/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/js/app.js":
/*!***********************!*\
  !*** ./src/js/app.js ***!
  \***********************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _files_forms_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./files/forms.js */ \"./src/js/files/forms.js\");\n/* harmony import */ var _files_functions_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./files/functions.js */ \"./src/js/files/functions.js\");\n/* harmony import */ var _libs_swiper_bundle_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./libs/swiper-bundle.js */ \"./src/js/libs/swiper-bundle.js\");\n/* harmony import */ var _files_sliders_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./files/sliders.js */ \"./src/js/files/sliders.js\");\n/* harmony import */ var _files_script_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./files/script.js */ \"./src/js/files/script.js\");\n/* harmony import */ var _files_popup_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./files/popup.js */ \"./src/js/files/popup.js\");\n/* js файлы теперь можем импортировать с других папок - \nimport * as flsFunctions from './modules/functions.js' \nвызывать flsFunctions.isWebp() */\n\n//======================================================================\n\n\n// В script.js подключаются дополнительные функции slide, webp, ibg...\n// import './files/dynamic_adapt.js';\n;\n\n\n\n\n\n// import './files/regular.js';\n//======================================================================\n\n//# sourceURL=webpack://funiro/./src/js/app.js?");

/***/ }),

/***/ "./src/js/files/forms.js":
/*!*******************************!*\
  !*** ./src/js/files/forms.js ***!
  \*******************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"_slideUp\": () => (/* binding */ _slideUp),\n/* harmony export */   \"_slideDown\": () => (/* binding */ _slideDown),\n/* harmony export */   \"_slideToggle\": () => (/* binding */ _slideToggle)\n/* harmony export */ });\n/* harmony import */ var _files_popup_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../files/popup.js */ \"./src/js/files/popup.js\");\n//<QUANTITY>======================================================================\nlet quantityButtons = document.querySelectorAll('.quantity__button');\nif (quantityButtons.length > 0) {\n\tfor (let index = 0; index < quantityButtons.length; index++) {\n\t\tconst quantityButton = quantityButtons[index];\n\n\t\tquantityButton.addEventListener(\"click\", function (e) {\n\t\t\tlet value = parseInt(quantityButton.closest('.quantity').querySelector('input').value);\n\t\t\tif (quantityButton.classList.contains('quantity__button_plus')) {\n\t\t\t\tvalue++;\n\t\t\t} else {\n\t\t\t\tvalue = value - 1;\n\t\t\t\tif (value < 1) {\n\t\t\t\t\tvalue = 1\n\t\t\t\t}\n\t\t\t}\n\t\t\tquantityButton.closest('.quantity').querySelector('input').value = value;\n\t\t});\n\t}\n}\n//</QUANTITY>======================================================================\n\n//<FORM>======================================================================\n// *** Работа с формами ***\nconst forms = document.querySelectorAll('form');\nconst dataValue = document.querySelectorAll('[data-value]');\n\n// Заполняю плейсхолдер формы с data-value\nif (dataValue.length > 0) {\n\tfor (let item of dataValue) {\n\t\titem.placeholder = item.dataset.value;\n\t}\n}\n// Навешую слушателей на формы\nif (forms.length > 0) {\n\tfor (let form of forms) {\n\t\tform.addEventListener('submit', formSend);\n\n\t\t// *** Отправляет форму, добавить async перед функцией ***\n\t\tasync function formSend(e) {\n\t\t\tlet btn = event.target;\n\t\t\tlet form = btn.closest('form');\n\t\t\tlet message = form.getAttribute('data-message');\n\n\t\t\te.preventDefault();\n\t\t\t// делаю валидацию\n\t\t\tlet error = 0;\n\t\t\tlet formData;\n\t\t\tif (forms.length > 0) {\n\t\t\t\tfor (let form of forms) {\n\t\t\t\t\t// error = formValidate(form);\n\t\t\t\t\terror = form_validate_input(form);\n\t\t\t\t\t// получаю данные с полей формы\n\t\t\t\t\tformData = new FormData(form);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// formData.append('image', formImage.files[0])\n\t\t\tif (error === 0) {\n\t\t\t\t//SendForm\n\t\t\t\tform_clean(form);\n\t\t\t\tif (message) {\n\t\t\t\t\t// console.log(message + '-message');\n\t\t\t\t\t(0,_files_popup_js__WEBPACK_IMPORTED_MODULE_0__.topopUp)(message + '-message');\n\t\t\t\t\t// popupOpen('message-' + message);\n\t\t\t\t\te.preventDefault();\n\t\t\t\t}\n\t\t\t\tform.classList.add('_sending');\n\t\t\t\t// let response = await fetch('sendmail.php', {\n\t\t\t\t//   method: 'POST',\n\t\t\t\t//   body: formData,\n\t\t\t\t// })\n\t\t\t\t// //отправляю форму\n\t\t\t\t// if (response.ok) {\n\t\t\t\t//   let result = await response.json()\n\t\t\t\t//   alert(result.message)\n\t\t\t\t//   formPreview.innerHTML = ''\n\t\t\t\t//   form.reset()\n\t\t\t\t//   form.classList.remove('_sending')\n\t\t\t\t// } else {\n\t\t\t\t//   alert('Ошибка')\n\t\t\t\t//   form.classList.remove('_sending')\n\t\t\t\t// }\n\n\t\t\t\t// Временно\n\t\t\t\t// const popupMessage = document.querySelector('.popup_subscribe-message');\n\t\t\t\t// popupMessage.classList.add('open');\n\t\t\t} else {\n\t\t\t\tlet form_error = form.querySelectorAll('._error');\n\t\t\t\tif (form_error && form.classList.contains('_goto-error')) {\n\t\t\t\t\t_goto(form_error[0], 1000, 50);\n\t\t\t\t}\n\t\t\t\tevent.preventDefault();\n\t\t\t\talert('Заполните обязательные поля');\n\t\t\t\t// const errorElement = element('span', ['form__error'], 'Ошибка');\n\t\t\t\t// const formError = document.querySelector('form__error');\n\t\t\t\t// formError.append(errorElement);\n\t\t\t}\n\t\t}\n\t}\n}\n// *** валидирует формы ***\nfunction formValidate(form) {\n\tlet error = 0;\n\tlet formReq = document.querySelectorAll('._req');\n\tif (formReq.length > 0) {\n\t\tfor (let index = 0; index < formReq.length; index++) {\n\t\t\tconst input = formReq[index];\n\t\t\tform_remove_error(input);\n\t\t\t// if (!_is_hidden(input)) {\n\t\t\t// \terror += form_validate_input(input)\n\t\t\t// }\n\t\t\tif (input.classList.contains('_email')) {\n\t\t\t\tif (email_test(input)) {\n\t\t\t\t\tform_add_error(input);\n\t\t\t\t\terror++;\n\t\t\t\t}\n\t\t\t} else if (input.getAttribute('type') === 'checkbox' && input.checked === false) {\n\t\t\t\tform_add_error(input);\n\t\t\t\terror++;\n\t\t\t} else {\n\t\t\t\tif (input.value === '') {\n\t\t\t\t\tform_add_error(input);\n\t\t\t\t\terror++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn error;\n}\n\nfunction form_validate_input(input) {\n\tlet error = 0;\n\tlet input_g_value = input.getAttribute('data-value');\n\n\t// \n\n\tlet formReq = document.querySelectorAll('._req');\n\tif (formReq.length > 0) {\n\t\tfor (let index = 0; index < formReq.length; index++) {\n\t\t\tconst input = formReq[index];\n\t\t\tform_remove_error(input);\n\t\t\t// if (!_is_hidden(input)) {\n\t\t\t// \terror += form_validate_input(input)\n\t\t\t// }\n\t\t\tif (input.classList.contains('_email')) {\n\t\t\t\tif (input.value != input_g_value) {\n\t\t\t\t\tlet em = input.value.replace(\" \", \"\");\n\t\t\t\t\tinput.value = em;\n\t\t\t\t}\n\t\t\t\tif (email_test(input)) {\n\t\t\t\t\tform_add_error(input);\n\t\t\t\t\terror++;\n\t\t\t\t} else {\n\t\t\t\t\tform_remove_error(input);\n\t\t\t\t}\n\t\t\t} else if (input.getAttribute('type') === 'checkbox' && input.checked === false) {\n\t\t\t\tform_add_error(input);\n\t\t\t\terror++;\n\t\t\t} else {\n\t\t\t\tif (input.value == '' || input.value == input_g_value) {\n\t\t\t\t\tform_add_error(input);\n\t\t\t\t\terror++;\n\t\t\t\t} else {\n\t\t\t\t\tform_remove_error(input);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn error;\n}\n// \n\n\n// if (input.getAttribute(\"name\") == \"email\" || input.classList.contains(\"_email\")) {\n// if (input.value != input_g_value) {\n// \tlet em = input.value.replace(\" \", \"\");\n// \tinput.value = em;\n// }\n// if (email_test(input) || input.value == input_g_value) {\n// \tform_add_error(input);\n// \terror++;\n// } else {\n// \tform_remove_error(input);\n// }\n// } else if (input.getAttribute(\"type\") == \"checkbox\" && input.checked == false) {\n// \tform_add_error(input);\n// \terror++;\n// } else {\n// if (input.value == '' || input.value == input_g_value) {\n// \tform_add_error(input);\n// \terror++;\n// } else {\n// \tform_remove_error(input);\n// }\n// }\n// return error;\n// }\n\nfunction form_add_error(input) {\n\tinput.classList.add('_error');\n\tinput.parentElement.classList.add('_error');\n\n\tlet input_error = input.parentElement.querySelector('.form__error');\n\tif (input_error) {\n\t\tinput.parentElement.removeChild(input_error);\n\t}\n\tlet input_error_text = input.getAttribute('data-error');\n\tif (input_error_text && input_error_text != '') {\n\t\tinput.parentElement.insertAdjacentHTML('beforeend', '<div class=\"form__error\">' + input_error_text + '</div>');\n\t}\n}\nfunction form_remove_error(input) {\n\tinput.classList.remove('_error');\n\tinput.parentElement.classList.remove('_error');\n\n\tlet input_error = input.parentElement.querySelector('.form__error');\n\tif (input_error) {\n\t\tinput.parentElement.removeChild(input_error);\n\t}\n}\n//  Добавляет и удаляет класс _error у формы и инпута \n// function formAddError(input) {\n// \tinput.parentElement.classList.add('_error');\n// \tinput.classList.add('_error');\n// }\n\n// function formRemoveError(input) {\n// \tinput.parentElement.classList.remove('_error');\n// \tinput.classList.remove('_error');\n// }\n\nfunction form_clean(form) {\n\tlet inputs = form.querySelectorAll('input,textarea');\n\tfor (let index = 0; index < inputs.length; index++) {\n\t\tconst el = inputs[index];\n\t\tel.parentElement.classList.remove('_focus');\n\t\tel.classList.remove('_focus');\n\t\tel.value = el.getAttribute('data-value');\n\t}\n\tlet checkboxes = form.querySelectorAll('.checkbox__input');\n\tif (checkboxes.length > 0) {\n\t\tfor (let index = 0; index < checkboxes.length; index++) {\n\t\t\tconst checkbox = checkboxes[index];\n\t\t\tcheckbox.checked = false;\n\t\t}\n\t}\n\n\tlet selects = form.querySelectorAll('select');\n\tif (selects.length > 0) {\n\t\tfor (let index = 0; index < selects.length; index++) {\n\t\t\tconst select = selects[index];\n\t\t\tconst select_default_value = select.getAttribute('data-default');\n\t\t\tselect.value = select_default_value;\n\t\t\tselect_item(select);\n\t\t}\n\t}\n}\n\n// *** Функция теста email ***\nfunction email_test(input) {\n\treturn !/^\\w+([\\.-]?\\w+)*@\\w+([\\.-]?\\w+)*(\\.\\w{2,8})+$/.test(input.value)\n}\n\nlet viewPass = document.querySelectorAll('.form__viewpass');\nfor (let index = 0; index < viewPass.length; index++) {\n\tconst element = viewPass[index];\n\telement.addEventListener(\"click\", function (e) {\n\t\tif (element.classList.contains('_active')) {\n\t\t\telement.parentElement.querySelector('input').setAttribute(\"type\", \"password\");\n\t\t} else {\n\t\t\telement.parentElement.querySelector('input').setAttribute(\"type\", \"text\");\n\t\t}\n\t\telement.classlist.toggle('_active');\n\t});\n}\n\n// import { popupOpen } from \"../files/popup.js\";\n//</FORM>======================================================================\n\n//<SELECT>======================================================================\nlet selects = document.getElementsByTagName('select'); //получаем элемент по имени тега\nif (selects.length > 0) { //если есть хотябы один\n\tselects_init(); //вызываем инициализацию\n}\nfunction selects_init() { //инициализация\n\tfor (let index = 0; index < selects.length; index++) { //проходим циклом \n\t\tconst select = selects[index]; //каждый найденный selects кладем в константу select\n\t\tselect_init(select); //вызов c параметром найденного select\n\t}\n\t//select_caLlback();\n\tdocument.addEventListener('click', function (e) { //вешам событие по клику \n\t\tselects_close(e); //вызов функции закрытия c параметром нажатия \n\t}); //получается фунция закрывает открытый select если нажимается клавиша мыши\n\tdocument.addEventListener('keydown', function (e) { //при нажатии...\n\t\tif (e.which == 27) { //клавиши Esc\n\t\t\tselects_close(e); //получается фунция закрывает открытый select если нажимается кнопка Esc\n\t\t}\n\t});\n}\nfunction selects_close(e) {\n\tconst selects = document.querySelectorAll('.select'); //получаем коллекцию всех елементов c классом .select\n\tif (!e.target.closest('.select')) {\n\t\tfor (let index = 0; index < selects.length; index++) {\n\t\t\tconst select = selects[index];\n\t\t\tconst select_body_options = select.querySelector('.select__options');\n\t\t\tselect.classList.remove('_active');\n\t\t\t_slideUp(select_body_options, 100);\n\t\t}\n\t}\n}\nfunction select_init(select) {\n\tconst select_parent = select.parentElement;\n\tconst select_modifikator = select.getAttribute('class');\n\tconst select_selected_option = select.querySelector('option:checked');//находим веделенный option\n\n\tselect.setAttribute('data-default', select_selected_option.value);//устанавливает data-defoult значение выделенного option\n\tselect.style.display = 'none';//скрываем селект\n\n\tselect_parent.insertAdjacentHTML('beforeend', '<div class=\"select select_' + select_modifikator + '\"></div>');//добавляем блок селекта \n\n\tlet new_select = select.parentElement.querySelector('.select');\n\n\tnew_select.appendChild(select);\n\tselect_item(select);\n}\nfunction select_item(select) {\n\tconst select_parent = select.parentElement; // родитель, блок select\n\tconst select_items = select_parent.querySelector('.select__item');//находим в родителе \n\tconst select_options = select.querySelectorAll('option');\n\tconst select_selected_option = select.querySelector('option:checked');\n\tconst select_selected_text = select_selected_option.text;\n\tconst select_type = select.getAttribute('data-type');\n\n\tif (select_items) {\n\t\tselect_items.remove();\n\t}\n\n\tlet select_type_content = '';\n\tif (select_type == 'input') {\n\t\tselect_type_content = '<div class=\"select__value\"><input>' + select_selected_text + '</input></div>';\n\t} else {\n\t\tselect_type_content = '<div class=\"select__value\"><span>' + select_selected_text + '</span></div>';\n\t}\n\n\tselect_parent.insertAdjacentHTML('beforeend',\n\t\t'<div class=\"select__item\">' +\n\t\t'<div class=\"select__title\">' + select_type_content + '</div>' +\n\t\t'<div class=\"select__options\">' + select_get_options(select_options) +\n\t\t'</div></div>');\n\n\tselect_actions(select, select_parent);\n}\nfunction select_actions(original, select) {\n\tconst select_item = select.querySelector('.select__item');\n\tconst select_body_options = select.querySelector('.select__options');\n\tconst select_options = select.querySelectorAll('.select__option');\n\tconst select_type = original.getAttribute('data-type');\n\tconst select_input = select.querySelector('.select__input');\n\n\tselect_item.addEventListener('click', function () {\n\t\tlet selects = document.querySelectorAll('.select');\n\t\tfor (let index = 0; index < selects.length; index++) {\n\t\t\tconst select = selects[index];\n\t\t\tconst select_body_options = select.querySelector('.select__options');\n\t\t\tif (select != select_item.closest('.select')) {\n\t\t\t\tselect.classList.remove('_active');\n\t\t\t\t_slideUp(select_body_options, 100);\n\t\t\t}\n\t\t}\n\t\t_slideToggle(select_body_options, 100);\n\t\tselect.classList.toggle('_active');\n\t});\n\n\tfor (let index = 0; index < select_options.length; index++) {\n\t\tconst select_option = select_options[index];\n\t\tconst select_option_value = select_option.getAttribute('data-value');\n\t\tconst select_option_text = select_option.innerHTML;\n\n\t\tif (select_type == 'input') {\n\t\t\tselect_input.addEventListener('keyup', select_search)\n\t\t} else {\n\t\t\tif (select_option.getAttribute('data-value') == original.getAttribute('data-default')) {\n\t\t\t\tselect_option.style.display = 'none';\n\t\t\t}\n\t\t}\n\n\t\tselect_option.addEventListener('click', function () {\n\t\t\tfor (let index = 0; index < select_options.length; index++) {\n\t\t\t\tconst el = select_options[index];\n\t\t\t\tel.style.display = 'block';\n\t\t\t}\n\t\t\tif (select_type == 'input') {\n\t\t\t\tselect_input.value = select_option_text;\n\t\t\t\toriginal.value = select_option_value;\n\t\t\t} else {\n\t\t\t\tselect.querySelector('.select__value').innerHTML = select_option_text;\n\t\t\t\toriginal.value = select_option_value;\n\t\t\t\tselect_option.style.display = 'none';\n\t\t\t}\n\t\t});\n\t}\n}\nfunction select_get_options(select_options) {\n\tif (select_options) {\n\t\tlet select_options_content = '';\n\t\tfor (let index = 0; index < select_options.length; index++) {\n\t\t\tconst select_option = select_options[index];\n\t\t\tconst select_option_value = select_option.value;\n\n\t\t\tif (select_option_value != '') {\n\t\t\t\tconst select_option_text = select_option.text;\n\t\t\t\tselect_options_content = select_options_content + '<div data-value=\"' + select_option_value + '\" class=\"select__option\">' + select_option_text + '</div>';\n\t\t\t}\n\t\t}\n\t\treturn select_options_content;\n\t}\n}\nfunction select_search(e) {\n\tlet select_block = e.target.closest('.select ').querySelector('.search');\n\tlet select_options = e.target.closest('.select ').querySelector('options');\n\tlet select_search_text = e.target.value.toUpperCase();\n\n\tfor (let i = 0; i < select_options.length; i++) {\n\t\tlet select_option = select_options[i];\n\t\tlet select_txt_value = select_option.textContent || select_search_text;\n\t\tif (select_txt_value.toUpperCase().indexOf(select_search_text)) {\n\t\t\tselect_option.style.display = \"\";\n\t\t} else {\n\t\t\tselect_option.style.display = \"none\";\n\t\t}\n\t}\n}\nfunction selects_update_all() {\n\tlet selects = document.querySelectorAll('select');\n\tif (selects) {\n\t\tfor (let index = 0; index < selects.length; index++) {\n\t\t\tconst select = selects[index];\n\t\t\tselect_item(select);\n\t\t}\n\t}\n}\n//</SELECT>======================================================================\n\n//<DATA-SPOLLERS>======================================================================\n// data-spollers - функция реализует адаптивный аккордеон \n// с data атрибутами data-spoller (добавляет класс true)\n// spollers\nconst spollersArray = document.querySelectorAll('[data-spollers]');\nif (spollersArray.length > 0) {\n\t// Получение обычных спойлеров\n\tconst spollersRegular = Array.from(spollersArray).filter(\n\t\t(item, index, self) => {\n\t\t\treturn !item.dataset.spollers.split(',')[0];\n\t\t}\n\t);\n\t// Инициализация обычных спойлеров\n\tif (spollersRegular.length > 0) {\n\t\tinitSpollers(spollersRegular);\n\t}\n\n\t// Получение спойлеров с медиа запросами\n\tconst spollersMedia = Array.from(spollersArray).filter(\n\t\t(item, index, self) => {\n\t\t\treturn item.dataset.spollers.split(',')[0];\n\t\t}\n\t);\n\n\t// Инициализация спойлеров с медиа запросами\n\tif (spollersMedia.length > 0) {\n\t\tconst breakpointsArray = [];\n\t\tspollersMedia.forEach((item) => {\n\t\t\tconst params = item.dataset.spollers;\n\t\t\tconst breakpoint = {};\n\t\t\tconst paramsArray = params.split(',');\n\t\t\tbreakpoint.value = paramsArray[0];\n\t\t\tbreakpoint.type = paramsArray[1] ? paramsArray[1].trim() : 'max';//трим удаляет пробелы\n\t\t\tbreakpoint.item = item;\n\t\t\tbreakpointsArray.push(breakpoint);\n\t\t});\n\n\t\t// Получаю уникальные брекпоинты\n\t\tlet mediaQueries = breakpointsArray.map((item) => {\n\t\t\treturn ('(' + item.type + '-width: ' + item.value + 'px),' + item.value + ',' + item.type)\n\t\t});\n\n\t\tmediaQueries = mediaQueries.filter((item, index, self) => {\n\t\t\treturn self.indexOf(item) === index;\n\t\t});\n\t\t// Работа с каждым брекпоинтом\n\t\tmediaQueries.forEach((breakpoint) => {\n\t\t\tconst paramsArray = breakpoint.split(',');//разделит строку позапятой на масс объектов\n\t\t\tconst mediaBreakpoint = paramsArray[1];\n\t\t\tconst mediaType = paramsArray[2];\n\t\t\tconst matchMedia = window.matchMedia(paramsArray[0]);//получение в медиазапрос\n\n\t\t\t// Обьекты с нужными условиями\n\t\t\tconst spollersArray = breakpointsArray.filter((item) => {\n\t\t\t\tif (item.value === mediaBreakpoint && item.type === mediaType) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t});\n\t\t\t// Событие\n\t\t\tmatchMedia.addListener(function () {\n\t\t\t\tinitSpollers(spollersArray, matchMedia);\n\t\t\t});\n\t\t\tinitSpollers(spollersArray, matchMedia);\n\t\t});\n\t}\n\t// Инициализация\n\tfunction initSpollers(spollersArray, matchMedia = false) {\n\t\tspollersArray.forEach((spollersBlock) => {\n\t\t\tspollersBlock = matchMedia ? spollersBlock.item : spollersBlock;\n\t\t\tif (matchMedia.matches || !matchMedia) { //matchMedia.matches возвращает true если возможен медиазапрос\n\t\t\t\tspollersBlock.classList.add('_init');\n\t\t\t\tinitSpollerBody(spollersBlock);\n\t\t\t\tspollersBlock.addEventListener('click', setSpollerAction);\n\t\t\t} else {\n\t\t\t\tspollersBlock.classList.remove('_init');\n\t\t\t\tinitSpollerBody(spollersBlock, false);\n\t\t\t\tspollersBlock.removeEventListener('click', setSpollerAction);\n\t\t\t}\n\t\t});\n\t}\n\n\t// Работа с контентом\n\tfunction initSpollerBody(spollersBlock, hideSpollerBody = true) {\n\t\tconst spollerTitles = spollersBlock.querySelectorAll('[data-spoller]');\n\t\tif (spollerTitles.length > 0) {\n\t\t\tspollerTitles.forEach((spollerTitle) => {\n\t\t\t\tif (hideSpollerBody) {\n\t\t\t\t\tspollerTitle.removeAttribute('tabindex');\n\t\t\t\t\tif (!spollerTitle.classList.contains('_active')) {\n\t\t\t\t\t\tspollerTitle.nextElementSibling.hidden = true;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tspollerTitle.setAttribute('tabindex', '-1');\n\t\t\t\t\tspollerTitle.nextElementSibling.hidden = false;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\n\tfunction setSpollerAction(e) {\n\t\tconst el = e.target;\n\t\tif (el.hasAttribute('data-spoller') || el.closest('[data-spoller]')) {\n\t\t\tconst spollerTitle = el.hasAttribute('data-spoller') ? el : el.closest('[data-spoller]');\n\t\t\tconst spollersBlock = spollerTitle.closest('[data-spollers]');\n\t\t\tconst oneSpoller = spollersBlock.hasAttribute('data-one-spoller') ? true : false; //проверяем наличие атрибута\n\t\t\tif (!spollersBlock.querySelectorAll('._slide').length) {\n\t\t\t\tif (oneSpoller && !spollerTitle.classList.contains('_active')) {\n\t\t\t\t\thideSpollersBody(spollersBlock);\n\t\t\t\t}\n\t\t\t\tspollerTitle.classList.toggle('_active');\n\t\t\t\t_slideToggle(spollerTitle.nextElementSibling, 500);\n\t\t\t}\n\t\t\te.preventDefault();\n\t\t}\n\t}\n\n\tfunction hideSpollersBody(spollersBlock) {\n\t\tconst spollerActiveTitle = spollersBlock.querySelector('[data-spoller]._active');\n\t\tif (spollerActiveTitle) {\n\t\t\tspollerActiveTitle.classList.remove('_active');\n\t\t\t_slideUp(spollerActiveTitle.nextElementSibling, 500);\n\t\t}\n\t}\n}\n/*\nДля родителя спойлера пишем атрибут data-spollers\nДля заголовков слайдеров пишем атрибут data-spoller\nЕсли нужно обеспечить работу спойлеров на всех размерах экранов пишем data-spollers без параметров\nЕсли нужно выключить\\включить работу спойлеров на разных размерах экранов пишем параметры ширины и типа брекпоинта.\nНапример:\ndata-spollers=\"992,max\" - спойлеры будут работать только на экранах меньше или равно 992px\ndata-spollers=\"768,min\" - спойлеры будут работать только на экранах больше или равно 768px\nЕсли нужно чтобы в блоке открывалься только один спойлер добавляем атрибут data-one-spoller\n*/\n//</DATA-SPOLLERS>======================================================================\n\n//<ANIM-SLIDE>================================================================\n//   Анимированное плавное открытие и закрытие блока.\n// Может применяться к меню или выпадающему списку\n// Выписано из видео фрилансера.\n// В CSS нужно установить display: none; для родителя.\n\n// SlideUP\n// let _slideUp = (target, duration = 500) => {\nlet _slideUp = (target, duration = 500) => {\n\ttarget.style.transitionProperty = 'height, margin, padding';\n\ttarget.style.transitionDuration = duration + 'ms';\n\ttarget.style.height = target.offsetHeight + 'px';\n\ttarget.offsetHeight;\n\ttarget.style.overflow = 'hidden';\n\ttarget.style.height = 0;\n\ttarget.style.paddingTop = 0;\n\ttarget.style.paddingBottom = 0;\n\ttarget.style.marginTop = 0;\n\ttarget.style.marginBottom = 0;\n\twindow.setTimeout(() => {\n\t\ttarget.style.display = 'none';\n\t\ttarget.style.removeProperty('height');\n\t\ttarget.style.removeProperty('padding-top');\n\t\ttarget.style.removeProperty('padding-bottom');\n\t\ttarget.style.removeProperty('margin-top');\n\t\ttarget.style.removeProperty('margin-bottom');\n\t\ttarget.style.removeProperty('overflow');\n\t\ttarget.style.removeProperty('transition-duration');\n\t\ttarget.style.removeProperty('transition-property');\n\t\ttarget.classList.remove('_slide');\n\t}, duration);\n};\n// SlideDown\n// let _slideDown = (target, duration = 500) => {\nlet _slideDown = (target, duration = 500) => {\n\ttarget.style.removeProperty('display');\n\tlet display = window.getComputedStyle(target).display;\n\tif (display === 'none') {\n\t\tdisplay = 'block';\n\t}\n\ttarget.style.display = display;\n\tlet height = target.offsetHeight;\n\ttarget.style.overflow = 'hidden';\n\ttarget.style.height = 0;\n\ttarget.style.paddingTop = 0;\n\ttarget.style.paddingBottom = 0;\n\ttarget.style.marginTop = 0;\n\ttarget.style.marginBottom = 0;\n\ttarget.offsetHeight;\n\ttarget.style.transitionProperty = 'height, margin, padding';\n\ttarget.style.transitionDuration = duration + 'ms';\n\ttarget.style.height = height + 'px';\n\ttarget.style.removeProperty('padding-top');\n\ttarget.style.removeProperty('padding-bottom');\n\ttarget.style.removeProperty('margin-top');\n\ttarget.style.removeProperty('margin-bottom');\n\twindow.setTimeout(() => {\n\t\ttarget.style.removeProperty('height');\n\t\ttarget.style.removeProperty('overflow');\n\t\ttarget.style.removeProperty('transition-duration');\n\t\ttarget.style.removeProperty('transition-property');\n\t\ttarget.classList.remove('_slide');\n\t}, duration);\n};\n//SlideToggLe\n// let _slideToggle = (target, duration = 500) => {\nlet _slideToggle = (target, duration = 500) => {\n\tif (!target.classList.contains('_slide')) {\n\t\ttarget.classList.add('_slide');\n\t\t// if (target.hidden) {\n\t\tif (window.getComputedStyle(target).display === 'none') {\n\t\t\treturn _slideDown(target, duration);\n\t\t} else {\n\t\t\treturn _slideUp(target, duration);\n\t\t}\n\t}\n};\n//</ANIM-SLIDE>================================================================\n\n//добавление картинки======================================================================\n/* const formImage = document.getElementById('formImage');\nconst formPreview = document.getElementById('formPreview');\nformImage.addEventListener(\"change\", () => {\n\tuploadFile(formImage.files[0]);\n});\n\nfunction uploadFile(file) {\n\t// провераяем тип файла\n\tif (!['image/jpeg', 'image/png', 'image/gif'].includes(file.type)) {\n\t\talert('Разрешены только изображения.');\n\t\tformImage.value = '';\n\t\treturn;\n\t}\n\t// проверим размер файла (<2 Мб)\n\tif (file.size > 2 * 1024 * 1024) {\n\t\talert('Файл должен быть менее 2 МБ. ');\n\t\treturn;\n\t}\n\n\tvar reader = new FileReader();\n\treader.onload = function (e) {\n\t\tformPreview.innerHTML = `<img src=\"${e.target.result}\" alt=\"Фoтo\">`;\n\t};\n\treader.onerror = function (e) {\n\t\talert('Ошибка');\n\t};\n\treader.readAsDataURL(file);\n} */\n//======================================================================\n\n//# sourceURL=webpack://funiro/./src/js/files/forms.js?");

/***/ }),

/***/ "./src/js/files/functions.js":
/*!***********************************!*\
  !*** ./src/js/files/functions.js ***!
  \***********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"isWebp\": () => (/* binding */ isWebp),\n/* harmony export */   \"ibg\": () => (/* binding */ ibg),\n/* harmony export */   \"isMobile\": () => (/* binding */ isMobile)\n/* harmony export */ });\n//<IsWEBP>================================================================\n//   Проверка поддержки webp.\n// Добавление класса webp или no-webp для HTML\n// в зависимости от поддержки браузером\n\nfunction isWebp() {\n\t// Проверка поддержки webp\n\tfunction testWebP(callback) {\n\t\tlet webP = new Image();\n\t\twebP.onload = webP.onerror = function () {\n\t\t\tcallback(webP.height == 2);\n\t\t};\n\t\twebP.src =\n\t\t\t'data:image/webp;base64,UklGRjoAAABXRUJQVlA4IC4AAACyAgCdASoCAAIALmk0mk0iIiIiIgBoSygABc6WWgAA/veff/0PP8bA//LwYAAA'\n\t};\n\t// Добавление класса _webp или _no-webp для HTML\n\ttestWebP(function (support) {\n\t\tlet className = (support === true) ? 'webp' : 'no-webp';\n\t\tdocument.documentElement.classList.add(className);\n\t});\n}\nisWebp();\n//</IsWEBP>================================================================\n\n//<IE Ibg>================================================================\n// Адаптивное изображение для IE Ibg.\n// Для корректного отображения картинок в Internet Explorer добавляет класс\n// .ibg и применяет атрибут background для упрощения адаптива.\n\nfunction ibg() {\n\t// if (isIE()) {\n\tlet ibg = document.querySelectorAll('._ibg');\n\tfor (let i = 0; i < ibg.length; i++) {\n\t\tif (ibg[i].querySelector('img')) {\n\t\t\tibg[i].style.backgroundImage =\n\t\t\t\t'url(' + ibg[i].querySelector('img').getAttribute('src') + ')';\n\t\t}\n\t\t// }\n\t}\n}\nibg();\n\nlet ua = window.navigator.userAgent;\nlet msie = ua.indexOf(\"MSIE \");\nfunction isIE() {\n\tua = navigator.userAgent;\n\tlet is_ie = ua.indexOf(\"MSIE \") > -1 || ua.indexOf(\"Trident/\") > -1;\n\treturn is_ie;\n}\n//</IE Ibg>======================================================================\n\n//<isMobile>================================================================\n//Проверка на каком устройстве работаем\nconst isMobile = {\n\tAndroid: function () {\n\t\treturn navigator.userAgent.match(/Android/i);\n\t},\n\tBlackBerry: function () {\n\t\treturn navigator.userAgent.match(/BlackBerry/i);\n\t},\n\tiOS: function () {\n\t\treturn navigator.userAgent.match(/iPhone|iPad|iPod/i);\n\t},\n\tOpera: function () {\n\t\treturn navigator.userAgent.match(/Opera Mini/i);\n\t},\n\tWindows: function () {\n\t\treturn navigator.userAgent.match(/IEMobile/i);\n\t},\n\tany: function () {\n\t\treturn (\n\t\t\tisMobile.Android() ||\n\t\t\tisMobile.BlackBerry() ||\n\t\t\tisMobile.iOS() ||\n\t\t\tisMobile.Opera() ||\n\t\t\tisMobile.Windows());\n\t}\n};\nif (isMobile.any()) {\n\tdocument.body.classList.add('_touch');\n} else {\n\tdocument.body.classList.add('_pc');\n}\n// Возвращает мобильный с которого зашли\n// export const isMobile = function () {\n// \tvar check = false;\n// \t(function (a) {\n// \t\tif (\n// \t\t\t/(android|bb\\d+|meego).+mobile|avantgo|bada\\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(\n// \t\t\t\ta\n// \t\t\t) ||\n// \t\t\t/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\\-(n|u)|c55\\/|capi|ccwa|cdm\\-|cell|chtm|cldc|cmd\\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\\-s|devi|dica|dmob|do(c|p)o|ds(12|\\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\\-|_)|g1 u|g560|gene|gf\\-5|g\\-mo|go(\\.w|od)|gr(ad|un)|haie|hcit|hd\\-(m|p|t)|hei\\-|hi(pt|ta)|hp( i|ip)|hs\\-c|ht(c(\\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\\-(20|go|ma)|i230|iac( |\\-|\\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\\/)|klon|kpt |kwc\\-|kyo(c|k)|le(no|xi)|lg( g|\\/(k|l|u)|50|54|\\-[a-w])|libw|lynx|m1\\-w|m3ga|m50\\/|ma(te|ui|xo)|mc(01|21|ca)|m\\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\\-2|po(ck|rt|se)|prox|psio|pt\\-g|qa\\-a|qc(07|12|21|32|60|\\-[2-7]|i\\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\\-|oo|p\\-)|sdk\\/|se(c(\\-|0|1)|47|mc|nd|ri)|sgh\\-|shar|sie(\\-|m)|sk\\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\\-|v\\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\\-|tdg\\-|tel(i|m)|tim\\-|t\\-mo|to(pl|sh)|ts(70|m\\-|m3|m5)|tx\\-9|up(\\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\\-|your|zeto|zte\\-/i.test(\n// \t\t\t\ta.substr(0, 4)\n// \t\t\t)\n// \t\t)\n// \t\t\tcheck = true;\n// \t})(navigator.userAgent || navigator.vendor || window.opera)\n// \treturn check;\n// };\n// возвращает true если зашли с мобильного\n// export const isMobileOrTablet = function () {\n// \tvar check = false\n// \t\t; (function (a) {\n// \t\t\tif (\n// \t\t\t\t/(android|bb\\d+|meego).+mobile|avantgo|bada\\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i.test(\n// \t\t\t\t\ta\n// \t\t\t\t) ||\n// \t\t\t\t/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\\-(n|u)|c55\\/|capi|ccwa|cdm\\-|cell|chtm|cldc|cmd\\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\\-s|devi|dica|dmob|do(c|p)o|ds(12|\\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\\-|_)|g1 u|g560|gene|gf\\-5|g\\-mo|go(\\.w|od)|gr(ad|un)|haie|hcit|hd\\-(m|p|t)|hei\\-|hi(pt|ta)|hp( i|ip)|hs\\-c|ht(c(\\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\\-(20|go|ma)|i230|iac( |\\-|\\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\\/)|klon|kpt |kwc\\-|kyo(c|k)|le(no|xi)|lg( g|\\/(k|l|u)|50|54|\\-[a-w])|libw|lynx|m1\\-w|m3ga|m50\\/|ma(te|ui|xo)|mc(01|21|ca)|m\\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\\-2|po(ck|rt|se)|prox|psio|pt\\-g|qa\\-a|qc(07|12|21|32|60|\\-[2-7]|i\\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\\-|oo|p\\-)|sdk\\/|se(c(\\-|0|1)|47|mc|nd|ri)|sgh\\-|shar|sie(\\-|m)|sk\\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\\-|v\\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\\-|tdg\\-|tel(i|m)|tim\\-|t\\-mo|to(pl|sh)|ts(70|m\\-|m3|m5)|tx\\-9|up(\\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\\-|your|zeto|zte\\-/i.test(\n// \t\t\t\t\ta.substr(0, 4)\n// \t\t\t\t)\n// \t\t\t)\n// \t\t\t\tcheck = true\n// \t\t})(navigator.userAgent || navigator.vendor || window.opera)\n// \treturn check\n// }\n//</isMobile>================================================================\n\n//======================================================================\n//  функция трансформирует размер изображения с байт в нормальный размер\n// export function bytesToSize(bytes) {\n// \tconst sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB']\n// \tif (!bytes) {\n// \t\treturn '0 Byte'\n// \t}\n// \tconst i = parseInt(Math.floor(Math.log(bytes) / Math.log(1024)))\n// \treturn Math.round(bytes / Math.pow(1024, i)) + ' ' + sizes[i]\n// }\n//======================================================================\n\n//======================================================================\n//  функция создает HTML элементы\n// export const element = (tag, classes = [], content) => {\n// \tconst node = document.createElement(tag)\n\n// \tif (classes.length) {\n// \t\tnode.classList.add(...classes)\n// \t}\n\n// \tif (content) {\n// \t\tnode.insertAdjacentHTML('beforeend', content)\n// \t}\n\n// \treturn node\n// }\n//======================================================================\n\n//======================================================================\n//  Универсальная FETCH функция для работы с API используя промисы(resolve, reject) ***\n// export function sendRequest(method, url, body = null) {\n// \tconst headers = {\n// \t\t'Content-Type': 'application/json',\n// \t}\n\n// \t// метод принимает 2 параметра url и обьект настроек при GET\n// \treturn fetch(url, {\n// \t\tmethod: method,\n// \t\t// body: JSON.stringify(body),\n// \t\theaders: headers,\n// \t}).then((response) => {\n// \t\t//если все хорошо и флаг свойство ok в true\n// \t\tif (response.ok) {\n// \t\t\treturn response.json()\n// \t\t}\n\n// \t\t//обрабатываем ошибку\n// \t\treturn response.json().then((error) => {\n// \t\t\tconst e = new Error('Что-то пошло не так')\n// \t\t\te.data = error\n// \t\t\tthrow e\n// \t\t})\n// \t})\n// }\n//======================================================================\n\n//======================================================================\n//пример получения данных методом GET используя нашу функцию\n// sendRequest('GET', requestURL)\n//     .then(data => console.log(data))\n//     .catch(err => console.log(err))\n//======================================================================\n\n//======================================================================\n//  прокрутка сраницы => кнопка прокрутки вверх\n// window.addEventListener('scroll', () => {\n//   // высота экрана\n//   const windowScroll = window.innerHeight\n//   const btn = document.querySelector('.btn__scroll-top')\n//   if (pageYOffset > windowScroll) {\n//     btn.classList.add('btn__scroll-top--active')\n//     btn.addEventListener('click', (e) => {\n//       // передаю в функцию координаты кнопки относительно верха окна\n//       smothScroll(e.clientY)\n//     })\n//   } else {\n//     btn.classList.remove('btn__scroll-top--active')\n//   }\n// })\n//======================================================================\n\n//======================================================================\n// плавная прокрутка по координатам\n// export const smothScroll = (h) => {\n// \tlet i = h || 0;\n// \tif (i > 0) {\n// \t\tsetTimeout(() => {\n// \t\t\twindow.scrollTo(0, i);\n// \t\t\tsmothScroll(i - 20);\n// \t\t}, 10);\n// \t}\n// };\n//======================================================================\n\n//======================================================================\n//  удаляет клссы\n// export function removeClassest(arr, removeClass) {\n// \tif (arr.length > 0) {\n// \t\tfor (let item of arr) {\n// \t\t\titem.classList.remove(removeClass);\n// \t\t};\n// \t};\n// };\n//======================================================================\n\n//# sourceURL=webpack://funiro/./src/js/files/functions.js?");

/***/ }),

/***/ "./src/js/files/popup.js":
/*!*******************************!*\
  !*** ./src/js/files/popup.js ***!
  \*******************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"topopUp\": () => (/* binding */ topopUp),\n/* harmony export */   \"popupOpen\": () => (/* binding */ popupOpen)\n/* harmony export */ });\n//<POPUP>======================================================================\n//получаем все эл popup-link\nconst popupLinks = document.querySelectorAll('.popup-link');\n//получаем тег боди для лока\nconst body = document.querySelector('body');\n/*для избавления эффекта смещения контента когда появляется полоса\nпрокруткиДобавляем этот клас для всех фиксированых объектов*/\nconst lockPadding = document.querySelectorAll('._lock-padding');\n//для предотвращения двойных нажатий\nlet unlock = true;\n//связано с блокировкой скрола и равна transition\nconst timeout = 800;\n\n//======================================================================\nfunction topopUp(str) {\n\tlet popup_name = 'popup_' + str;\n\t// console.log(popup_name);\n\n\tconst popUps = document.querySelectorAll('.popup');\n\t// console.log(popUps);\n\tfor (let index = 0; index < popUps.length; index++) {\n\t\tconst popUp = popUps[index];\n\t\t// console.log(popUp.classList.contains(popup_name));\n\n\t\tif (popUp.classList.contains(popup_name)) {\n\t\t\tpopupOpen(popUp);\n\t\t}\n\t}\n\n}\n\n//======================================================================\n\n/*ВЕШАЕМ СОБЫТИЕ ПО КЛИКУ НА POPUP-LINK\nесли есть элементы*/\nif (popupLinks.length > 0) {\n\t//проходим массивом по всем эл \n\tfor (let index = 0; index < popupLinks.length; index++) {\n\t\t//каждый элементв переменную\n\t\tconst popupLink = popupLinks[index];\n\t\t//вешаем событие клик на popupLink\n\t\tpopupLink.addEventListener(\"click\", function (e) {\n\t\t\t//в переменную popupName кладём popupLink без знака #\n\t\t\tconst popupName = popupLink.getAttribute('href').replace('#', '');\n\t\t\t//в переменную cerentPopup елемент с id popupName\n\t\t\tconst curentPopup = document.getElementById(popupName);\n\t\t\t//полученный объект отправляем в функцию открытия попап\n\t\t\tpopupOpen(curentPopup);\n\t\t\t//предотвращение перезагрузки страницы при переходе по ссылке при открытии попап\n\t\t\te.preventDefault();\n\t\t});\n\t}\n}\n\n//ВЕШАЕМ СОБЫТИЕ ПО КЛИКУ НА КНОПКУ ЗАКРЫТИЯ ПОПАП\n//получаем все кнопки закрытия который находится внутри попап\nconst popupCloseIcon = document.querySelectorAll('.popup__close');\n//если есть\nif (popupCloseIcon.length > 0) {\n\t//перебираем\n\tfor (let index = 0; index < popupCloseIcon.length; index++) {\n\t\t//каждый в переменную el\n\t\tconst el = popupCloseIcon[index];\n\t\t//вешаем клик\n\t\tel.addEventListener(\"click\", function (e) {\n\t\t\t//отправляем в функ popupClose объект который является ближайшим родителем нажатого лемента с классом popup\n\t\t\tpopupClose(el.closest('.popup'));\n\t\t\t//предотвращение перезагрузки страницы при переходе по ссылке при открытии\n\t\t\te.preventDefault();\n\t\t});\n\t}\n}\n\n//ФУНКЦИЯ ОТКРЫТИЯ ПОПАП\n//объявляем функ передавая объект по индентификатору\nfunction popupOpen(curentPopup) {\n\t//если существует и разблокирован\n\tif (curentPopup && unlock) {\n\t\t//активный попап в переменную\n\t\tconst popupActive = document.querySelector('.popup._active');\n\t\t//если popupActive существует\n\t\tif (popupActive) {\n\t\t\t//отправляем в функ popupClose параметр popupActive=false т.е. закрываем попап\n\t\t\tpopupClose(popupActive, false);\n\t\t\t//иначе\n\t\t} else {\n\t\t\t//блочим body\n\t\t\tbodyLock();\n\t\t}\n\t\t// console.log(curentPopup);\n\n\t\t//добавляем класс open нашему попап\n\t\tcurentPopup.classList.add('_active');\n\t\t//вешаем событие при клике на попап\n\t\tcurentPopup.addEventListener(\"click\", function (e) {\n\t\t\t//если нажатие не на объект содержащий popup__content\n\t\t\tif (!e.target.closest('.popup__content')) {\n\t\t\t\t//в функцию закртия передаем ближайший объект содержщий popup\n\t\t\t\tpopupClose(e.target.closest('.popup'));\n\t\t\t}\n\t\t});\n\t}\n}\n/*ФУНКЦИЯ ЗАКРЫТИЯ ПОПАП\nпередаем активный объекти, а так же стоит ли использовать блокирование скрола в этот раз или нет\nэто нужно для того, чтобы мы могли открывать попап внутри попап*/\nfunction popupClose(popupActive, doUnlock = true) {\n\tif (unlock) {\n\t\t//у активного попапа убераем класс open\n\t\tpopupActive.classList.remove('_active');\n\t\t/*если есть открытый попап мы запрещаем ему выполнять bodyUnLock();\n\t\tтаким образом при открытом попапе и вновь вызванном скрол будет залочен и не разлочится*/\n\t\tif (doUnlock) {\n\t\t\tbodyUnLock();\n\t\t}\n\t}\n}\n\n//БЛОКИРОВКА BODY\nfunction bodyLock() {\n\t//внутренняя ширина окна минус ширина оболочки wrapper\n\t//Для избавления сдвига контента при появлении полосы прокрутки\n\tconst lockPaddingValue = window.innerWidth - document.querySelector('.wrapper').offsetWidth + 'px';\n\t//есть ли такие объекты\n\tif (lockPadding.length > 0) {\n\t\tfor (let index = 0; index < lockPadding.length; index++) {\n\t\t\t//каждый объект\n\t\t\tconst el = lockPadding[index];\n\t\t\t//добавляет в html стиль padding-right: для всех элементов с классом lock-padding\n\t\t\tel.style.paddingRight = lockPaddingValue;\n\t\t}\n\t}\n\t//добавляет в html стиль padding-right: для body\n\tbody.style.paddingRight = lockPaddingValue;\n\t//даем для body клас lock\n\tbody.classList.add('_lock');\n\n\t//на время лочим переменную unlock\n\tunlock = false;\n\t//через какое-то время\n\tsetTimeout(function () {\n\t\t//разблокируем\n\t\tunlock = true;\n\t\t//передаем заданное время с помощью переменной\n\t}, timeout);\n}\n\n//ОТКРЫТИЕ СКРОЛА И УБИРАНИЕ ПАДДИНГОВ\nfunction bodyUnLock() {\n\t//скрол появляется только когда закончится анимация\n\tsetTimeout(function () {\n\t\tif (lockPadding.length > 0) {\n\t\t\tfor (let index = 0; index < lockPadding.length; index++) {\n\t\t\t\tconst el = lockPadding[index];\n\t\t\t\t//убераем паддинг с каждого объекта\n\t\t\t\tel.style.paddingRight = '0px';\n\t\t\t}\n\t\t}\n\t\t//убираем паддинг с body\n\t\tbody.style.paddingRight = '0px';\n\t\t//убираем класс lock c body\n\t\tbody.classList.remove('_lock');\n\t\t//значение задержки в переменной\n\t}, 0);\n\n\t//на время лочим переменную unlock\n\tunlock = false;\n\t//через какое-то время\n\tsetTimeout(function () {\n\t\t//разблокируем\n\t\tunlock = true;\n\t\t//передаем заданное время с помощью переменной\n\t}, timeout);\n}\n//ЗАКРЫТИЕ ПОПАП ПО КЛАВИШЕ ESCAPE\n//слушаю нажате клавиши\ndocument.addEventListener(\"keydown\", function (e) {\n\t//если нажатие клавиши равно коду 27(клавиша ESC)\n\tif (e.which === 27) {\n\t\tconst popupActive = document.querySelector('.popup._active');\n\t\t//вызываем функцию закрытия активного попап\n\t\tpopupClose(popupActive);\n\t}\n});\n//</POPUP>======================================================================\n\n\n//# sourceURL=webpack://funiro/./src/js/files/popup.js?");

/***/ }),

/***/ "./src/js/files/script.js":
/*!********************************!*\
  !*** ./src/js/files/script.js ***!
  \********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _functions_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./functions.js */ \"./src/js/files/functions.js\");\nwindow.onload = function () { //когда весь контент загрузится\n\tdocument.addEventListener(\"click\", documentActions);\n\n\t// Actions (делигирование события click)\n\tfunction documentActions(e) {\n\t\tconst targetElement = e.target; // кладем в переменную нажатый объект\n\t\tif (window.innerWidth > 768 && _functions_js__WEBPACK_IMPORTED_MODULE_0__.isMobile.any()) { // если ширина окна меньше 768 и это мобилка\n\t\t\tif (targetElement.classList.contains('menu__arrow')) {\n\t\t\t\ttargetElement.closest('.menu__item').classList.toggle('_hover');\n\t\t\t}\n\t\t\tif (!targetElement.closest('.menu__item') && document.querySelectorAll('.menu__item._hover').length > 0) {\n\t\t\t\t_removeClasses(document.querySelectorAll('.menu__item._hover'), '_hover');\n\t\t\t}\n\t\t}\n\t\tif (targetElement.classList.contains('search-form__icon')) {\n\t\t\tdocument.querySelector('.search-form').classList.toggle('_active');\n\t\t} else if (!targetElement.closest('.search-form') && document.querySelector('.search-form._active')) {\n\t\t\tdocument.querySelector('.search-form').classList.remove('_active');\n\n\t\t}\n\t}\n}\n//======================================================================\nfunction _removeClasses(object, classToRemove) {\n\tfor (let index = 0; index < object.length; index++) {\n\t\tconst element = object[index];\n\t\telement.classList.remove(classToRemove);\n\t}\n}\n//======================================================================\n\n//<BURGER>=================================\nconst iconMenu = document.querySelector('.icon-menu');//находим класс icon-menu\nconst menuBody = document.querySelector('.menu__body');//находим класс menu__body\nconst headerBody = document.querySelector('.header__body');//находим класс menu__body\nif (iconMenu) {//Проверяем есть ли icon-menu\n\ticonMenu.addEventListener(\"click\", function (e) {//вещам событие при клике мыши\n\t\tdocument.body.classList.toggle('_lock');//Для Body даем класс Lock для отключения прокрутки\n\t\ticonMenu.classList.toggle('_active');//добавляем класс active icon-menu\n\t\tmenuBody.classList.toggle('_active');//добавляем класс active menu__body\n\t\theaderBody.classList.toggle('_active');//добавляем класс active menu__body\n\t\t// _slideToggle(menuBody, 500);\n\t});\n};\n//</BURGER>=================================\n\n//<BURGER SIDE-MENU>=================================\n// let menuPageBurger = document.querySelector('.menu-page__burger');\n// let menuPageBody = document.querySelector('.menu-page__body');\n// menuPageBurger.addEventListener(\"click\", function (e) {\n// \t// menuPageBody.classList.toggle('_active');\n// \tmenuPageBurger.classList.toggle('_active');\n// \t_slideToggle(menuPageBody, 500);\n// });\n//</BURGER SIDE-MENU>=================================\n\n//<ANIM-SLIDE>================================================================\n/*   Анимированное плавное открытие и закрытие блока.\nМожет применяться к меню или выпадающему списку\nВыписано из видео фрилансера.\nВ CSS нужно установить display: none; для родителя.\n*/\n// SlideUP\n\n// SlideDown\n\n//SlideToggLe\n\n//</ANIM-SLIDE>================================================================\n//<isMobile>================================================================\n//Проверка на каком устройстве работаем\n\n//</isMobile>================================================================\n\n//# sourceURL=webpack://funiro/./src/js/files/script.js?");

/***/ }),

/***/ "./src/js/files/sliders.js":
/*!*********************************!*\
  !*** ./src/js/files/sliders.js ***!
  \*********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _libs_swiper_bundle_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../libs/swiper-bundle.js */ \"./src/js/libs/swiper-bundle.js\");\n\n\n//<BILD-SWIPER>======================================================================\nlet sliders = document.querySelectorAll('._swiper');\nif (sliders.length > 0) {\n\tfor (let index = 0; index < sliders.length; index++) {\n\t\tlet slider = sliders[index];\n\t\tif (!slider.classList.contains('swiper-bild')) {\n\t\t\tlet slider_items = slider.children;\n\t\t\tif (slider_items) {\n\t\t\t\tfor (let index = 0; index < slider_items.length; index++) {\n\t\t\t\t\tlet el = slider_items[index];\n\t\t\t\t\tel.classList.add('swiper-slide');\n\t\t\t\t}\n\t\t\t}\n\t\t\t// ветка Слайдов с содержимым mainslider__slide(swiper-slide) и глубже\n\t\t\tlet slider_content = slider.innerHTML;\n\t\t\t// let slider_wrapper = element('div', ['swiper-wrapper'], slider_content);\n\t\t\t// создаем пустой див\n\t\t\tlet slider_wrapper = document.createElement('div');\n\t\t\t// даем этому диву класс swiper-wrapper\n\t\t\tslider_wrapper.classList.add('swiper-wrapper');\n\t\t\t// помещаем ветку Слайдов внутрь оболочки swiper-wrapper\n\t\t\tslider_wrapper.innerHTML = slider_content;\n\t\t\t// затираем всё что было внутри mainslider__body\n\t\t\tslider.innerHTML = '';\n\t\t\t// в пустой блок mainslider__body вставляем оболочку swiper-wrapper\n\t\t\tslider.appendChild(slider_wrapper);\n\t\t\t// даем клас swiper-bild\n\t\t\tslider.classList.add('swiper-bild');\n\t\t\t// if (slider.classList.contains('_swiper_scroll')) {\n\t\t\t// let sliderScroll = element('div', ['swiper-scrollbar']);\n\t\t\t// slider.appendChild(sliderScroll);\n\t\t\t// }\n\t\t}\n\t\tif (slider.classList.contains('_gallery')) {\n\t\t\t// slider.data('ligthGallery').destroy(true);\n\t\t}\n\t}\n\tsliders_bild_callback();\n\t// }\n}\nfunction sliders_bild_callback(params) { }\n//</BILD-SWIPER>======================================================================\n\n// const sliderScrollItems = document.querySelectorAll('._swiper_scroll');\n// if (sliderScrollItems.length > 0) {\n// \tfor (let index = 0; index < sliderScrollItems.length; index++) {\n// \t\tconst sliderScrollItem = sliderScrollItems[index];\n// \t\tconst sliderScrollBar = sliderScrollItem.querySelector('.swiper-scrollbar');\n// \t\tconst sliderScroll = new Swiper(sliderScrollItem, {\n// \t\t\tobserver: true,\n// \t\t\tobserveParent: true,\n// \t\t\tdirection: 'vertical',\n// \t\t\tslidesPerView: 'auto',\n// \t\t\tfreeMode: true,\n// \t\t\tscrollbar: {\n// \t\t\t\tel: sliderScrollBar,\n// \t\t\t\tdraggable: true,\n// \t\t\t\tsnapOnRelease: false,\n// \t\t\t},\n// \t\t\tmousewheel: {\n// \t\t\t\treleaseOnEdges: true,\n// \t\t\t},\n// \t\t});\n// \t\tsliderScroll.scrollbar.updateSize();\n// \t}\n// }\n//<INIT-SLIDER-1>======================================================================\n//Инициализация и Настройки слайдера 1\nif (document.querySelector('.slider-main__body')) {\n\tlet mainSwiper = new _libs_swiper_bundle_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]('.slider-main__body', {\n\t\tobserver: true,\n\t\tobserveParents: true,\n\t\tslidesPerView: 0,\n\t\tspaceBetween: 32,\n\t\t// autoHeight: true,\n\t\twatchOverflow: true,\n\t\tspeed: 800,\n\t\tloop: true,\n\t\t// loopAdditionalSlides: 1,\n\t\tpreloadImages: false,\n\t\tparallax: true,\n\t\t// Dotts\n\t\tpagination: {\n\t\t\tel: '.controls-slider-main__dotts',\n\t\t\tclickable: true,\n\t\t},\n\t\t// Arrows\n\t\tnavigation: {\n\t\t\tnextEl: '.slider-main .slider-arrow_next',\n\t\t\tprevEl: '.slider-main .slider-arrow_prev',\n\t\t},\n\t});\n}\n//</INIT-SLIDER-1>======================================================================\n\n/* //шаблон с Настройками слайдера\nif (document.querySelector('.slider-rooms__body')) {\n\tnew Swiper('.slider-rooms__body', {\n\t\tobserver: true,\n\t\tobserveParents: true,\n\t\tslidesPerView: 'auto',\n\t\tspaceBetween: 24,\n\t\twatchOverflow: true,\n\t\tspeed: 800,\n\t\tloop: true,\n\t\tloopAdditionalSlides: 5,\n\t\tpreloadImages: false,\n\t\tslideToClickedSlide: false,\n\t\ttouchRatio: 0,\n\t\tsimulateTouch: false,\n\t\tparallax: true,\n\t\teffect: 'fade',\n\t\t// Autoplay\n\t\tautoplay: {\n\t\t\tdelay: 3000,\n\t\t\tdisableOnInteraction: true,\n\t\t},\n\t\t// Dots\n\t\tpagination: {\n\t\t\tel: '.slider-rooms__dotts',\n\t\t\tclickable: true,\n\t\t\ttype: 'fraction',\n\t\t},\n\t\t// Arrows\n\t\tnavigation: {\n\t\t\tnextEl: '.slider-rooms .slider-arrow_next',\n\t\t\tprevEl: '.slider-rooms .slider-arrow_prev',\n\t\t},\n\t\t// ScroLLbar\n\tscroLLbar: {\n\t\tel: '.swiper-scrollbar',\n\t},\n\t\n\t\t\t\tbreakpoints: {\n\t\t\t\t\t320: {\n\t\t\t\t\t\tslidesPerView: 1,\n\t\t\t\t\t\tspaceBetween: 0,\n\t\t\t\t\t\tautoHeight: true,\n\t\t\t\t\t},\n\t\t\t\t\t768: {\n\t\t\t\t\t\tslidesPerView: 2,\n\t\t\t\t\t\tspaceBetween: 20,\n\t\t\t\t\t},\n\t\t\t\t\t992: {\n\t\t\t\t\t\tslidesPerView: 3,\n\t\t\t\t\t\tspaceBetween: 20,\n\t\t\t\t\t},\n\t\t\t\t\t1268: {\n\t\t\t\t\t\tslidesPerView: 4,\n\t\t\t\t\t\tspaceBetween: 30,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t})\n}\n*/\n\n//# sourceURL=webpack://funiro/./src/js/files/sliders.js?");

/***/ }),

/***/ "./src/js/libs/swiper-bundle.js":
/*!**************************************!*\
  !*** ./src/js/libs/swiper-bundle.js ***!
  \**************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Swiper\": () => (/* binding */ Swiper),\n/* harmony export */   \"default\": () => (/* binding */ Swiper)\n/* harmony export */ });\n/**\n * Swiper 11.1.4\n * Most modern mobile touch slider and framework with hardware accelerated transitions\n * https://swiperjs.com\n *\n * Copyright 2014-2024 Vladimir Kharlampidi\n *\n * Released under the MIT License\n *\n * Released on: May 30, 2024\n */\n\nvar Swiper = (function () {\n\t'use strict';\n\n\t/**\n\t * SSR Window 4.0.2\n\t * Better handling for window object in SSR environment\n\t * https://github.com/nolimits4web/ssr-window\n\t *\n\t * Copyright 2021, Vladimir Kharlampidi\n\t *\n\t * Licensed under MIT\n\t *\n\t * Released on: December 13, 2021\n\t */\n\t/* eslint-disable no-param-reassign */\n\tfunction isObject$1(obj) {\n\t\treturn obj !== null && typeof obj === 'object' && 'constructor' in obj && obj.constructor === Object;\n\t}\n\tfunction extend$1(target, src) {\n\t\tif (target === void 0) {\n\t\t\ttarget = {};\n\t\t}\n\t\tif (src === void 0) {\n\t\t\tsrc = {};\n\t\t}\n\t\tObject.keys(src).forEach(key => {\n\t\t\tif (typeof target[key] === 'undefined') target[key] = src[key]; else if (isObject$1(src[key]) && isObject$1(target[key]) && Object.keys(src[key]).length > 0) {\n\t\t\t\textend$1(target[key], src[key]);\n\t\t\t}\n\t\t});\n\t}\n\tconst ssrDocument = {\n\t\tbody: {},\n\t\taddEventListener() { },\n\t\tremoveEventListener() { },\n\t\tactiveElement: {\n\t\t\tblur() { },\n\t\t\tnodeName: ''\n\t\t},\n\t\tquerySelector() {\n\t\t\treturn null;\n\t\t},\n\t\tquerySelectorAll() {\n\t\t\treturn [];\n\t\t},\n\t\tgetElementById() {\n\t\t\treturn null;\n\t\t},\n\t\tcreateEvent() {\n\t\t\treturn {\n\t\t\t\tinitEvent() { }\n\t\t\t};\n\t\t},\n\t\tcreateElement() {\n\t\t\treturn {\n\t\t\t\tchildren: [],\n\t\t\t\tchildNodes: [],\n\t\t\t\tstyle: {},\n\t\t\t\tsetAttribute() { },\n\t\t\t\tgetElementsByTagName() {\n\t\t\t\t\treturn [];\n\t\t\t\t}\n\t\t\t};\n\t\t},\n\t\tcreateElementNS() {\n\t\t\treturn {};\n\t\t},\n\t\timportNode() {\n\t\t\treturn null;\n\t\t},\n\t\tlocation: {\n\t\t\thash: '',\n\t\t\thost: '',\n\t\t\thostname: '',\n\t\t\thref: '',\n\t\t\torigin: '',\n\t\t\tpathname: '',\n\t\t\tprotocol: '',\n\t\t\tsearch: ''\n\t\t}\n\t};\n\tfunction getDocument() {\n\t\tconst doc = typeof document !== 'undefined' ? document : {};\n\t\textend$1(doc, ssrDocument);\n\t\treturn doc;\n\t}\n\tconst ssrWindow = {\n\t\tdocument: ssrDocument,\n\t\tnavigator: {\n\t\t\tuserAgent: ''\n\t\t},\n\t\tlocation: {\n\t\t\thash: '',\n\t\t\thost: '',\n\t\t\thostname: '',\n\t\t\thref: '',\n\t\t\torigin: '',\n\t\t\tpathname: '',\n\t\t\tprotocol: '',\n\t\t\tsearch: ''\n\t\t},\n\t\thistory: {\n\t\t\treplaceState() { },\n\t\t\tpushState() { },\n\t\t\tgo() { },\n\t\t\tback() { }\n\t\t},\n\t\tCustomEvent: function CustomEvent() {\n\t\t\treturn this;\n\t\t},\n\t\taddEventListener() { },\n\t\tremoveEventListener() { },\n\t\tgetComputedStyle() {\n\t\t\treturn {\n\t\t\t\tgetPropertyValue() {\n\t\t\t\t\treturn '';\n\t\t\t\t}\n\t\t\t};\n\t\t},\n\t\tImage() { },\n\t\tDate() { },\n\t\tscreen: {},\n\t\tsetTimeout() { },\n\t\tclearTimeout() { },\n\t\tmatchMedia() {\n\t\t\treturn {};\n\t\t},\n\t\trequestAnimationFrame(callback) {\n\t\t\tif (typeof setTimeout === 'undefined') {\n\t\t\t\tcallback();\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\treturn setTimeout(callback, 0);\n\t\t},\n\t\tcancelAnimationFrame(id) {\n\t\t\tif (typeof setTimeout === 'undefined') {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tclearTimeout(id);\n\t\t}\n\t};\n\tfunction getWindow() {\n\t\tconst win = typeof window !== 'undefined' ? window : {};\n\t\textend$1(win, ssrWindow);\n\t\treturn win;\n\t}\n\n\tfunction classesToTokens(classes) {\n\t\tif (classes === void 0) {\n\t\t\tclasses = '';\n\t\t}\n\t\treturn classes.trim().split(' ').filter(c => !!c.trim());\n\t}\n\n\tfunction deleteProps(obj) {\n\t\tconst object = obj;\n\t\tObject.keys(object).forEach(key => {\n\t\t\ttry {\n\t\t\t\tobject[key] = null;\n\t\t\t} catch (e) {\n\t\t\t\t// no getter for object\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tdelete object[key];\n\t\t\t} catch (e) {\n\t\t\t\t// something got wrong\n\t\t\t}\n\t\t});\n\t}\n\tfunction nextTick(callback, delay) {\n\t\tif (delay === void 0) {\n\t\t\tdelay = 0;\n\t\t}\n\t\treturn setTimeout(callback, delay);\n\t}\n\tfunction now() {\n\t\treturn Date.now();\n\t}\n\tfunction getComputedStyle$1(el) {\n\t\tconst window = getWindow();\n\t\tlet style;\n\t\tif (window.getComputedStyle) {\n\t\t\tstyle = window.getComputedStyle(el, null);\n\t\t}\n\t\tif (!style && el.currentStyle) {\n\t\t\tstyle = el.currentStyle;\n\t\t}\n\t\tif (!style) {\n\t\t\tstyle = el.style;\n\t\t}\n\t\treturn style;\n\t}\n\tfunction getTranslate(el, axis) {\n\t\tif (axis === void 0) {\n\t\t\taxis = 'x';\n\t\t}\n\t\tconst window = getWindow();\n\t\tlet matrix;\n\t\tlet curTransform;\n\t\tlet transformMatrix;\n\t\tconst curStyle = getComputedStyle$1(el);\n\t\tif (window.WebKitCSSMatrix) {\n\t\t\tcurTransform = curStyle.transform || curStyle.webkitTransform;\n\t\t\tif (curTransform.split(',').length > 6) {\n\t\t\t\tcurTransform = curTransform.split(', ').map(a => a.replace(',', '.')).join(', ');\n\t\t\t}\n\t\t\t// Some old versions of Webkit choke when 'none' is passed; pass\n\t\t\t// empty string instead in this case\n\t\t\ttransformMatrix = new window.WebKitCSSMatrix(curTransform === 'none' ? '' : curTransform);\n\t\t} else {\n\t\t\ttransformMatrix = curStyle.MozTransform || curStyle.OTransform || curStyle.MsTransform || curStyle.msTransform || curStyle.transform || curStyle.getPropertyValue('transform').replace('translate(', 'matrix(1, 0, 0, 1,');\n\t\t\tmatrix = transformMatrix.toString().split(',');\n\t\t}\n\t\tif (axis === 'x') {\n\t\t\t// Latest Chrome and webkits Fix\n\t\t\tif (window.WebKitCSSMatrix) curTransform = transformMatrix.m41;\n\t\t\t// Crazy IE10 Matrix\n\t\t\telse if (matrix.length === 16) curTransform = parseFloat(matrix[12]);\n\t\t\t// Normal Browsers\n\t\t\telse curTransform = parseFloat(matrix[4]);\n\t\t}\n\t\tif (axis === 'y') {\n\t\t\t// Latest Chrome and webkits Fix\n\t\t\tif (window.WebKitCSSMatrix) curTransform = transformMatrix.m42;\n\t\t\t// Crazy IE10 Matrix\n\t\t\telse if (matrix.length === 16) curTransform = parseFloat(matrix[13]);\n\t\t\t// Normal Browsers\n\t\t\telse curTransform = parseFloat(matrix[5]);\n\t\t}\n\t\treturn curTransform || 0;\n\t}\n\tfunction isObject(o) {\n\t\treturn typeof o === 'object' && o !== null && o.constructor && Object.prototype.toString.call(o).slice(8, -1) === 'Object';\n\t}\n\tfunction isNode(node) {\n\t\t// eslint-disable-next-line\n\t\tif (typeof window !== 'undefined' && typeof window.HTMLElement !== 'undefined') {\n\t\t\treturn node instanceof HTMLElement;\n\t\t}\n\t\treturn node && (node.nodeType === 1 || node.nodeType === 11);\n\t}\n\tfunction extend() {\n\t\tconst to = Object(arguments.length <= 0 ? undefined : arguments[0]);\n\t\tconst noExtend = ['__proto__', 'constructor', 'prototype'];\n\t\tfor (let i = 1; i < arguments.length; i += 1) {\n\t\t\tconst nextSource = i < 0 || arguments.length <= i ? undefined : arguments[i];\n\t\t\tif (nextSource !== undefined && nextSource !== null && !isNode(nextSource)) {\n\t\t\t\tconst keysArray = Object.keys(Object(nextSource)).filter(key => noExtend.indexOf(key) < 0);\n\t\t\t\tfor (let nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex += 1) {\n\t\t\t\t\tconst nextKey = keysArray[nextIndex];\n\t\t\t\t\tconst desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);\n\t\t\t\t\tif (desc !== undefined && desc.enumerable) {\n\t\t\t\t\t\tif (isObject(to[nextKey]) && isObject(nextSource[nextKey])) {\n\t\t\t\t\t\t\tif (nextSource[nextKey].__swiper__) {\n\t\t\t\t\t\t\t\tto[nextKey] = nextSource[nextKey];\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\textend(to[nextKey], nextSource[nextKey]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (!isObject(to[nextKey]) && isObject(nextSource[nextKey])) {\n\t\t\t\t\t\t\tto[nextKey] = {};\n\t\t\t\t\t\t\tif (nextSource[nextKey].__swiper__) {\n\t\t\t\t\t\t\t\tto[nextKey] = nextSource[nextKey];\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\textend(to[nextKey], nextSource[nextKey]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tto[nextKey] = nextSource[nextKey];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn to;\n\t}\n\tfunction setCSSProperty(el, varName, varValue) {\n\t\tel.style.setProperty(varName, varValue);\n\t}\n\tfunction animateCSSModeScroll(_ref) {\n\t\tlet {\n\t\t\tswiper,\n\t\t\ttargetPosition,\n\t\t\tside\n\t\t} = _ref;\n\t\tconst window = getWindow();\n\t\tconst startPosition = -swiper.translate;\n\t\tlet startTime = null;\n\t\tlet time;\n\t\tconst duration = swiper.params.speed;\n\t\tswiper.wrapperEl.style.scrollSnapType = 'none';\n\t\twindow.cancelAnimationFrame(swiper.cssModeFrameID);\n\t\tconst dir = targetPosition > startPosition ? 'next' : 'prev';\n\t\tconst isOutOfBound = (current, target) => {\n\t\t\treturn dir === 'next' && current >= target || dir === 'prev' && current <= target;\n\t\t};\n\t\tconst animate = () => {\n\t\t\ttime = new Date().getTime();\n\t\t\tif (startTime === null) {\n\t\t\t\tstartTime = time;\n\t\t\t}\n\t\t\tconst progress = Math.max(Math.min((time - startTime) / duration, 1), 0);\n\t\t\tconst easeProgress = 0.5 - Math.cos(progress * Math.PI) / 2;\n\t\t\tlet currentPosition = startPosition + easeProgress * (targetPosition - startPosition);\n\t\t\tif (isOutOfBound(currentPosition, targetPosition)) {\n\t\t\t\tcurrentPosition = targetPosition;\n\t\t\t}\n\t\t\tswiper.wrapperEl.scrollTo({\n\t\t\t\t[side]: currentPosition\n\t\t\t});\n\t\t\tif (isOutOfBound(currentPosition, targetPosition)) {\n\t\t\t\tswiper.wrapperEl.style.overflow = 'hidden';\n\t\t\t\tswiper.wrapperEl.style.scrollSnapType = '';\n\t\t\t\tsetTimeout(() => {\n\t\t\t\t\tswiper.wrapperEl.style.overflow = '';\n\t\t\t\t\tswiper.wrapperEl.scrollTo({\n\t\t\t\t\t\t[side]: currentPosition\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t\twindow.cancelAnimationFrame(swiper.cssModeFrameID);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tswiper.cssModeFrameID = window.requestAnimationFrame(animate);\n\t\t};\n\t\tanimate();\n\t}\n\tfunction getSlideTransformEl(slideEl) {\n\t\treturn slideEl.querySelector('.swiper-slide-transform') || slideEl.shadowRoot && slideEl.shadowRoot.querySelector('.swiper-slide-transform') || slideEl;\n\t}\n\tfunction elementChildren(element, selector) {\n\t\tif (selector === void 0) {\n\t\t\tselector = '';\n\t\t}\n\t\treturn [...element.children].filter(el => el.matches(selector));\n\t}\n\tfunction showWarning(text) {\n\t\ttry {\n\t\t\tconsole.warn(text);\n\t\t\treturn;\n\t\t} catch (err) {\n\t\t\t// err\n\t\t}\n\t}\n\tfunction createElement(tag, classes) {\n\t\tif (classes === void 0) {\n\t\t\tclasses = [];\n\t\t}\n\t\tconst el = document.createElement(tag);\n\t\tel.classList.add(...(Array.isArray(classes) ? classes : classesToTokens(classes)));\n\t\treturn el;\n\t}\n\tfunction elementOffset(el) {\n\t\tconst window = getWindow();\n\t\tconst document = getDocument();\n\t\tconst box = el.getBoundingClientRect();\n\t\tconst body = document.body;\n\t\tconst clientTop = el.clientTop || body.clientTop || 0;\n\t\tconst clientLeft = el.clientLeft || body.clientLeft || 0;\n\t\tconst scrollTop = el === window ? window.scrollY : el.scrollTop;\n\t\tconst scrollLeft = el === window ? window.scrollX : el.scrollLeft;\n\t\treturn {\n\t\t\ttop: box.top + scrollTop - clientTop,\n\t\t\tleft: box.left + scrollLeft - clientLeft\n\t\t};\n\t}\n\tfunction elementPrevAll(el, selector) {\n\t\tconst prevEls = [];\n\t\twhile (el.previousElementSibling) {\n\t\t\tconst prev = el.previousElementSibling; // eslint-disable-line\n\t\t\tif (selector) {\n\t\t\t\tif (prev.matches(selector)) prevEls.push(prev);\n\t\t\t} else prevEls.push(prev);\n\t\t\tel = prev;\n\t\t}\n\t\treturn prevEls;\n\t}\n\tfunction elementNextAll(el, selector) {\n\t\tconst nextEls = [];\n\t\twhile (el.nextElementSibling) {\n\t\t\tconst next = el.nextElementSibling; // eslint-disable-line\n\t\t\tif (selector) {\n\t\t\t\tif (next.matches(selector)) nextEls.push(next);\n\t\t\t} else nextEls.push(next);\n\t\t\tel = next;\n\t\t}\n\t\treturn nextEls;\n\t}\n\tfunction elementStyle(el, prop) {\n\t\tconst window = getWindow();\n\t\treturn window.getComputedStyle(el, null).getPropertyValue(prop);\n\t}\n\tfunction elementIndex(el) {\n\t\tlet child = el;\n\t\tlet i;\n\t\tif (child) {\n\t\t\ti = 0;\n\t\t\t// eslint-disable-next-line\n\t\t\twhile ((child = child.previousSibling) !== null) {\n\t\t\t\tif (child.nodeType === 1) i += 1;\n\t\t\t}\n\t\t\treturn i;\n\t\t}\n\t\treturn undefined;\n\t}\n\tfunction elementParents(el, selector) {\n\t\tconst parents = []; // eslint-disable-line\n\t\tlet parent = el.parentElement; // eslint-disable-line\n\t\twhile (parent) {\n\t\t\tif (selector) {\n\t\t\t\tif (parent.matches(selector)) parents.push(parent);\n\t\t\t} else {\n\t\t\t\tparents.push(parent);\n\t\t\t}\n\t\t\tparent = parent.parentElement;\n\t\t}\n\t\treturn parents;\n\t}\n\tfunction elementTransitionEnd(el, callback) {\n\t\tfunction fireCallBack(e) {\n\t\t\tif (e.target !== el) return;\n\t\t\tcallback.call(el, e);\n\t\t\tel.removeEventListener('transitionend', fireCallBack);\n\t\t}\n\t\tif (callback) {\n\t\t\tel.addEventListener('transitionend', fireCallBack);\n\t\t}\n\t}\n\tfunction elementOuterSize(el, size, includeMargins) {\n\t\tconst window = getWindow();\n\t\tif (includeMargins) {\n\t\t\treturn el[size === 'width' ? 'offsetWidth' : 'offsetHeight'] + parseFloat(window.getComputedStyle(el, null).getPropertyValue(size === 'width' ? 'margin-right' : 'margin-top')) + parseFloat(window.getComputedStyle(el, null).getPropertyValue(size === 'width' ? 'margin-left' : 'margin-bottom'));\n\t\t}\n\t\treturn el.offsetWidth;\n\t}\n\tfunction makeElementsArray(el) {\n\t\treturn (Array.isArray(el) ? el : [el]).filter(e => !!e);\n\t}\n\n\tlet support;\n\tfunction calcSupport() {\n\t\tconst window = getWindow();\n\t\tconst document = getDocument();\n\t\treturn {\n\t\t\tsmoothScroll: document.documentElement && document.documentElement.style && 'scrollBehavior' in document.documentElement.style,\n\t\t\ttouch: !!('ontouchstart' in window || window.DocumentTouch && document instanceof window.DocumentTouch)\n\t\t};\n\t}\n\tfunction getSupport() {\n\t\tif (!support) {\n\t\t\tsupport = calcSupport();\n\t\t}\n\t\treturn support;\n\t}\n\n\tlet deviceCached;\n\tfunction calcDevice(_temp) {\n\t\tlet {\n\t\t\tuserAgent\n\t\t} = _temp === void 0 ? {} : _temp;\n\t\tconst support = getSupport();\n\t\tconst window = getWindow();\n\t\tconst platform = window.navigator.platform;\n\t\tconst ua = userAgent || window.navigator.userAgent;\n\t\tconst device = {\n\t\t\tios: false,\n\t\t\tandroid: false\n\t\t};\n\t\tconst screenWidth = window.screen.width;\n\t\tconst screenHeight = window.screen.height;\n\t\tconst android = ua.match(/(Android);?[\\s\\/]+([\\d.]+)?/); // eslint-disable-line\n\t\tlet ipad = ua.match(/(iPad).*OS\\s([\\d_]+)/);\n\t\tconst ipod = ua.match(/(iPod)(.*OS\\s([\\d_]+))?/);\n\t\tconst iphone = !ipad && ua.match(/(iPhone\\sOS|iOS)\\s([\\d_]+)/);\n\t\tconst windows = platform === 'Win32';\n\t\tlet macos = platform === 'MacIntel';\n\n\t\t// iPadOs 13 fix\n\t\tconst iPadScreens = ['1024x1366', '1366x1024', '834x1194', '1194x834', '834x1112', '1112x834', '768x1024', '1024x768', '820x1180', '1180x820', '810x1080', '1080x810'];\n\t\tif (!ipad && macos && support.touch && iPadScreens.indexOf(`${screenWidth}x${screenHeight}`) >= 0) {\n\t\t\tipad = ua.match(/(Version)\\/([\\d.]+)/);\n\t\t\tif (!ipad) ipad = [0, 1, '13_0_0'];\n\t\t\tmacos = false;\n\t\t}\n\n\t\t// Android\n\t\tif (android && !windows) {\n\t\t\tdevice.os = 'android';\n\t\t\tdevice.android = true;\n\t\t}\n\t\tif (ipad || iphone || ipod) {\n\t\t\tdevice.os = 'ios';\n\t\t\tdevice.ios = true;\n\t\t}\n\n\t\t// Export object\n\t\treturn device;\n\t}\n\tfunction getDevice(overrides) {\n\t\tif (overrides === void 0) {\n\t\t\toverrides = {};\n\t\t}\n\t\tif (!deviceCached) {\n\t\t\tdeviceCached = calcDevice(overrides);\n\t\t}\n\t\treturn deviceCached;\n\t}\n\n\tlet browser;\n\tfunction calcBrowser() {\n\t\tconst window = getWindow();\n\t\tconst device = getDevice();\n\t\tlet needPerspectiveFix = false;\n\t\tfunction isSafari() {\n\t\t\tconst ua = window.navigator.userAgent.toLowerCase();\n\t\t\treturn ua.indexOf('safari') >= 0 && ua.indexOf('chrome') < 0 && ua.indexOf('android') < 0;\n\t\t}\n\t\tif (isSafari()) {\n\t\t\tconst ua = String(window.navigator.userAgent);\n\t\t\tif (ua.includes('Version/')) {\n\t\t\t\tconst [major, minor] = ua.split('Version/')[1].split(' ')[0].split('.').map(num => Number(num));\n\t\t\t\tneedPerspectiveFix = major < 16 || major === 16 && minor < 2;\n\t\t\t}\n\t\t}\n\t\tconst isWebView = /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(window.navigator.userAgent);\n\t\tconst isSafariBrowser = isSafari();\n\t\tconst need3dFix = isSafariBrowser || isWebView && device.ios;\n\t\treturn {\n\t\t\tisSafari: needPerspectiveFix || isSafariBrowser,\n\t\t\tneedPerspectiveFix,\n\t\t\tneed3dFix,\n\t\t\tisWebView\n\t\t};\n\t}\n\tfunction getBrowser() {\n\t\tif (!browser) {\n\t\t\tbrowser = calcBrowser();\n\t\t}\n\t\treturn browser;\n\t}\n\n\tfunction Resize(_ref) {\n\t\tlet {\n\t\t\tswiper,\n\t\t\ton,\n\t\t\temit\n\t\t} = _ref;\n\t\tconst window = getWindow();\n\t\tlet observer = null;\n\t\tlet animationFrame = null;\n\t\tconst resizeHandler = () => {\n\t\t\tif (!swiper || swiper.destroyed || !swiper.initialized) return;\n\t\t\temit('beforeResize');\n\t\t\temit('resize');\n\t\t};\n\t\tconst createObserver = () => {\n\t\t\tif (!swiper || swiper.destroyed || !swiper.initialized) return;\n\t\t\tobserver = new ResizeObserver(entries => {\n\t\t\t\tanimationFrame = window.requestAnimationFrame(() => {\n\t\t\t\t\tconst {\n\t\t\t\t\t\twidth,\n\t\t\t\t\t\theight\n\t\t\t\t\t} = swiper;\n\t\t\t\t\tlet newWidth = width;\n\t\t\t\t\tlet newHeight = height;\n\t\t\t\t\tentries.forEach(_ref2 => {\n\t\t\t\t\t\tlet {\n\t\t\t\t\t\t\tcontentBoxSize,\n\t\t\t\t\t\t\tcontentRect,\n\t\t\t\t\t\t\ttarget\n\t\t\t\t\t\t} = _ref2;\n\t\t\t\t\t\tif (target && target !== swiper.el) return;\n\t\t\t\t\t\tnewWidth = contentRect ? contentRect.width : (contentBoxSize[0] || contentBoxSize).inlineSize;\n\t\t\t\t\t\tnewHeight = contentRect ? contentRect.height : (contentBoxSize[0] || contentBoxSize).blockSize;\n\t\t\t\t\t});\n\t\t\t\t\tif (newWidth !== width || newHeight !== height) {\n\t\t\t\t\t\tresizeHandler();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t});\n\t\t\tobserver.observe(swiper.el);\n\t\t};\n\t\tconst removeObserver = () => {\n\t\t\tif (animationFrame) {\n\t\t\t\twindow.cancelAnimationFrame(animationFrame);\n\t\t\t}\n\t\t\tif (observer && observer.unobserve && swiper.el) {\n\t\t\t\tobserver.unobserve(swiper.el);\n\t\t\t\tobserver = null;\n\t\t\t}\n\t\t};\n\t\tconst orientationChangeHandler = () => {\n\t\t\tif (!swiper || swiper.destroyed || !swiper.initialized) return;\n\t\t\temit('orientationchange');\n\t\t};\n\t\ton('init', () => {\n\t\t\tif (swiper.params.resizeObserver && typeof window.ResizeObserver !== 'undefined') {\n\t\t\t\tcreateObserver();\n\t\t\t\treturn;\n\t\t\t}\n\t\t\twindow.addEventListener('resize', resizeHandler);\n\t\t\twindow.addEventListener('orientationchange', orientationChangeHandler);\n\t\t});\n\t\ton('destroy', () => {\n\t\t\tremoveObserver();\n\t\t\twindow.removeEventListener('resize', resizeHandler);\n\t\t\twindow.removeEventListener('orientationchange', orientationChangeHandler);\n\t\t});\n\t}\n\n\tfunction Observer(_ref) {\n\t\tlet {\n\t\t\tswiper,\n\t\t\textendParams,\n\t\t\ton,\n\t\t\temit\n\t\t} = _ref;\n\t\tconst observers = [];\n\t\tconst window = getWindow();\n\t\tconst attach = function (target, options) {\n\t\t\tif (options === void 0) {\n\t\t\t\toptions = {};\n\t\t\t}\n\t\t\tconst ObserverFunc = window.MutationObserver || window.WebkitMutationObserver;\n\t\t\tconst observer = new ObserverFunc(mutations => {\n\t\t\t\t// The observerUpdate event should only be triggered\n\t\t\t\t// once despite the number of mutations.  Additional\n\t\t\t\t// triggers are redundant and are very costly\n\t\t\t\tif (swiper.__preventObserver__) return;\n\t\t\t\tif (mutations.length === 1) {\n\t\t\t\t\temit('observerUpdate', mutations[0]);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tconst observerUpdate = function observerUpdate() {\n\t\t\t\t\temit('observerUpdate', mutations[0]);\n\t\t\t\t};\n\t\t\t\tif (window.requestAnimationFrame) {\n\t\t\t\t\twindow.requestAnimationFrame(observerUpdate);\n\t\t\t\t} else {\n\t\t\t\t\twindow.setTimeout(observerUpdate, 0);\n\t\t\t\t}\n\t\t\t});\n\t\t\tobserver.observe(target, {\n\t\t\t\tattributes: typeof options.attributes === 'undefined' ? true : options.attributes,\n\t\t\t\tchildList: typeof options.childList === 'undefined' ? true : options.childList,\n\t\t\t\tcharacterData: typeof options.characterData === 'undefined' ? true : options.characterData\n\t\t\t});\n\t\t\tobservers.push(observer);\n\t\t};\n\t\tconst init = () => {\n\t\t\tif (!swiper.params.observer) return;\n\t\t\tif (swiper.params.observeParents) {\n\t\t\t\tconst containerParents = elementParents(swiper.hostEl);\n\t\t\t\tfor (let i = 0; i < containerParents.length; i += 1) {\n\t\t\t\t\tattach(containerParents[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Observe container\n\t\t\tattach(swiper.hostEl, {\n\t\t\t\tchildList: swiper.params.observeSlideChildren\n\t\t\t});\n\n\t\t\t// Observe wrapper\n\t\t\tattach(swiper.wrapperEl, {\n\t\t\t\tattributes: false\n\t\t\t});\n\t\t};\n\t\tconst destroy = () => {\n\t\t\tobservers.forEach(observer => {\n\t\t\t\tobserver.disconnect();\n\t\t\t});\n\t\t\tobservers.splice(0, observers.length);\n\t\t};\n\t\textendParams({\n\t\t\tobserver: false,\n\t\t\tobserveParents: false,\n\t\t\tobserveSlideChildren: false\n\t\t});\n\t\ton('init', init);\n\t\ton('destroy', destroy);\n\t}\n\n\t/* eslint-disable no-underscore-dangle */\n\n\tvar eventsEmitter = {\n\t\ton(events, handler, priority) {\n\t\t\tconst self = this;\n\t\t\tif (!self.eventsListeners || self.destroyed) return self;\n\t\t\tif (typeof handler !== 'function') return self;\n\t\t\tconst method = priority ? 'unshift' : 'push';\n\t\t\tevents.split(' ').forEach(event => {\n\t\t\t\tif (!self.eventsListeners[event]) self.eventsListeners[event] = [];\n\t\t\t\tself.eventsListeners[event][method](handler);\n\t\t\t});\n\t\t\treturn self;\n\t\t},\n\t\tonce(events, handler, priority) {\n\t\t\tconst self = this;\n\t\t\tif (!self.eventsListeners || self.destroyed) return self;\n\t\t\tif (typeof handler !== 'function') return self;\n\t\t\tfunction onceHandler() {\n\t\t\t\tself.off(events, onceHandler);\n\t\t\t\tif (onceHandler.__emitterProxy) {\n\t\t\t\t\tdelete onceHandler.__emitterProxy;\n\t\t\t\t}\n\t\t\t\tfor (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n\t\t\t\t\targs[_key] = arguments[_key];\n\t\t\t\t}\n\t\t\t\thandler.apply(self, args);\n\t\t\t}\n\t\t\tonceHandler.__emitterProxy = handler;\n\t\t\treturn self.on(events, onceHandler, priority);\n\t\t},\n\t\tonAny(handler, priority) {\n\t\t\tconst self = this;\n\t\t\tif (!self.eventsListeners || self.destroyed) return self;\n\t\t\tif (typeof handler !== 'function') return self;\n\t\t\tconst method = priority ? 'unshift' : 'push';\n\t\t\tif (self.eventsAnyListeners.indexOf(handler) < 0) {\n\t\t\t\tself.eventsAnyListeners[method](handler);\n\t\t\t}\n\t\t\treturn self;\n\t\t},\n\t\toffAny(handler) {\n\t\t\tconst self = this;\n\t\t\tif (!self.eventsListeners || self.destroyed) return self;\n\t\t\tif (!self.eventsAnyListeners) return self;\n\t\t\tconst index = self.eventsAnyListeners.indexOf(handler);\n\t\t\tif (index >= 0) {\n\t\t\t\tself.eventsAnyListeners.splice(index, 1);\n\t\t\t}\n\t\t\treturn self;\n\t\t},\n\t\toff(events, handler) {\n\t\t\tconst self = this;\n\t\t\tif (!self.eventsListeners || self.destroyed) return self;\n\t\t\tif (!self.eventsListeners) return self;\n\t\t\tevents.split(' ').forEach(event => {\n\t\t\t\tif (typeof handler === 'undefined') {\n\t\t\t\t\tself.eventsListeners[event] = [];\n\t\t\t\t} else if (self.eventsListeners[event]) {\n\t\t\t\t\tself.eventsListeners[event].forEach((eventHandler, index) => {\n\t\t\t\t\t\tif (eventHandler === handler || eventHandler.__emitterProxy && eventHandler.__emitterProxy === handler) {\n\t\t\t\t\t\t\tself.eventsListeners[event].splice(index, 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn self;\n\t\t},\n\t\temit() {\n\t\t\tconst self = this;\n\t\t\tif (!self.eventsListeners || self.destroyed) return self;\n\t\t\tif (!self.eventsListeners) return self;\n\t\t\tlet events;\n\t\t\tlet data;\n\t\t\tlet context;\n\t\t\tfor (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n\t\t\t\targs[_key2] = arguments[_key2];\n\t\t\t}\n\t\t\tif (typeof args[0] === 'string' || Array.isArray(args[0])) {\n\t\t\t\tevents = args[0];\n\t\t\t\tdata = args.slice(1, args.length);\n\t\t\t\tcontext = self;\n\t\t\t} else {\n\t\t\t\tevents = args[0].events;\n\t\t\t\tdata = args[0].data;\n\t\t\t\tcontext = args[0].context || self;\n\t\t\t}\n\t\t\tdata.unshift(context);\n\t\t\tconst eventsArray = Array.isArray(events) ? events : events.split(' ');\n\t\t\teventsArray.forEach(event => {\n\t\t\t\tif (self.eventsAnyListeners && self.eventsAnyListeners.length) {\n\t\t\t\t\tself.eventsAnyListeners.forEach(eventHandler => {\n\t\t\t\t\t\teventHandler.apply(context, [event, ...data]);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tif (self.eventsListeners && self.eventsListeners[event]) {\n\t\t\t\t\tself.eventsListeners[event].forEach(eventHandler => {\n\t\t\t\t\t\teventHandler.apply(context, data);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn self;\n\t\t}\n\t};\n\n\tfunction updateSize() {\n\t\tconst swiper = this;\n\t\tlet width;\n\t\tlet height;\n\t\tconst el = swiper.el;\n\t\tif (typeof swiper.params.width !== 'undefined' && swiper.params.width !== null) {\n\t\t\twidth = swiper.params.width;\n\t\t} else {\n\t\t\twidth = el.clientWidth;\n\t\t}\n\t\tif (typeof swiper.params.height !== 'undefined' && swiper.params.height !== null) {\n\t\t\theight = swiper.params.height;\n\t\t} else {\n\t\t\theight = el.clientHeight;\n\t\t}\n\t\tif (width === 0 && swiper.isHorizontal() || height === 0 && swiper.isVertical()) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Subtract paddings\n\t\twidth = width - parseInt(elementStyle(el, 'padding-left') || 0, 10) - parseInt(elementStyle(el, 'padding-right') || 0, 10);\n\t\theight = height - parseInt(elementStyle(el, 'padding-top') || 0, 10) - parseInt(elementStyle(el, 'padding-bottom') || 0, 10);\n\t\tif (Number.isNaN(width)) width = 0;\n\t\tif (Number.isNaN(height)) height = 0;\n\t\tObject.assign(swiper, {\n\t\t\twidth,\n\t\t\theight,\n\t\t\tsize: swiper.isHorizontal() ? width : height\n\t\t});\n\t}\n\n\tfunction updateSlides() {\n\t\tconst swiper = this;\n\t\tfunction getDirectionPropertyValue(node, label) {\n\t\t\treturn parseFloat(node.getPropertyValue(swiper.getDirectionLabel(label)) || 0);\n\t\t}\n\t\tconst params = swiper.params;\n\t\tconst {\n\t\t\twrapperEl,\n\t\t\tslidesEl,\n\t\t\tsize: swiperSize,\n\t\t\trtlTranslate: rtl,\n\t\t\twrongRTL\n\t\t} = swiper;\n\t\tconst isVirtual = swiper.virtual && params.virtual.enabled;\n\t\tconst previousSlidesLength = isVirtual ? swiper.virtual.slides.length : swiper.slides.length;\n\t\tconst slides = elementChildren(slidesEl, `.${swiper.params.slideClass}, swiper-slide`);\n\t\tconst slidesLength = isVirtual ? swiper.virtual.slides.length : slides.length;\n\t\tlet snapGrid = [];\n\t\tconst slidesGrid = [];\n\t\tconst slidesSizesGrid = [];\n\t\tlet offsetBefore = params.slidesOffsetBefore;\n\t\tif (typeof offsetBefore === 'function') {\n\t\t\toffsetBefore = params.slidesOffsetBefore.call(swiper);\n\t\t}\n\t\tlet offsetAfter = params.slidesOffsetAfter;\n\t\tif (typeof offsetAfter === 'function') {\n\t\t\toffsetAfter = params.slidesOffsetAfter.call(swiper);\n\t\t}\n\t\tconst previousSnapGridLength = swiper.snapGrid.length;\n\t\tconst previousSlidesGridLength = swiper.slidesGrid.length;\n\t\tlet spaceBetween = params.spaceBetween;\n\t\tlet slidePosition = -offsetBefore;\n\t\tlet prevSlideSize = 0;\n\t\tlet index = 0;\n\t\tif (typeof swiperSize === 'undefined') {\n\t\t\treturn;\n\t\t}\n\t\tif (typeof spaceBetween === 'string' && spaceBetween.indexOf('%') >= 0) {\n\t\t\tspaceBetween = parseFloat(spaceBetween.replace('%', '')) / 100 * swiperSize;\n\t\t} else if (typeof spaceBetween === 'string') {\n\t\t\tspaceBetween = parseFloat(spaceBetween);\n\t\t}\n\t\tswiper.virtualSize = -spaceBetween;\n\n\t\t// reset margins\n\t\tslides.forEach(slideEl => {\n\t\t\tif (rtl) {\n\t\t\t\tslideEl.style.marginLeft = '';\n\t\t\t} else {\n\t\t\t\tslideEl.style.marginRight = '';\n\t\t\t}\n\t\t\tslideEl.style.marginBottom = '';\n\t\t\tslideEl.style.marginTop = '';\n\t\t});\n\n\t\t// reset cssMode offsets\n\t\tif (params.centeredSlides && params.cssMode) {\n\t\t\tsetCSSProperty(wrapperEl, '--swiper-centered-offset-before', '');\n\t\t\tsetCSSProperty(wrapperEl, '--swiper-centered-offset-after', '');\n\t\t}\n\t\tconst gridEnabled = params.grid && params.grid.rows > 1 && swiper.grid;\n\t\tif (gridEnabled) {\n\t\t\tswiper.grid.initSlides(slides);\n\t\t} else if (swiper.grid) {\n\t\t\tswiper.grid.unsetSlides();\n\t\t}\n\n\t\t// Calc slides\n\t\tlet slideSize;\n\t\tconst shouldResetSlideSize = params.slidesPerView === 'auto' && params.breakpoints && Object.keys(params.breakpoints).filter(key => {\n\t\t\treturn typeof params.breakpoints[key].slidesPerView !== 'undefined';\n\t\t}).length > 0;\n\t\tfor (let i = 0; i < slidesLength; i += 1) {\n\t\t\tslideSize = 0;\n\t\t\tlet slide;\n\t\t\tif (slides[i]) slide = slides[i];\n\t\t\tif (gridEnabled) {\n\t\t\t\tswiper.grid.updateSlide(i, slide, slides);\n\t\t\t}\n\t\t\tif (slides[i] && elementStyle(slide, 'display') === 'none') continue; // eslint-disable-line\n\n\t\t\tif (params.slidesPerView === 'auto') {\n\t\t\t\tif (shouldResetSlideSize) {\n\t\t\t\t\tslides[i].style[swiper.getDirectionLabel('width')] = ``;\n\t\t\t\t}\n\t\t\t\tconst slideStyles = getComputedStyle(slide);\n\t\t\t\tconst currentTransform = slide.style.transform;\n\t\t\t\tconst currentWebKitTransform = slide.style.webkitTransform;\n\t\t\t\tif (currentTransform) {\n\t\t\t\t\tslide.style.transform = 'none';\n\t\t\t\t}\n\t\t\t\tif (currentWebKitTransform) {\n\t\t\t\t\tslide.style.webkitTransform = 'none';\n\t\t\t\t}\n\t\t\t\tif (params.roundLengths) {\n\t\t\t\t\tslideSize = swiper.isHorizontal() ? elementOuterSize(slide, 'width', true) : elementOuterSize(slide, 'height', true);\n\t\t\t\t} else {\n\t\t\t\t\t// eslint-disable-next-line\n\t\t\t\t\tconst width = getDirectionPropertyValue(slideStyles, 'width');\n\t\t\t\t\tconst paddingLeft = getDirectionPropertyValue(slideStyles, 'padding-left');\n\t\t\t\t\tconst paddingRight = getDirectionPropertyValue(slideStyles, 'padding-right');\n\t\t\t\t\tconst marginLeft = getDirectionPropertyValue(slideStyles, 'margin-left');\n\t\t\t\t\tconst marginRight = getDirectionPropertyValue(slideStyles, 'margin-right');\n\t\t\t\t\tconst boxSizing = slideStyles.getPropertyValue('box-sizing');\n\t\t\t\t\tif (boxSizing && boxSizing === 'border-box') {\n\t\t\t\t\t\tslideSize = width + marginLeft + marginRight;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconst {\n\t\t\t\t\t\t\tclientWidth,\n\t\t\t\t\t\t\toffsetWidth\n\t\t\t\t\t\t} = slide;\n\t\t\t\t\t\tslideSize = width + paddingLeft + paddingRight + marginLeft + marginRight + (offsetWidth - clientWidth);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (currentTransform) {\n\t\t\t\t\tslide.style.transform = currentTransform;\n\t\t\t\t}\n\t\t\t\tif (currentWebKitTransform) {\n\t\t\t\t\tslide.style.webkitTransform = currentWebKitTransform;\n\t\t\t\t}\n\t\t\t\tif (params.roundLengths) slideSize = Math.floor(slideSize);\n\t\t\t} else {\n\t\t\t\tslideSize = (swiperSize - (params.slidesPerView - 1) * spaceBetween) / params.slidesPerView;\n\t\t\t\tif (params.roundLengths) slideSize = Math.floor(slideSize);\n\t\t\t\tif (slides[i]) {\n\t\t\t\t\tslides[i].style[swiper.getDirectionLabel('width')] = `${slideSize}px`;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (slides[i]) {\n\t\t\t\tslides[i].swiperSlideSize = slideSize;\n\t\t\t}\n\t\t\tslidesSizesGrid.push(slideSize);\n\t\t\tif (params.centeredSlides) {\n\t\t\t\tslidePosition = slidePosition + slideSize / 2 + prevSlideSize / 2 + spaceBetween;\n\t\t\t\tif (prevSlideSize === 0 && i !== 0) slidePosition = slidePosition - swiperSize / 2 - spaceBetween;\n\t\t\t\tif (i === 0) slidePosition = slidePosition - swiperSize / 2 - spaceBetween;\n\t\t\t\tif (Math.abs(slidePosition) < 1 / 1000) slidePosition = 0;\n\t\t\t\tif (params.roundLengths) slidePosition = Math.floor(slidePosition);\n\t\t\t\tif (index % params.slidesPerGroup === 0) snapGrid.push(slidePosition);\n\t\t\t\tslidesGrid.push(slidePosition);\n\t\t\t} else {\n\t\t\t\tif (params.roundLengths) slidePosition = Math.floor(slidePosition);\n\t\t\t\tif ((index - Math.min(swiper.params.slidesPerGroupSkip, index)) % swiper.params.slidesPerGroup === 0) snapGrid.push(slidePosition);\n\t\t\t\tslidesGrid.push(slidePosition);\n\t\t\t\tslidePosition = slidePosition + slideSize + spaceBetween;\n\t\t\t}\n\t\t\tswiper.virtualSize += slideSize + spaceBetween;\n\t\t\tprevSlideSize = slideSize;\n\t\t\tindex += 1;\n\t\t}\n\t\tswiper.virtualSize = Math.max(swiper.virtualSize, swiperSize) + offsetAfter;\n\t\tif (rtl && wrongRTL && (params.effect === 'slide' || params.effect === 'coverflow')) {\n\t\t\twrapperEl.style.width = `${swiper.virtualSize + spaceBetween}px`;\n\t\t}\n\t\tif (params.setWrapperSize) {\n\t\t\twrapperEl.style[swiper.getDirectionLabel('width')] = `${swiper.virtualSize + spaceBetween}px`;\n\t\t}\n\t\tif (gridEnabled) {\n\t\t\tswiper.grid.updateWrapperSize(slideSize, snapGrid);\n\t\t}\n\n\t\t// Remove last grid elements depending on width\n\t\tif (!params.centeredSlides) {\n\t\t\tconst newSlidesGrid = [];\n\t\t\tfor (let i = 0; i < snapGrid.length; i += 1) {\n\t\t\t\tlet slidesGridItem = snapGrid[i];\n\t\t\t\tif (params.roundLengths) slidesGridItem = Math.floor(slidesGridItem);\n\t\t\t\tif (snapGrid[i] <= swiper.virtualSize - swiperSize) {\n\t\t\t\t\tnewSlidesGrid.push(slidesGridItem);\n\t\t\t\t}\n\t\t\t}\n\t\t\tsnapGrid = newSlidesGrid;\n\t\t\tif (Math.floor(swiper.virtualSize - swiperSize) - Math.floor(snapGrid[snapGrid.length - 1]) > 1) {\n\t\t\t\tsnapGrid.push(swiper.virtualSize - swiperSize);\n\t\t\t}\n\t\t}\n\t\tif (isVirtual && params.loop) {\n\t\t\tconst size = slidesSizesGrid[0] + spaceBetween;\n\t\t\tif (params.slidesPerGroup > 1) {\n\t\t\t\tconst groups = Math.ceil((swiper.virtual.slidesBefore + swiper.virtual.slidesAfter) / params.slidesPerGroup);\n\t\t\t\tconst groupSize = size * params.slidesPerGroup;\n\t\t\t\tfor (let i = 0; i < groups; i += 1) {\n\t\t\t\t\tsnapGrid.push(snapGrid[snapGrid.length - 1] + groupSize);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (let i = 0; i < swiper.virtual.slidesBefore + swiper.virtual.slidesAfter; i += 1) {\n\t\t\t\tif (params.slidesPerGroup === 1) {\n\t\t\t\t\tsnapGrid.push(snapGrid[snapGrid.length - 1] + size);\n\t\t\t\t}\n\t\t\t\tslidesGrid.push(slidesGrid[slidesGrid.length - 1] + size);\n\t\t\t\tswiper.virtualSize += size;\n\t\t\t}\n\t\t}\n\t\tif (snapGrid.length === 0) snapGrid = [0];\n\t\tif (spaceBetween !== 0) {\n\t\t\tconst key = swiper.isHorizontal() && rtl ? 'marginLeft' : swiper.getDirectionLabel('marginRight');\n\t\t\tslides.filter((_, slideIndex) => {\n\t\t\t\tif (!params.cssMode || params.loop) return true;\n\t\t\t\tif (slideIndex === slides.length - 1) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}).forEach(slideEl => {\n\t\t\t\tslideEl.style[key] = `${spaceBetween}px`;\n\t\t\t});\n\t\t}\n\t\tif (params.centeredSlides && params.centeredSlidesBounds) {\n\t\t\tlet allSlidesSize = 0;\n\t\t\tslidesSizesGrid.forEach(slideSizeValue => {\n\t\t\t\tallSlidesSize += slideSizeValue + (spaceBetween || 0);\n\t\t\t});\n\t\t\tallSlidesSize -= spaceBetween;\n\t\t\tconst maxSnap = allSlidesSize - swiperSize;\n\t\t\tsnapGrid = snapGrid.map(snap => {\n\t\t\t\tif (snap <= 0) return -offsetBefore;\n\t\t\t\tif (snap > maxSnap) return maxSnap + offsetAfter;\n\t\t\t\treturn snap;\n\t\t\t});\n\t\t}\n\t\tif (params.centerInsufficientSlides) {\n\t\t\tlet allSlidesSize = 0;\n\t\t\tslidesSizesGrid.forEach(slideSizeValue => {\n\t\t\t\tallSlidesSize += slideSizeValue + (spaceBetween || 0);\n\t\t\t});\n\t\t\tallSlidesSize -= spaceBetween;\n\t\t\tconst offsetSize = (params.slidesOffsetBefore || 0) + (params.slidesOffsetAfter || 0);\n\t\t\tif (allSlidesSize + offsetSize < swiperSize) {\n\t\t\t\tconst allSlidesOffset = (swiperSize - allSlidesSize - offsetSize) / 2;\n\t\t\t\tsnapGrid.forEach((snap, snapIndex) => {\n\t\t\t\t\tsnapGrid[snapIndex] = snap - allSlidesOffset;\n\t\t\t\t});\n\t\t\t\tslidesGrid.forEach((snap, snapIndex) => {\n\t\t\t\t\tslidesGrid[snapIndex] = snap + allSlidesOffset;\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\tObject.assign(swiper, {\n\t\t\tslides,\n\t\t\tsnapGrid,\n\t\t\tslidesGrid,\n\t\t\tslidesSizesGrid\n\t\t});\n\t\tif (params.centeredSlides && params.cssMode && !params.centeredSlidesBounds) {\n\t\t\tsetCSSProperty(wrapperEl, '--swiper-centered-offset-before', `${-snapGrid[0]}px`);\n\t\t\tsetCSSProperty(wrapperEl, '--swiper-centered-offset-after', `${swiper.size / 2 - slidesSizesGrid[slidesSizesGrid.length - 1] / 2}px`);\n\t\t\tconst addToSnapGrid = -swiper.snapGrid[0];\n\t\t\tconst addToSlidesGrid = -swiper.slidesGrid[0];\n\t\t\tswiper.snapGrid = swiper.snapGrid.map(v => v + addToSnapGrid);\n\t\t\tswiper.slidesGrid = swiper.slidesGrid.map(v => v + addToSlidesGrid);\n\t\t}\n\t\tif (slidesLength !== previousSlidesLength) {\n\t\t\tswiper.emit('slidesLengthChange');\n\t\t}\n\t\tif (snapGrid.length !== previousSnapGridLength) {\n\t\t\tif (swiper.params.watchOverflow) swiper.checkOverflow();\n\t\t\tswiper.emit('snapGridLengthChange');\n\t\t}\n\t\tif (slidesGrid.length !== previousSlidesGridLength) {\n\t\t\tswiper.emit('slidesGridLengthChange');\n\t\t}\n\t\tif (params.watchSlidesProgress) {\n\t\t\tswiper.updateSlidesOffset();\n\t\t}\n\t\tswiper.emit('slidesUpdated');\n\t\tif (!isVirtual && !params.cssMode && (params.effect === 'slide' || params.effect === 'fade')) {\n\t\t\tconst backFaceHiddenClass = `${params.containerModifierClass}backface-hidden`;\n\t\t\tconst hasClassBackfaceClassAdded = swiper.el.classList.contains(backFaceHiddenClass);\n\t\t\tif (slidesLength <= params.maxBackfaceHiddenSlides) {\n\t\t\t\tif (!hasClassBackfaceClassAdded) swiper.el.classList.add(backFaceHiddenClass);\n\t\t\t} else if (hasClassBackfaceClassAdded) {\n\t\t\t\tswiper.el.classList.remove(backFaceHiddenClass);\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction updateAutoHeight(speed) {\n\t\tconst swiper = this;\n\t\tconst activeSlides = [];\n\t\tconst isVirtual = swiper.virtual && swiper.params.virtual.enabled;\n\t\tlet newHeight = 0;\n\t\tlet i;\n\t\tif (typeof speed === 'number') {\n\t\t\tswiper.setTransition(speed);\n\t\t} else if (speed === true) {\n\t\t\tswiper.setTransition(swiper.params.speed);\n\t\t}\n\t\tconst getSlideByIndex = index => {\n\t\t\tif (isVirtual) {\n\t\t\t\treturn swiper.slides[swiper.getSlideIndexByData(index)];\n\t\t\t}\n\t\t\treturn swiper.slides[index];\n\t\t};\n\t\t// Find slides currently in view\n\t\tif (swiper.params.slidesPerView !== 'auto' && swiper.params.slidesPerView > 1) {\n\t\t\tif (swiper.params.centeredSlides) {\n\t\t\t\t(swiper.visibleSlides || []).forEach(slide => {\n\t\t\t\t\tactiveSlides.push(slide);\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tfor (i = 0; i < Math.ceil(swiper.params.slidesPerView); i += 1) {\n\t\t\t\t\tconst index = swiper.activeIndex + i;\n\t\t\t\t\tif (index > swiper.slides.length && !isVirtual) break;\n\t\t\t\t\tactiveSlides.push(getSlideByIndex(index));\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tactiveSlides.push(getSlideByIndex(swiper.activeIndex));\n\t\t}\n\n\t\t// Find new height from highest slide in view\n\t\tfor (i = 0; i < activeSlides.length; i += 1) {\n\t\t\tif (typeof activeSlides[i] !== 'undefined') {\n\t\t\t\tconst height = activeSlides[i].offsetHeight;\n\t\t\t\tnewHeight = height > newHeight ? height : newHeight;\n\t\t\t}\n\t\t}\n\n\t\t// Update Height\n\t\tif (newHeight || newHeight === 0) swiper.wrapperEl.style.height = `${newHeight}px`;\n\t}\n\n\tfunction updateSlidesOffset() {\n\t\tconst swiper = this;\n\t\tconst slides = swiper.slides;\n\t\t// eslint-disable-next-line\n\t\tconst minusOffset = swiper.isElement ? swiper.isHorizontal() ? swiper.wrapperEl.offsetLeft : swiper.wrapperEl.offsetTop : 0;\n\t\tfor (let i = 0; i < slides.length; i += 1) {\n\t\t\tslides[i].swiperSlideOffset = (swiper.isHorizontal() ? slides[i].offsetLeft : slides[i].offsetTop) - minusOffset - swiper.cssOverflowAdjustment();\n\t\t}\n\t}\n\n\tconst toggleSlideClasses$1 = (slideEl, condition, className) => {\n\t\tif (condition && !slideEl.classList.contains(className)) {\n\t\t\tslideEl.classList.add(className);\n\t\t} else if (!condition && slideEl.classList.contains(className)) {\n\t\t\tslideEl.classList.remove(className);\n\t\t}\n\t};\n\tfunction updateSlidesProgress(translate) {\n\t\tif (translate === void 0) {\n\t\t\ttranslate = this && this.translate || 0;\n\t\t}\n\t\tconst swiper = this;\n\t\tconst params = swiper.params;\n\t\tconst {\n\t\t\tslides,\n\t\t\trtlTranslate: rtl,\n\t\t\tsnapGrid\n\t\t} = swiper;\n\t\tif (slides.length === 0) return;\n\t\tif (typeof slides[0].swiperSlideOffset === 'undefined') swiper.updateSlidesOffset();\n\t\tlet offsetCenter = -translate;\n\t\tif (rtl) offsetCenter = translate;\n\t\tswiper.visibleSlidesIndexes = [];\n\t\tswiper.visibleSlides = [];\n\t\tlet spaceBetween = params.spaceBetween;\n\t\tif (typeof spaceBetween === 'string' && spaceBetween.indexOf('%') >= 0) {\n\t\t\tspaceBetween = parseFloat(spaceBetween.replace('%', '')) / 100 * swiper.size;\n\t\t} else if (typeof spaceBetween === 'string') {\n\t\t\tspaceBetween = parseFloat(spaceBetween);\n\t\t}\n\t\tfor (let i = 0; i < slides.length; i += 1) {\n\t\t\tconst slide = slides[i];\n\t\t\tlet slideOffset = slide.swiperSlideOffset;\n\t\t\tif (params.cssMode && params.centeredSlides) {\n\t\t\t\tslideOffset -= slides[0].swiperSlideOffset;\n\t\t\t}\n\t\t\tconst slideProgress = (offsetCenter + (params.centeredSlides ? swiper.minTranslate() : 0) - slideOffset) / (slide.swiperSlideSize + spaceBetween);\n\t\t\tconst originalSlideProgress = (offsetCenter - snapGrid[0] + (params.centeredSlides ? swiper.minTranslate() : 0) - slideOffset) / (slide.swiperSlideSize + spaceBetween);\n\t\t\tconst slideBefore = -(offsetCenter - slideOffset);\n\t\t\tconst slideAfter = slideBefore + swiper.slidesSizesGrid[i];\n\t\t\tconst isFullyVisible = slideBefore >= 0 && slideBefore <= swiper.size - swiper.slidesSizesGrid[i];\n\t\t\tconst isVisible = slideBefore >= 0 && slideBefore < swiper.size - 1 || slideAfter > 1 && slideAfter <= swiper.size || slideBefore <= 0 && slideAfter >= swiper.size;\n\t\t\tif (isVisible) {\n\t\t\t\tswiper.visibleSlides.push(slide);\n\t\t\t\tswiper.visibleSlidesIndexes.push(i);\n\t\t\t}\n\t\t\ttoggleSlideClasses$1(slide, isVisible, params.slideVisibleClass);\n\t\t\ttoggleSlideClasses$1(slide, isFullyVisible, params.slideFullyVisibleClass);\n\t\t\tslide.progress = rtl ? -slideProgress : slideProgress;\n\t\t\tslide.originalProgress = rtl ? -originalSlideProgress : originalSlideProgress;\n\t\t}\n\t}\n\n\tfunction updateProgress(translate) {\n\t\tconst swiper = this;\n\t\tif (typeof translate === 'undefined') {\n\t\t\tconst multiplier = swiper.rtlTranslate ? -1 : 1;\n\t\t\t// eslint-disable-next-line\n\t\t\ttranslate = swiper && swiper.translate && swiper.translate * multiplier || 0;\n\t\t}\n\t\tconst params = swiper.params;\n\t\tconst translatesDiff = swiper.maxTranslate() - swiper.minTranslate();\n\t\tlet {\n\t\t\tprogress,\n\t\t\tisBeginning,\n\t\t\tisEnd,\n\t\t\tprogressLoop\n\t\t} = swiper;\n\t\tconst wasBeginning = isBeginning;\n\t\tconst wasEnd = isEnd;\n\t\tif (translatesDiff === 0) {\n\t\t\tprogress = 0;\n\t\t\tisBeginning = true;\n\t\t\tisEnd = true;\n\t\t} else {\n\t\t\tprogress = (translate - swiper.minTranslate()) / translatesDiff;\n\t\t\tconst isBeginningRounded = Math.abs(translate - swiper.minTranslate()) < 1;\n\t\t\tconst isEndRounded = Math.abs(translate - swiper.maxTranslate()) < 1;\n\t\t\tisBeginning = isBeginningRounded || progress <= 0;\n\t\t\tisEnd = isEndRounded || progress >= 1;\n\t\t\tif (isBeginningRounded) progress = 0;\n\t\t\tif (isEndRounded) progress = 1;\n\t\t}\n\t\tif (params.loop) {\n\t\t\tconst firstSlideIndex = swiper.getSlideIndexByData(0);\n\t\t\tconst lastSlideIndex = swiper.getSlideIndexByData(swiper.slides.length - 1);\n\t\t\tconst firstSlideTranslate = swiper.slidesGrid[firstSlideIndex];\n\t\t\tconst lastSlideTranslate = swiper.slidesGrid[lastSlideIndex];\n\t\t\tconst translateMax = swiper.slidesGrid[swiper.slidesGrid.length - 1];\n\t\t\tconst translateAbs = Math.abs(translate);\n\t\t\tif (translateAbs >= firstSlideTranslate) {\n\t\t\t\tprogressLoop = (translateAbs - firstSlideTranslate) / translateMax;\n\t\t\t} else {\n\t\t\t\tprogressLoop = (translateAbs + translateMax - lastSlideTranslate) / translateMax;\n\t\t\t}\n\t\t\tif (progressLoop > 1) progressLoop -= 1;\n\t\t}\n\t\tObject.assign(swiper, {\n\t\t\tprogress,\n\t\t\tprogressLoop,\n\t\t\tisBeginning,\n\t\t\tisEnd\n\t\t});\n\t\tif (params.watchSlidesProgress || params.centeredSlides && params.autoHeight) swiper.updateSlidesProgress(translate);\n\t\tif (isBeginning && !wasBeginning) {\n\t\t\tswiper.emit('reachBeginning toEdge');\n\t\t}\n\t\tif (isEnd && !wasEnd) {\n\t\t\tswiper.emit('reachEnd toEdge');\n\t\t}\n\t\tif (wasBeginning && !isBeginning || wasEnd && !isEnd) {\n\t\t\tswiper.emit('fromEdge');\n\t\t}\n\t\tswiper.emit('progress', progress);\n\t}\n\n\tconst toggleSlideClasses = (slideEl, condition, className) => {\n\t\tif (condition && !slideEl.classList.contains(className)) {\n\t\t\tslideEl.classList.add(className);\n\t\t} else if (!condition && slideEl.classList.contains(className)) {\n\t\t\tslideEl.classList.remove(className);\n\t\t}\n\t};\n\tfunction updateSlidesClasses() {\n\t\tconst swiper = this;\n\t\tconst {\n\t\t\tslides,\n\t\t\tparams,\n\t\t\tslidesEl,\n\t\t\tactiveIndex\n\t\t} = swiper;\n\t\tconst isVirtual = swiper.virtual && params.virtual.enabled;\n\t\tconst gridEnabled = swiper.grid && params.grid && params.grid.rows > 1;\n\t\tconst getFilteredSlide = selector => {\n\t\t\treturn elementChildren(slidesEl, `.${params.slideClass}${selector}, swiper-slide${selector}`)[0];\n\t\t};\n\t\tlet activeSlide;\n\t\tlet prevSlide;\n\t\tlet nextSlide;\n\t\tif (isVirtual) {\n\t\t\tif (params.loop) {\n\t\t\t\tlet slideIndex = activeIndex - swiper.virtual.slidesBefore;\n\t\t\t\tif (slideIndex < 0) slideIndex = swiper.virtual.slides.length + slideIndex;\n\t\t\t\tif (slideIndex >= swiper.virtual.slides.length) slideIndex -= swiper.virtual.slides.length;\n\t\t\t\tactiveSlide = getFilteredSlide(`[data-swiper-slide-index=\"${slideIndex}\"]`);\n\t\t\t} else {\n\t\t\t\tactiveSlide = getFilteredSlide(`[data-swiper-slide-index=\"${activeIndex}\"]`);\n\t\t\t}\n\t\t} else {\n\t\t\tif (gridEnabled) {\n\t\t\t\tactiveSlide = slides.filter(slideEl => slideEl.column === activeIndex)[0];\n\t\t\t\tnextSlide = slides.filter(slideEl => slideEl.column === activeIndex + 1)[0];\n\t\t\t\tprevSlide = slides.filter(slideEl => slideEl.column === activeIndex - 1)[0];\n\t\t\t} else {\n\t\t\t\tactiveSlide = slides[activeIndex];\n\t\t\t}\n\t\t}\n\t\tif (activeSlide) {\n\t\t\tif (!gridEnabled) {\n\t\t\t\t// Next Slide\n\t\t\t\tnextSlide = elementNextAll(activeSlide, `.${params.slideClass}, swiper-slide`)[0];\n\t\t\t\tif (params.loop && !nextSlide) {\n\t\t\t\t\tnextSlide = slides[0];\n\t\t\t\t}\n\n\t\t\t\t// Prev Slide\n\t\t\t\tprevSlide = elementPrevAll(activeSlide, `.${params.slideClass}, swiper-slide`)[0];\n\t\t\t\tif (params.loop && !prevSlide === 0) {\n\t\t\t\t\tprevSlide = slides[slides.length - 1];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tslides.forEach(slideEl => {\n\t\t\ttoggleSlideClasses(slideEl, slideEl === activeSlide, params.slideActiveClass);\n\t\t\ttoggleSlideClasses(slideEl, slideEl === nextSlide, params.slideNextClass);\n\t\t\ttoggleSlideClasses(slideEl, slideEl === prevSlide, params.slidePrevClass);\n\t\t});\n\t\tswiper.emitSlidesClasses();\n\t}\n\n\tconst processLazyPreloader = (swiper, imageEl) => {\n\t\tif (!swiper || swiper.destroyed || !swiper.params) return;\n\t\tconst slideSelector = () => swiper.isElement ? `swiper-slide` : `.${swiper.params.slideClass}`;\n\t\tconst slideEl = imageEl.closest(slideSelector());\n\t\tif (slideEl) {\n\t\t\tlet lazyEl = slideEl.querySelector(`.${swiper.params.lazyPreloaderClass}`);\n\t\t\tif (!lazyEl && swiper.isElement) {\n\t\t\t\tif (slideEl.shadowRoot) {\n\t\t\t\t\tlazyEl = slideEl.shadowRoot.querySelector(`.${swiper.params.lazyPreloaderClass}`);\n\t\t\t\t} else {\n\t\t\t\t\t// init later\n\t\t\t\t\trequestAnimationFrame(() => {\n\t\t\t\t\t\tif (slideEl.shadowRoot) {\n\t\t\t\t\t\t\tlazyEl = slideEl.shadowRoot.querySelector(`.${swiper.params.lazyPreloaderClass}`);\n\t\t\t\t\t\t\tif (lazyEl) lazyEl.remove();\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (lazyEl) lazyEl.remove();\n\t\t}\n\t};\n\tconst unlazy = (swiper, index) => {\n\t\tif (!swiper.slides[index]) return;\n\t\tconst imageEl = swiper.slides[index].querySelector('[loading=\"lazy\"]');\n\t\tif (imageEl) imageEl.removeAttribute('loading');\n\t};\n\tconst preload = swiper => {\n\t\tif (!swiper || swiper.destroyed || !swiper.params) return;\n\t\tlet amount = swiper.params.lazyPreloadPrevNext;\n\t\tconst len = swiper.slides.length;\n\t\tif (!len || !amount || amount < 0) return;\n\t\tamount = Math.min(amount, len);\n\t\tconst slidesPerView = swiper.params.slidesPerView === 'auto' ? swiper.slidesPerViewDynamic() : Math.ceil(swiper.params.slidesPerView);\n\t\tconst activeIndex = swiper.activeIndex;\n\t\tif (swiper.params.grid && swiper.params.grid.rows > 1) {\n\t\t\tconst activeColumn = activeIndex;\n\t\t\tconst preloadColumns = [activeColumn - amount];\n\t\t\tpreloadColumns.push(...Array.from({\n\t\t\t\tlength: amount\n\t\t\t}).map((_, i) => {\n\t\t\t\treturn activeColumn + slidesPerView + i;\n\t\t\t}));\n\t\t\tswiper.slides.forEach((slideEl, i) => {\n\t\t\t\tif (preloadColumns.includes(slideEl.column)) unlazy(swiper, i);\n\t\t\t});\n\t\t\treturn;\n\t\t}\n\t\tconst slideIndexLastInView = activeIndex + slidesPerView - 1;\n\t\tif (swiper.params.rewind || swiper.params.loop) {\n\t\t\tfor (let i = activeIndex - amount; i <= slideIndexLastInView + amount; i += 1) {\n\t\t\t\tconst realIndex = (i % len + len) % len;\n\t\t\t\tif (realIndex < activeIndex || realIndex > slideIndexLastInView) unlazy(swiper, realIndex);\n\t\t\t}\n\t\t} else {\n\t\t\tfor (let i = Math.max(activeIndex - amount, 0); i <= Math.min(slideIndexLastInView + amount, len - 1); i += 1) {\n\t\t\t\tif (i !== activeIndex && (i > slideIndexLastInView || i < activeIndex)) {\n\t\t\t\t\tunlazy(swiper, i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\n\tfunction getActiveIndexByTranslate(swiper) {\n\t\tconst {\n\t\t\tslidesGrid,\n\t\t\tparams\n\t\t} = swiper;\n\t\tconst translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;\n\t\tlet activeIndex;\n\t\tfor (let i = 0; i < slidesGrid.length; i += 1) {\n\t\t\tif (typeof slidesGrid[i + 1] !== 'undefined') {\n\t\t\t\tif (translate >= slidesGrid[i] && translate < slidesGrid[i + 1] - (slidesGrid[i + 1] - slidesGrid[i]) / 2) {\n\t\t\t\t\tactiveIndex = i;\n\t\t\t\t} else if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1]) {\n\t\t\t\t\tactiveIndex = i + 1;\n\t\t\t\t}\n\t\t\t} else if (translate >= slidesGrid[i]) {\n\t\t\t\tactiveIndex = i;\n\t\t\t}\n\t\t}\n\t\t// Normalize slideIndex\n\t\tif (params.normalizeSlideIndex) {\n\t\t\tif (activeIndex < 0 || typeof activeIndex === 'undefined') activeIndex = 0;\n\t\t}\n\t\treturn activeIndex;\n\t}\n\tfunction updateActiveIndex(newActiveIndex) {\n\t\tconst swiper = this;\n\t\tconst translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;\n\t\tconst {\n\t\t\tsnapGrid,\n\t\t\tparams,\n\t\t\tactiveIndex: previousIndex,\n\t\t\trealIndex: previousRealIndex,\n\t\t\tsnapIndex: previousSnapIndex\n\t\t} = swiper;\n\t\tlet activeIndex = newActiveIndex;\n\t\tlet snapIndex;\n\t\tconst getVirtualRealIndex = aIndex => {\n\t\t\tlet realIndex = aIndex - swiper.virtual.slidesBefore;\n\t\t\tif (realIndex < 0) {\n\t\t\t\trealIndex = swiper.virtual.slides.length + realIndex;\n\t\t\t}\n\t\t\tif (realIndex >= swiper.virtual.slides.length) {\n\t\t\t\trealIndex -= swiper.virtual.slides.length;\n\t\t\t}\n\t\t\treturn realIndex;\n\t\t};\n\t\tif (typeof activeIndex === 'undefined') {\n\t\t\tactiveIndex = getActiveIndexByTranslate(swiper);\n\t\t}\n\t\tif (snapGrid.indexOf(translate) >= 0) {\n\t\t\tsnapIndex = snapGrid.indexOf(translate);\n\t\t} else {\n\t\t\tconst skip = Math.min(params.slidesPerGroupSkip, activeIndex);\n\t\t\tsnapIndex = skip + Math.floor((activeIndex - skip) / params.slidesPerGroup);\n\t\t}\n\t\tif (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;\n\t\tif (activeIndex === previousIndex && !swiper.params.loop) {\n\t\t\tif (snapIndex !== previousSnapIndex) {\n\t\t\t\tswiper.snapIndex = snapIndex;\n\t\t\t\tswiper.emit('snapIndexChange');\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tif (activeIndex === previousIndex && swiper.params.loop && swiper.virtual && swiper.params.virtual.enabled) {\n\t\t\tswiper.realIndex = getVirtualRealIndex(activeIndex);\n\t\t\treturn;\n\t\t}\n\t\tconst gridEnabled = swiper.grid && params.grid && params.grid.rows > 1;\n\n\t\t// Get real index\n\t\tlet realIndex;\n\t\tif (swiper.virtual && params.virtual.enabled && params.loop) {\n\t\t\trealIndex = getVirtualRealIndex(activeIndex);\n\t\t} else if (gridEnabled) {\n\t\t\tconst firstSlideInColumn = swiper.slides.filter(slideEl => slideEl.column === activeIndex)[0];\n\t\t\tlet activeSlideIndex = parseInt(firstSlideInColumn.getAttribute('data-swiper-slide-index'), 10);\n\t\t\tif (Number.isNaN(activeSlideIndex)) {\n\t\t\t\tactiveSlideIndex = Math.max(swiper.slides.indexOf(firstSlideInColumn), 0);\n\t\t\t}\n\t\t\trealIndex = Math.floor(activeSlideIndex / params.grid.rows);\n\t\t} else if (swiper.slides[activeIndex]) {\n\t\t\tconst slideIndex = swiper.slides[activeIndex].getAttribute('data-swiper-slide-index');\n\t\t\tif (slideIndex) {\n\t\t\t\trealIndex = parseInt(slideIndex, 10);\n\t\t\t} else {\n\t\t\t\trealIndex = activeIndex;\n\t\t\t}\n\t\t} else {\n\t\t\trealIndex = activeIndex;\n\t\t}\n\t\tObject.assign(swiper, {\n\t\t\tpreviousSnapIndex,\n\t\t\tsnapIndex,\n\t\t\tpreviousRealIndex,\n\t\t\trealIndex,\n\t\t\tpreviousIndex,\n\t\t\tactiveIndex\n\t\t});\n\t\tif (swiper.initialized) {\n\t\t\tpreload(swiper);\n\t\t}\n\t\tswiper.emit('activeIndexChange');\n\t\tswiper.emit('snapIndexChange');\n\t\tif (swiper.initialized || swiper.params.runCallbacksOnInit) {\n\t\t\tif (previousRealIndex !== realIndex) {\n\t\t\t\tswiper.emit('realIndexChange');\n\t\t\t}\n\t\t\tswiper.emit('slideChange');\n\t\t}\n\t}\n\n\tfunction updateClickedSlide(el, path) {\n\t\tconst swiper = this;\n\t\tconst params = swiper.params;\n\t\tlet slide = el.closest(`.${params.slideClass}, swiper-slide`);\n\t\tif (!slide && swiper.isElement && path && path.length > 1 && path.includes(el)) {\n\t\t\t[...path.slice(path.indexOf(el) + 1, path.length)].forEach(pathEl => {\n\t\t\t\tif (!slide && pathEl.matches && pathEl.matches(`.${params.slideClass}, swiper-slide`)) {\n\t\t\t\t\tslide = pathEl;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\tlet slideFound = false;\n\t\tlet slideIndex;\n\t\tif (slide) {\n\t\t\tfor (let i = 0; i < swiper.slides.length; i += 1) {\n\t\t\t\tif (swiper.slides[i] === slide) {\n\t\t\t\t\tslideFound = true;\n\t\t\t\t\tslideIndex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (slide && slideFound) {\n\t\t\tswiper.clickedSlide = slide;\n\t\t\tif (swiper.virtual && swiper.params.virtual.enabled) {\n\t\t\t\tswiper.clickedIndex = parseInt(slide.getAttribute('data-swiper-slide-index'), 10);\n\t\t\t} else {\n\t\t\t\tswiper.clickedIndex = slideIndex;\n\t\t\t}\n\t\t} else {\n\t\t\tswiper.clickedSlide = undefined;\n\t\t\tswiper.clickedIndex = undefined;\n\t\t\treturn;\n\t\t}\n\t\tif (params.slideToClickedSlide && swiper.clickedIndex !== undefined && swiper.clickedIndex !== swiper.activeIndex) {\n\t\t\tswiper.slideToClickedSlide();\n\t\t}\n\t}\n\n\tvar update = {\n\t\tupdateSize,\n\t\tupdateSlides,\n\t\tupdateAutoHeight,\n\t\tupdateSlidesOffset,\n\t\tupdateSlidesProgress,\n\t\tupdateProgress,\n\t\tupdateSlidesClasses,\n\t\tupdateActiveIndex,\n\t\tupdateClickedSlide\n\t};\n\n\tfunction getSwiperTranslate(axis) {\n\t\tif (axis === void 0) {\n\t\t\taxis = this.isHorizontal() ? 'x' : 'y';\n\t\t}\n\t\tconst swiper = this;\n\t\tconst {\n\t\t\tparams,\n\t\t\trtlTranslate: rtl,\n\t\t\ttranslate,\n\t\t\twrapperEl\n\t\t} = swiper;\n\t\tif (params.virtualTranslate) {\n\t\t\treturn rtl ? -translate : translate;\n\t\t}\n\t\tif (params.cssMode) {\n\t\t\treturn translate;\n\t\t}\n\t\tlet currentTranslate = getTranslate(wrapperEl, axis);\n\t\tcurrentTranslate += swiper.cssOverflowAdjustment();\n\t\tif (rtl) currentTranslate = -currentTranslate;\n\t\treturn currentTranslate || 0;\n\t}\n\n\tfunction setTranslate(translate, byController) {\n\t\tconst swiper = this;\n\t\tconst {\n\t\t\trtlTranslate: rtl,\n\t\t\tparams,\n\t\t\twrapperEl,\n\t\t\tprogress\n\t\t} = swiper;\n\t\tlet x = 0;\n\t\tlet y = 0;\n\t\tconst z = 0;\n\t\tif (swiper.isHorizontal()) {\n\t\t\tx = rtl ? -translate : translate;\n\t\t} else {\n\t\t\ty = translate;\n\t\t}\n\t\tif (params.roundLengths) {\n\t\t\tx = Math.floor(x);\n\t\t\ty = Math.floor(y);\n\t\t}\n\t\tswiper.previousTranslate = swiper.translate;\n\t\tswiper.translate = swiper.isHorizontal() ? x : y;\n\t\tif (params.cssMode) {\n\t\t\twrapperEl[swiper.isHorizontal() ? 'scrollLeft' : 'scrollTop'] = swiper.isHorizontal() ? -x : -y;\n\t\t} else if (!params.virtualTranslate) {\n\t\t\tif (swiper.isHorizontal()) {\n\t\t\t\tx -= swiper.cssOverflowAdjustment();\n\t\t\t} else {\n\t\t\t\ty -= swiper.cssOverflowAdjustment();\n\t\t\t}\n\t\t\twrapperEl.style.transform = `translate3d(${x}px, ${y}px, ${z}px)`;\n\t\t}\n\n\t\t// Check if we need to update progress\n\t\tlet newProgress;\n\t\tconst translatesDiff = swiper.maxTranslate() - swiper.minTranslate();\n\t\tif (translatesDiff === 0) {\n\t\t\tnewProgress = 0;\n\t\t} else {\n\t\t\tnewProgress = (translate - swiper.minTranslate()) / translatesDiff;\n\t\t}\n\t\tif (newProgress !== progress) {\n\t\t\tswiper.updateProgress(translate);\n\t\t}\n\t\tswiper.emit('setTranslate', swiper.translate, byController);\n\t}\n\n\tfunction minTranslate() {\n\t\treturn -this.snapGrid[0];\n\t}\n\n\tfunction maxTranslate() {\n\t\treturn -this.snapGrid[this.snapGrid.length - 1];\n\t}\n\n\tfunction translateTo(translate, speed, runCallbacks, translateBounds, internal) {\n\t\tif (translate === void 0) {\n\t\t\ttranslate = 0;\n\t\t}\n\t\tif (speed === void 0) {\n\t\t\tspeed = this.params.speed;\n\t\t}\n\t\tif (runCallbacks === void 0) {\n\t\t\trunCallbacks = true;\n\t\t}\n\t\tif (translateBounds === void 0) {\n\t\t\ttranslateBounds = true;\n\t\t}\n\t\tconst swiper = this;\n\t\tconst {\n\t\t\tparams,\n\t\t\twrapperEl\n\t\t} = swiper;\n\t\tif (swiper.animating && params.preventInteractionOnTransition) {\n\t\t\treturn false;\n\t\t}\n\t\tconst minTranslate = swiper.minTranslate();\n\t\tconst maxTranslate = swiper.maxTranslate();\n\t\tlet newTranslate;\n\t\tif (translateBounds && translate > minTranslate) newTranslate = minTranslate; else if (translateBounds && translate < maxTranslate) newTranslate = maxTranslate; else newTranslate = translate;\n\n\t\t// Update progress\n\t\tswiper.updateProgress(newTranslate);\n\t\tif (params.cssMode) {\n\t\t\tconst isH = swiper.isHorizontal();\n\t\t\tif (speed === 0) {\n\t\t\t\twrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = -newTranslate;\n\t\t\t} else {\n\t\t\t\tif (!swiper.support.smoothScroll) {\n\t\t\t\t\tanimateCSSModeScroll({\n\t\t\t\t\t\tswiper,\n\t\t\t\t\t\ttargetPosition: -newTranslate,\n\t\t\t\t\t\tside: isH ? 'left' : 'top'\n\t\t\t\t\t});\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\twrapperEl.scrollTo({\n\t\t\t\t\t[isH ? 'left' : 'top']: -newTranslate,\n\t\t\t\t\tbehavior: 'smooth'\n\t\t\t\t});\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\tif (speed === 0) {\n\t\t\tswiper.setTransition(0);\n\t\t\tswiper.setTranslate(newTranslate);\n\t\t\tif (runCallbacks) {\n\t\t\t\tswiper.emit('beforeTransitionStart', speed, internal);\n\t\t\t\tswiper.emit('transitionEnd');\n\t\t\t}\n\t\t} else {\n\t\t\tswiper.setTransition(speed);\n\t\t\tswiper.setTranslate(newTranslate);\n\t\t\tif (runCallbacks) {\n\t\t\t\tswiper.emit('beforeTransitionStart', speed, internal);\n\t\t\t\tswiper.emit('transitionStart');\n\t\t\t}\n\t\t\tif (!swiper.animating) {\n\t\t\t\tswiper.animating = true;\n\t\t\t\tif (!swiper.onTranslateToWrapperTransitionEnd) {\n\t\t\t\t\tswiper.onTranslateToWrapperTransitionEnd = function transitionEnd(e) {\n\t\t\t\t\t\tif (!swiper || swiper.destroyed) return;\n\t\t\t\t\t\tif (e.target !== this) return;\n\t\t\t\t\t\tswiper.wrapperEl.removeEventListener('transitionend', swiper.onTranslateToWrapperTransitionEnd);\n\t\t\t\t\t\tswiper.onTranslateToWrapperTransitionEnd = null;\n\t\t\t\t\t\tdelete swiper.onTranslateToWrapperTransitionEnd;\n\t\t\t\t\t\tswiper.animating = false;\n\t\t\t\t\t\tif (runCallbacks) {\n\t\t\t\t\t\t\tswiper.emit('transitionEnd');\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tswiper.wrapperEl.addEventListener('transitionend', swiper.onTranslateToWrapperTransitionEnd);\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tvar translate = {\n\t\tgetTranslate: getSwiperTranslate,\n\t\tsetTranslate,\n\t\tminTranslate,\n\t\tmaxTranslate,\n\t\ttranslateTo\n\t};\n\n\tfunction setTransition(duration, byController) {\n\t\tconst swiper = this;\n\t\tif (!swiper.params.cssMode) {\n\t\t\tswiper.wrapperEl.style.transitionDuration = `${duration}ms`;\n\t\t\tswiper.wrapperEl.style.transitionDelay = duration === 0 ? `0ms` : '';\n\t\t}\n\t\tswiper.emit('setTransition', duration, byController);\n\t}\n\n\tfunction transitionEmit(_ref) {\n\t\tlet {\n\t\t\tswiper,\n\t\t\trunCallbacks,\n\t\t\tdirection,\n\t\t\tstep\n\t\t} = _ref;\n\t\tconst {\n\t\t\tactiveIndex,\n\t\t\tpreviousIndex\n\t\t} = swiper;\n\t\tlet dir = direction;\n\t\tif (!dir) {\n\t\t\tif (activeIndex > previousIndex) dir = 'next'; else if (activeIndex < previousIndex) dir = 'prev'; else dir = 'reset';\n\t\t}\n\t\tswiper.emit(`transition${step}`);\n\t\tif (runCallbacks && activeIndex !== previousIndex) {\n\t\t\tif (dir === 'reset') {\n\t\t\t\tswiper.emit(`slideResetTransition${step}`);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tswiper.emit(`slideChangeTransition${step}`);\n\t\t\tif (dir === 'next') {\n\t\t\t\tswiper.emit(`slideNextTransition${step}`);\n\t\t\t} else {\n\t\t\t\tswiper.emit(`slidePrevTransition${step}`);\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction transitionStart(runCallbacks, direction) {\n\t\tif (runCallbacks === void 0) {\n\t\t\trunCallbacks = true;\n\t\t}\n\t\tconst swiper = this;\n\t\tconst {\n\t\t\tparams\n\t\t} = swiper;\n\t\tif (params.cssMode) return;\n\t\tif (params.autoHeight) {\n\t\t\tswiper.updateAutoHeight();\n\t\t}\n\t\ttransitionEmit({\n\t\t\tswiper,\n\t\t\trunCallbacks,\n\t\t\tdirection,\n\t\t\tstep: 'Start'\n\t\t});\n\t}\n\n\tfunction transitionEnd(runCallbacks, direction) {\n\t\tif (runCallbacks === void 0) {\n\t\t\trunCallbacks = true;\n\t\t}\n\t\tconst swiper = this;\n\t\tconst {\n\t\t\tparams\n\t\t} = swiper;\n\t\tswiper.animating = false;\n\t\tif (params.cssMode) return;\n\t\tswiper.setTransition(0);\n\t\ttransitionEmit({\n\t\t\tswiper,\n\t\t\trunCallbacks,\n\t\t\tdirection,\n\t\t\tstep: 'End'\n\t\t});\n\t}\n\n\tvar transition = {\n\t\tsetTransition,\n\t\ttransitionStart,\n\t\ttransitionEnd\n\t};\n\n\tfunction slideTo(index, speed, runCallbacks, internal, initial) {\n\t\tif (index === void 0) {\n\t\t\tindex = 0;\n\t\t}\n\t\tif (runCallbacks === void 0) {\n\t\t\trunCallbacks = true;\n\t\t}\n\t\tif (typeof index === 'string') {\n\t\t\tindex = parseInt(index, 10);\n\t\t}\n\t\tconst swiper = this;\n\t\tlet slideIndex = index;\n\t\tif (slideIndex < 0) slideIndex = 0;\n\t\tconst {\n\t\t\tparams,\n\t\t\tsnapGrid,\n\t\t\tslidesGrid,\n\t\t\tpreviousIndex,\n\t\t\tactiveIndex,\n\t\t\trtlTranslate: rtl,\n\t\t\twrapperEl,\n\t\t\tenabled\n\t\t} = swiper;\n\t\tif (!enabled && !internal && !initial || swiper.destroyed || swiper.animating && params.preventInteractionOnTransition) {\n\t\t\treturn false;\n\t\t}\n\t\tif (typeof speed === 'undefined') {\n\t\t\tspeed = swiper.params.speed;\n\t\t}\n\t\tconst skip = Math.min(swiper.params.slidesPerGroupSkip, slideIndex);\n\t\tlet snapIndex = skip + Math.floor((slideIndex - skip) / swiper.params.slidesPerGroup);\n\t\tif (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;\n\t\tconst translate = -snapGrid[snapIndex];\n\t\t// Normalize slideIndex\n\t\tif (params.normalizeSlideIndex) {\n\t\t\tfor (let i = 0; i < slidesGrid.length; i += 1) {\n\t\t\t\tconst normalizedTranslate = -Math.floor(translate * 100);\n\t\t\t\tconst normalizedGrid = Math.floor(slidesGrid[i] * 100);\n\t\t\t\tconst normalizedGridNext = Math.floor(slidesGrid[i + 1] * 100);\n\t\t\t\tif (typeof slidesGrid[i + 1] !== 'undefined') {\n\t\t\t\t\tif (normalizedTranslate >= normalizedGrid && normalizedTranslate < normalizedGridNext - (normalizedGridNext - normalizedGrid) / 2) {\n\t\t\t\t\t\tslideIndex = i;\n\t\t\t\t\t} else if (normalizedTranslate >= normalizedGrid && normalizedTranslate < normalizedGridNext) {\n\t\t\t\t\t\tslideIndex = i + 1;\n\t\t\t\t\t}\n\t\t\t\t} else if (normalizedTranslate >= normalizedGrid) {\n\t\t\t\t\tslideIndex = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// Directions locks\n\t\tif (swiper.initialized && slideIndex !== activeIndex) {\n\t\t\tif (!swiper.allowSlideNext && (rtl ? translate > swiper.translate && translate > swiper.minTranslate() : translate < swiper.translate && translate < swiper.minTranslate())) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (!swiper.allowSlidePrev && translate > swiper.translate && translate > swiper.maxTranslate()) {\n\t\t\t\tif ((activeIndex || 0) !== slideIndex) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (slideIndex !== (previousIndex || 0) && runCallbacks) {\n\t\t\tswiper.emit('beforeSlideChangeStart');\n\t\t}\n\n\t\t// Update progress\n\t\tswiper.updateProgress(translate);\n\t\tlet direction;\n\t\tif (slideIndex > activeIndex) direction = 'next'; else if (slideIndex < activeIndex) direction = 'prev'; else direction = 'reset';\n\n\t\t// Update Index\n\t\tif (rtl && -translate === swiper.translate || !rtl && translate === swiper.translate) {\n\t\t\tswiper.updateActiveIndex(slideIndex);\n\t\t\t// Update Height\n\t\t\tif (params.autoHeight) {\n\t\t\t\tswiper.updateAutoHeight();\n\t\t\t}\n\t\t\tswiper.updateSlidesClasses();\n\t\t\tif (params.effect !== 'slide') {\n\t\t\t\tswiper.setTranslate(translate);\n\t\t\t}\n\t\t\tif (direction !== 'reset') {\n\t\t\t\tswiper.transitionStart(runCallbacks, direction);\n\t\t\t\tswiper.transitionEnd(runCallbacks, direction);\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\tif (params.cssMode) {\n\t\t\tconst isH = swiper.isHorizontal();\n\t\t\tconst t = rtl ? translate : -translate;\n\t\t\tif (speed === 0) {\n\t\t\t\tconst isVirtual = swiper.virtual && swiper.params.virtual.enabled;\n\t\t\t\tif (isVirtual) {\n\t\t\t\t\tswiper.wrapperEl.style.scrollSnapType = 'none';\n\t\t\t\t\tswiper._immediateVirtual = true;\n\t\t\t\t}\n\t\t\t\tif (isVirtual && !swiper._cssModeVirtualInitialSet && swiper.params.initialSlide > 0) {\n\t\t\t\t\tswiper._cssModeVirtualInitialSet = true;\n\t\t\t\t\trequestAnimationFrame(() => {\n\t\t\t\t\t\twrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = t;\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\twrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = t;\n\t\t\t\t}\n\t\t\t\tif (isVirtual) {\n\t\t\t\t\trequestAnimationFrame(() => {\n\t\t\t\t\t\tswiper.wrapperEl.style.scrollSnapType = '';\n\t\t\t\t\t\tswiper._immediateVirtual = false;\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (!swiper.support.smoothScroll) {\n\t\t\t\t\tanimateCSSModeScroll({\n\t\t\t\t\t\tswiper,\n\t\t\t\t\t\ttargetPosition: t,\n\t\t\t\t\t\tside: isH ? 'left' : 'top'\n\t\t\t\t\t});\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\twrapperEl.scrollTo({\n\t\t\t\t\t[isH ? 'left' : 'top']: t,\n\t\t\t\t\tbehavior: 'smooth'\n\t\t\t\t});\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\tswiper.setTransition(speed);\n\t\tswiper.setTranslate(translate);\n\t\tswiper.updateActiveIndex(slideIndex);\n\t\tswiper.updateSlidesClasses();\n\t\tswiper.emit('beforeTransitionStart', speed, internal);\n\t\tswiper.transitionStart(runCallbacks, direction);\n\t\tif (speed === 0) {\n\t\t\tswiper.transitionEnd(runCallbacks, direction);\n\t\t} else if (!swiper.animating) {\n\t\t\tswiper.animating = true;\n\t\t\tif (!swiper.onSlideToWrapperTransitionEnd) {\n\t\t\t\tswiper.onSlideToWrapperTransitionEnd = function transitionEnd(e) {\n\t\t\t\t\tif (!swiper || swiper.destroyed) return;\n\t\t\t\t\tif (e.target !== this) return;\n\t\t\t\t\tswiper.wrapperEl.removeEventListener('transitionend', swiper.onSlideToWrapperTransitionEnd);\n\t\t\t\t\tswiper.onSlideToWrapperTransitionEnd = null;\n\t\t\t\t\tdelete swiper.onSlideToWrapperTransitionEnd;\n\t\t\t\t\tswiper.transitionEnd(runCallbacks, direction);\n\t\t\t\t};\n\t\t\t}\n\t\t\tswiper.wrapperEl.addEventListener('transitionend', swiper.onSlideToWrapperTransitionEnd);\n\t\t}\n\t\treturn true;\n\t}\n\n\tfunction slideToLoop(index, speed, runCallbacks, internal) {\n\t\tif (index === void 0) {\n\t\t\tindex = 0;\n\t\t}\n\t\tif (runCallbacks === void 0) {\n\t\t\trunCallbacks = true;\n\t\t}\n\t\tif (typeof index === 'string') {\n\t\t\tconst indexAsNumber = parseInt(index, 10);\n\t\t\tindex = indexAsNumber;\n\t\t}\n\t\tconst swiper = this;\n\t\tif (swiper.destroyed) return;\n\t\tif (typeof speed === 'undefined') {\n\t\t\tspeed = swiper.params.speed;\n\t\t}\n\t\tconst gridEnabled = swiper.grid && swiper.params.grid && swiper.params.grid.rows > 1;\n\t\tlet newIndex = index;\n\t\tif (swiper.params.loop) {\n\t\t\tif (swiper.virtual && swiper.params.virtual.enabled) {\n\t\t\t\t// eslint-disable-next-line\n\t\t\t\tnewIndex = newIndex + swiper.virtual.slidesBefore;\n\t\t\t} else {\n\t\t\t\tlet targetSlideIndex;\n\t\t\t\tif (gridEnabled) {\n\t\t\t\t\tconst slideIndex = newIndex * swiper.params.grid.rows;\n\t\t\t\t\ttargetSlideIndex = swiper.slides.filter(slideEl => slideEl.getAttribute('data-swiper-slide-index') * 1 === slideIndex)[0].column;\n\t\t\t\t} else {\n\t\t\t\t\ttargetSlideIndex = swiper.getSlideIndexByData(newIndex);\n\t\t\t\t}\n\t\t\t\tconst cols = gridEnabled ? Math.ceil(swiper.slides.length / swiper.params.grid.rows) : swiper.slides.length;\n\t\t\t\tconst {\n\t\t\t\t\tcenteredSlides\n\t\t\t\t} = swiper.params;\n\t\t\t\tlet slidesPerView = swiper.params.slidesPerView;\n\t\t\t\tif (slidesPerView === 'auto') {\n\t\t\t\t\tslidesPerView = swiper.slidesPerViewDynamic();\n\t\t\t\t} else {\n\t\t\t\t\tslidesPerView = Math.ceil(parseFloat(swiper.params.slidesPerView, 10));\n\t\t\t\t\tif (centeredSlides && slidesPerView % 2 === 0) {\n\t\t\t\t\t\tslidesPerView = slidesPerView + 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlet needLoopFix = cols - targetSlideIndex < slidesPerView;\n\t\t\t\tif (centeredSlides) {\n\t\t\t\t\tneedLoopFix = needLoopFix || targetSlideIndex < Math.ceil(slidesPerView / 2);\n\t\t\t\t}\n\t\t\t\tif (internal && centeredSlides && swiper.params.slidesPerView !== 'auto' && !gridEnabled) {\n\t\t\t\t\tneedLoopFix = false;\n\t\t\t\t}\n\t\t\t\tif (needLoopFix) {\n\t\t\t\t\tconst direction = centeredSlides ? targetSlideIndex < swiper.activeIndex ? 'prev' : 'next' : targetSlideIndex - swiper.activeIndex - 1 < swiper.params.slidesPerView ? 'next' : 'prev';\n\t\t\t\t\tswiper.loopFix({\n\t\t\t\t\t\tdirection,\n\t\t\t\t\t\tslideTo: true,\n\t\t\t\t\t\tactiveSlideIndex: direction === 'next' ? targetSlideIndex + 1 : targetSlideIndex - cols + 1,\n\t\t\t\t\t\tslideRealIndex: direction === 'next' ? swiper.realIndex : undefined\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tif (gridEnabled) {\n\t\t\t\t\tconst slideIndex = newIndex * swiper.params.grid.rows;\n\t\t\t\t\tnewIndex = swiper.slides.filter(slideEl => slideEl.getAttribute('data-swiper-slide-index') * 1 === slideIndex)[0].column;\n\t\t\t\t} else {\n\t\t\t\t\tnewIndex = swiper.getSlideIndexByData(newIndex);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trequestAnimationFrame(() => {\n\t\t\tswiper.slideTo(newIndex, speed, runCallbacks, internal);\n\t\t});\n\t\treturn swiper;\n\t}\n\n\t/* eslint no-unused-vars: \"off\" */\n\tfunction slideNext(speed, runCallbacks, internal) {\n\t\tif (runCallbacks === void 0) {\n\t\t\trunCallbacks = true;\n\t\t}\n\t\tconst swiper = this;\n\t\tconst {\n\t\t\tenabled,\n\t\t\tparams,\n\t\t\tanimating\n\t\t} = swiper;\n\t\tif (!enabled || swiper.destroyed) return swiper;\n\t\tif (typeof speed === 'undefined') {\n\t\t\tspeed = swiper.params.speed;\n\t\t}\n\t\tlet perGroup = params.slidesPerGroup;\n\t\tif (params.slidesPerView === 'auto' && params.slidesPerGroup === 1 && params.slidesPerGroupAuto) {\n\t\t\tperGroup = Math.max(swiper.slidesPerViewDynamic('current', true), 1);\n\t\t}\n\t\tconst increment = swiper.activeIndex < params.slidesPerGroupSkip ? 1 : perGroup;\n\t\tconst isVirtual = swiper.virtual && params.virtual.enabled;\n\t\tif (params.loop) {\n\t\t\tif (animating && !isVirtual && params.loopPreventsSliding) return false;\n\t\t\tswiper.loopFix({\n\t\t\t\tdirection: 'next'\n\t\t\t});\n\t\t\t// eslint-disable-next-line\n\t\t\tswiper._clientLeft = swiper.wrapperEl.clientLeft;\n\t\t\tif (swiper.activeIndex === swiper.slides.length - 1 && params.cssMode) {\n\t\t\t\trequestAnimationFrame(() => {\n\t\t\t\t\tswiper.slideTo(swiper.activeIndex + increment, speed, runCallbacks, internal);\n\t\t\t\t});\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\tif (params.rewind && swiper.isEnd) {\n\t\t\treturn swiper.slideTo(0, speed, runCallbacks, internal);\n\t\t}\n\t\treturn swiper.slideTo(swiper.activeIndex + increment, speed, runCallbacks, internal);\n\t}\n\n\t/* eslint no-unused-vars: \"off\" */\n\tfunction slidePrev(speed, runCallbacks, internal) {\n\t\tif (runCallbacks === void 0) {\n\t\t\trunCallbacks = true;\n\t\t}\n\t\tconst swiper = this;\n\t\tconst {\n\t\t\tparams,\n\t\t\tsnapGrid,\n\t\t\tslidesGrid,\n\t\t\trtlTranslate,\n\t\t\tenabled,\n\t\t\tanimating\n\t\t} = swiper;\n\t\tif (!enabled || swiper.destroyed) return swiper;\n\t\tif (typeof speed === 'undefined') {\n\t\t\tspeed = swiper.params.speed;\n\t\t}\n\t\tconst isVirtual = swiper.virtual && params.virtual.enabled;\n\t\tif (params.loop) {\n\t\t\tif (animating && !isVirtual && params.loopPreventsSliding) return false;\n\t\t\tswiper.loopFix({\n\t\t\t\tdirection: 'prev'\n\t\t\t});\n\t\t\t// eslint-disable-next-line\n\t\t\tswiper._clientLeft = swiper.wrapperEl.clientLeft;\n\t\t}\n\t\tconst translate = rtlTranslate ? swiper.translate : -swiper.translate;\n\t\tfunction normalize(val) {\n\t\t\tif (val < 0) return -Math.floor(Math.abs(val));\n\t\t\treturn Math.floor(val);\n\t\t}\n\t\tconst normalizedTranslate = normalize(translate);\n\t\tconst normalizedSnapGrid = snapGrid.map(val => normalize(val));\n\t\tlet prevSnap = snapGrid[normalizedSnapGrid.indexOf(normalizedTranslate) - 1];\n\t\tif (typeof prevSnap === 'undefined' && params.cssMode) {\n\t\t\tlet prevSnapIndex;\n\t\t\tsnapGrid.forEach((snap, snapIndex) => {\n\t\t\t\tif (normalizedTranslate >= snap) {\n\t\t\t\t\t// prevSnap = snap;\n\t\t\t\t\tprevSnapIndex = snapIndex;\n\t\t\t\t}\n\t\t\t});\n\t\t\tif (typeof prevSnapIndex !== 'undefined') {\n\t\t\t\tprevSnap = snapGrid[prevSnapIndex > 0 ? prevSnapIndex - 1 : prevSnapIndex];\n\t\t\t}\n\t\t}\n\t\tlet prevIndex = 0;\n\t\tif (typeof prevSnap !== 'undefined') {\n\t\t\tprevIndex = slidesGrid.indexOf(prevSnap);\n\t\t\tif (prevIndex < 0) prevIndex = swiper.activeIndex - 1;\n\t\t\tif (params.slidesPerView === 'auto' && params.slidesPerGroup === 1 && params.slidesPerGroupAuto) {\n\t\t\t\tprevIndex = prevIndex - swiper.slidesPerViewDynamic('previous', true) + 1;\n\t\t\t\tprevIndex = Math.max(prevIndex, 0);\n\t\t\t}\n\t\t}\n\t\tif (params.rewind && swiper.isBeginning) {\n\t\t\tconst lastIndex = swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual ? swiper.virtual.slides.length - 1 : swiper.slides.length - 1;\n\t\t\treturn swiper.slideTo(lastIndex, speed, runCallbacks, internal);\n\t\t} else if (params.loop && swiper.activeIndex === 0 && params.cssMode) {\n\t\t\trequestAnimationFrame(() => {\n\t\t\t\tswiper.slideTo(prevIndex, speed, runCallbacks, internal);\n\t\t\t});\n\t\t\treturn true;\n\t\t}\n\t\treturn swiper.slideTo(prevIndex, speed, runCallbacks, internal);\n\t}\n\n\t/* eslint no-unused-vars: \"off\" */\n\tfunction slideReset(speed, runCallbacks, internal) {\n\t\tif (runCallbacks === void 0) {\n\t\t\trunCallbacks = true;\n\t\t}\n\t\tconst swiper = this;\n\t\tif (swiper.destroyed) return;\n\t\tif (typeof speed === 'undefined') {\n\t\t\tspeed = swiper.params.speed;\n\t\t}\n\t\treturn swiper.slideTo(swiper.activeIndex, speed, runCallbacks, internal);\n\t}\n\n\t/* eslint no-unused-vars: \"off\" */\n\tfunction slideToClosest(speed, runCallbacks, internal, threshold) {\n\t\tif (runCallbacks === void 0) {\n\t\t\trunCallbacks = true;\n\t\t}\n\t\tif (threshold === void 0) {\n\t\t\tthreshold = 0.5;\n\t\t}\n\t\tconst swiper = this;\n\t\tif (swiper.destroyed) return;\n\t\tif (typeof speed === 'undefined') {\n\t\t\tspeed = swiper.params.speed;\n\t\t}\n\t\tlet index = swiper.activeIndex;\n\t\tconst skip = Math.min(swiper.params.slidesPerGroupSkip, index);\n\t\tconst snapIndex = skip + Math.floor((index - skip) / swiper.params.slidesPerGroup);\n\t\tconst translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;\n\t\tif (translate >= swiper.snapGrid[snapIndex]) {\n\t\t\t// The current translate is on or after the current snap index, so the choice\n\t\t\t// is between the current index and the one after it.\n\t\t\tconst currentSnap = swiper.snapGrid[snapIndex];\n\t\t\tconst nextSnap = swiper.snapGrid[snapIndex + 1];\n\t\t\tif (translate - currentSnap > (nextSnap - currentSnap) * threshold) {\n\t\t\t\tindex += swiper.params.slidesPerGroup;\n\t\t\t}\n\t\t} else {\n\t\t\t// The current translate is before the current snap index, so the choice\n\t\t\t// is between the current index and the one before it.\n\t\t\tconst prevSnap = swiper.snapGrid[snapIndex - 1];\n\t\t\tconst currentSnap = swiper.snapGrid[snapIndex];\n\t\t\tif (translate - prevSnap <= (currentSnap - prevSnap) * threshold) {\n\t\t\t\tindex -= swiper.params.slidesPerGroup;\n\t\t\t}\n\t\t}\n\t\tindex = Math.max(index, 0);\n\t\tindex = Math.min(index, swiper.slidesGrid.length - 1);\n\t\treturn swiper.slideTo(index, speed, runCallbacks, internal);\n\t}\n\n\tfunction slideToClickedSlide() {\n\t\tconst swiper = this;\n\t\tif (swiper.destroyed) return;\n\t\tconst {\n\t\t\tparams,\n\t\t\tslidesEl\n\t\t} = swiper;\n\t\tconst slidesPerView = params.slidesPerView === 'auto' ? swiper.slidesPerViewDynamic() : params.slidesPerView;\n\t\tlet slideToIndex = swiper.clickedIndex;\n\t\tlet realIndex;\n\t\tconst slideSelector = swiper.isElement ? `swiper-slide` : `.${params.slideClass}`;\n\t\tif (params.loop) {\n\t\t\tif (swiper.animating) return;\n\t\t\trealIndex = parseInt(swiper.clickedSlide.getAttribute('data-swiper-slide-index'), 10);\n\t\t\tif (params.centeredSlides) {\n\t\t\t\tif (slideToIndex < swiper.loopedSlides - slidesPerView / 2 || slideToIndex > swiper.slides.length - swiper.loopedSlides + slidesPerView / 2) {\n\t\t\t\t\tswiper.loopFix();\n\t\t\t\t\tslideToIndex = swiper.getSlideIndex(elementChildren(slidesEl, `${slideSelector}[data-swiper-slide-index=\"${realIndex}\"]`)[0]);\n\t\t\t\t\tnextTick(() => {\n\t\t\t\t\t\tswiper.slideTo(slideToIndex);\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tswiper.slideTo(slideToIndex);\n\t\t\t\t}\n\t\t\t} else if (slideToIndex > swiper.slides.length - slidesPerView) {\n\t\t\t\tswiper.loopFix();\n\t\t\t\tslideToIndex = swiper.getSlideIndex(elementChildren(slidesEl, `${slideSelector}[data-swiper-slide-index=\"${realIndex}\"]`)[0]);\n\t\t\t\tnextTick(() => {\n\t\t\t\t\tswiper.slideTo(slideToIndex);\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tswiper.slideTo(slideToIndex);\n\t\t\t}\n\t\t} else {\n\t\t\tswiper.slideTo(slideToIndex);\n\t\t}\n\t}\n\n\tvar slide = {\n\t\tslideTo,\n\t\tslideToLoop,\n\t\tslideNext,\n\t\tslidePrev,\n\t\tslideReset,\n\t\tslideToClosest,\n\t\tslideToClickedSlide\n\t};\n\n\tfunction loopCreate(slideRealIndex) {\n\t\tconst swiper = this;\n\t\tconst {\n\t\t\tparams,\n\t\t\tslidesEl\n\t\t} = swiper;\n\t\tif (!params.loop || swiper.virtual && swiper.params.virtual.enabled) return;\n\t\tconst initSlides = () => {\n\t\t\tconst slides = elementChildren(slidesEl, `.${params.slideClass}, swiper-slide`);\n\t\t\tslides.forEach((el, index) => {\n\t\t\t\tel.setAttribute('data-swiper-slide-index', index);\n\t\t\t});\n\t\t};\n\t\tconst gridEnabled = swiper.grid && params.grid && params.grid.rows > 1;\n\t\tconst slidesPerGroup = params.slidesPerGroup * (gridEnabled ? params.grid.rows : 1);\n\t\tconst shouldFillGroup = swiper.slides.length % slidesPerGroup !== 0;\n\t\tconst shouldFillGrid = gridEnabled && swiper.slides.length % params.grid.rows !== 0;\n\t\tconst addBlankSlides = amountOfSlides => {\n\t\t\tfor (let i = 0; i < amountOfSlides; i += 1) {\n\t\t\t\tconst slideEl = swiper.isElement ? createElement('swiper-slide', [params.slideBlankClass]) : createElement('div', [params.slideClass, params.slideBlankClass]);\n\t\t\t\tswiper.slidesEl.append(slideEl);\n\t\t\t}\n\t\t};\n\t\tif (shouldFillGroup) {\n\t\t\tif (params.loopAddBlankSlides) {\n\t\t\t\tconst slidesToAdd = slidesPerGroup - swiper.slides.length % slidesPerGroup;\n\t\t\t\taddBlankSlides(slidesToAdd);\n\t\t\t\tswiper.recalcSlides();\n\t\t\t\tswiper.updateSlides();\n\t\t\t} else {\n\t\t\t\tshowWarning('Swiper Loop Warning: The number of slides is not even to slidesPerGroup, loop mode may not function properly. You need to add more slides (or make duplicates, or empty slides)');\n\t\t\t}\n\t\t\tinitSlides();\n\t\t} else if (shouldFillGrid) {\n\t\t\tif (params.loopAddBlankSlides) {\n\t\t\t\tconst slidesToAdd = params.grid.rows - swiper.slides.length % params.grid.rows;\n\t\t\t\taddBlankSlides(slidesToAdd);\n\t\t\t\tswiper.recalcSlides();\n\t\t\t\tswiper.updateSlides();\n\t\t\t} else {\n\t\t\t\tshowWarning('Swiper Loop Warning: The number of slides is not even to grid.rows, loop mode may not function properly. You need to add more slides (or make duplicates, or empty slides)');\n\t\t\t}\n\t\t\tinitSlides();\n\t\t} else {\n\t\t\tinitSlides();\n\t\t}\n\t\tswiper.loopFix({\n\t\t\tslideRealIndex,\n\t\t\tdirection: params.centeredSlides ? undefined : 'next'\n\t\t});\n\t}\n\n\tfunction loopFix(_temp) {\n\t\tlet {\n\t\t\tslideRealIndex,\n\t\t\tslideTo = true,\n\t\t\tdirection,\n\t\t\tsetTranslate,\n\t\t\tactiveSlideIndex,\n\t\t\tbyController,\n\t\t\tbyMousewheel\n\t\t} = _temp === void 0 ? {} : _temp;\n\t\tconst swiper = this;\n\t\tif (!swiper.params.loop) return;\n\t\tswiper.emit('beforeLoopFix');\n\t\tconst {\n\t\t\tslides,\n\t\t\tallowSlidePrev,\n\t\t\tallowSlideNext,\n\t\t\tslidesEl,\n\t\t\tparams\n\t\t} = swiper;\n\t\tconst {\n\t\t\tcenteredSlides\n\t\t} = params;\n\t\tswiper.allowSlidePrev = true;\n\t\tswiper.allowSlideNext = true;\n\t\tif (swiper.virtual && params.virtual.enabled) {\n\t\t\tif (slideTo) {\n\t\t\t\tif (!params.centeredSlides && swiper.snapIndex === 0) {\n\t\t\t\t\tswiper.slideTo(swiper.virtual.slides.length, 0, false, true);\n\t\t\t\t} else if (params.centeredSlides && swiper.snapIndex < params.slidesPerView) {\n\t\t\t\t\tswiper.slideTo(swiper.virtual.slides.length + swiper.snapIndex, 0, false, true);\n\t\t\t\t} else if (swiper.snapIndex === swiper.snapGrid.length - 1) {\n\t\t\t\t\tswiper.slideTo(swiper.virtual.slidesBefore, 0, false, true);\n\t\t\t\t}\n\t\t\t}\n\t\t\tswiper.allowSlidePrev = allowSlidePrev;\n\t\t\tswiper.allowSlideNext = allowSlideNext;\n\t\t\tswiper.emit('loopFix');\n\t\t\treturn;\n\t\t}\n\t\tlet slidesPerView = params.slidesPerView;\n\t\tif (slidesPerView === 'auto') {\n\t\t\tslidesPerView = swiper.slidesPerViewDynamic();\n\t\t} else {\n\t\t\tslidesPerView = Math.ceil(parseFloat(params.slidesPerView, 10));\n\t\t\tif (centeredSlides && slidesPerView % 2 === 0) {\n\t\t\t\tslidesPerView = slidesPerView + 1;\n\t\t\t}\n\t\t}\n\t\tconst slidesPerGroup = params.slidesPerGroupAuto ? slidesPerView : params.slidesPerGroup;\n\t\tlet loopedSlides = slidesPerGroup;\n\t\tif (loopedSlides % slidesPerGroup !== 0) {\n\t\t\tloopedSlides += slidesPerGroup - loopedSlides % slidesPerGroup;\n\t\t}\n\t\tloopedSlides += params.loopAdditionalSlides;\n\t\tswiper.loopedSlides = loopedSlides;\n\t\tconst gridEnabled = swiper.grid && params.grid && params.grid.rows > 1;\n\t\tif (slides.length < slidesPerView + loopedSlides) {\n\t\t\tshowWarning('Swiper Loop Warning: The number of slides is not enough for loop mode, it will be disabled and not function properly. You need to add more slides (or make duplicates) or lower the values of slidesPerView and slidesPerGroup parameters');\n\t\t} else if (gridEnabled && params.grid.fill === 'row') {\n\t\t\tshowWarning('Swiper Loop Warning: Loop mode is not compatible with grid.fill = `row`');\n\t\t}\n\t\tconst prependSlidesIndexes = [];\n\t\tconst appendSlidesIndexes = [];\n\t\tlet activeIndex = swiper.activeIndex;\n\t\tif (typeof activeSlideIndex === 'undefined') {\n\t\t\tactiveSlideIndex = swiper.getSlideIndex(slides.filter(el => el.classList.contains(params.slideActiveClass))[0]);\n\t\t} else {\n\t\t\tactiveIndex = activeSlideIndex;\n\t\t}\n\t\tconst isNext = direction === 'next' || !direction;\n\t\tconst isPrev = direction === 'prev' || !direction;\n\t\tlet slidesPrepended = 0;\n\t\tlet slidesAppended = 0;\n\t\tconst cols = gridEnabled ? Math.ceil(slides.length / params.grid.rows) : slides.length;\n\t\tconst activeColIndex = gridEnabled ? slides[activeSlideIndex].column : activeSlideIndex;\n\t\tconst activeColIndexWithShift = activeColIndex + (centeredSlides && typeof setTranslate === 'undefined' ? -slidesPerView / 2 + 0.5 : 0);\n\t\t// prepend last slides before start\n\t\tif (activeColIndexWithShift < loopedSlides) {\n\t\t\tslidesPrepended = Math.max(loopedSlides - activeColIndexWithShift, slidesPerGroup);\n\t\t\tfor (let i = 0; i < loopedSlides - activeColIndexWithShift; i += 1) {\n\t\t\t\tconst index = i - Math.floor(i / cols) * cols;\n\t\t\t\tif (gridEnabled) {\n\t\t\t\t\tconst colIndexToPrepend = cols - index - 1;\n\t\t\t\t\tfor (let i = slides.length - 1; i >= 0; i -= 1) {\n\t\t\t\t\t\tif (slides[i].column === colIndexToPrepend) prependSlidesIndexes.push(i);\n\t\t\t\t\t}\n\t\t\t\t\t// slides.forEach((slide, slideIndex) => {\n\t\t\t\t\t//   if (slide.column === colIndexToPrepend) prependSlidesIndexes.push(slideIndex);\n\t\t\t\t\t// });\n\t\t\t\t} else {\n\t\t\t\t\tprependSlidesIndexes.push(cols - index - 1);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (activeColIndexWithShift + slidesPerView > cols - loopedSlides) {\n\t\t\tslidesAppended = Math.max(activeColIndexWithShift - (cols - loopedSlides * 2), slidesPerGroup);\n\t\t\tfor (let i = 0; i < slidesAppended; i += 1) {\n\t\t\t\tconst index = i - Math.floor(i / cols) * cols;\n\t\t\t\tif (gridEnabled) {\n\t\t\t\t\tslides.forEach((slide, slideIndex) => {\n\t\t\t\t\t\tif (slide.column === index) appendSlidesIndexes.push(slideIndex);\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tappendSlidesIndexes.push(index);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tswiper.__preventObserver__ = true;\n\t\trequestAnimationFrame(() => {\n\t\t\tswiper.__preventObserver__ = false;\n\t\t});\n\t\tif (isPrev) {\n\t\t\tprependSlidesIndexes.forEach(index => {\n\t\t\t\tslides[index].swiperLoopMoveDOM = true;\n\t\t\t\tslidesEl.prepend(slides[index]);\n\t\t\t\tslides[index].swiperLoopMoveDOM = false;\n\t\t\t});\n\t\t}\n\t\tif (isNext) {\n\t\t\tappendSlidesIndexes.forEach(index => {\n\t\t\t\tslides[index].swiperLoopMoveDOM = true;\n\t\t\t\tslidesEl.append(slides[index]);\n\t\t\t\tslides[index].swiperLoopMoveDOM = false;\n\t\t\t});\n\t\t}\n\t\tswiper.recalcSlides();\n\t\tif (params.slidesPerView === 'auto') {\n\t\t\tswiper.updateSlides();\n\t\t} else if (gridEnabled && (prependSlidesIndexes.length > 0 && isPrev || appendSlidesIndexes.length > 0 && isNext)) {\n\t\t\tswiper.slides.forEach((slide, slideIndex) => {\n\t\t\t\tswiper.grid.updateSlide(slideIndex, slide, swiper.slides);\n\t\t\t});\n\t\t}\n\t\tif (params.watchSlidesProgress) {\n\t\t\tswiper.updateSlidesOffset();\n\t\t}\n\t\tif (slideTo) {\n\t\t\tif (prependSlidesIndexes.length > 0 && isPrev) {\n\t\t\t\tif (typeof slideRealIndex === 'undefined') {\n\t\t\t\t\tconst currentSlideTranslate = swiper.slidesGrid[activeIndex];\n\t\t\t\t\tconst newSlideTranslate = swiper.slidesGrid[activeIndex + slidesPrepended];\n\t\t\t\t\tconst diff = newSlideTranslate - currentSlideTranslate;\n\t\t\t\t\tif (byMousewheel) {\n\t\t\t\t\t\tswiper.setTranslate(swiper.translate - diff);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tswiper.slideTo(activeIndex + Math.ceil(slidesPrepended), 0, false, true);\n\t\t\t\t\t\tif (setTranslate) {\n\t\t\t\t\t\t\tswiper.touchEventsData.startTranslate = swiper.touchEventsData.startTranslate - diff;\n\t\t\t\t\t\t\tswiper.touchEventsData.currentTranslate = swiper.touchEventsData.currentTranslate - diff;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (setTranslate) {\n\t\t\t\t\t\tconst shift = gridEnabled ? prependSlidesIndexes.length / params.grid.rows : prependSlidesIndexes.length;\n\t\t\t\t\t\tswiper.slideTo(swiper.activeIndex + shift, 0, false, true);\n\t\t\t\t\t\tswiper.touchEventsData.currentTranslate = swiper.translate;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (appendSlidesIndexes.length > 0 && isNext) {\n\t\t\t\tif (typeof slideRealIndex === 'undefined') {\n\t\t\t\t\tconst currentSlideTranslate = swiper.slidesGrid[activeIndex];\n\t\t\t\t\tconst newSlideTranslate = swiper.slidesGrid[activeIndex - slidesAppended];\n\t\t\t\t\tconst diff = newSlideTranslate - currentSlideTranslate;\n\t\t\t\t\tif (byMousewheel) {\n\t\t\t\t\t\tswiper.setTranslate(swiper.translate - diff);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tswiper.slideTo(activeIndex - slidesAppended, 0, false, true);\n\t\t\t\t\t\tif (setTranslate) {\n\t\t\t\t\t\t\tswiper.touchEventsData.startTranslate = swiper.touchEventsData.startTranslate - diff;\n\t\t\t\t\t\t\tswiper.touchEventsData.currentTranslate = swiper.touchEventsData.currentTranslate - diff;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tconst shift = gridEnabled ? appendSlidesIndexes.length / params.grid.rows : appendSlidesIndexes.length;\n\t\t\t\t\tswiper.slideTo(swiper.activeIndex - shift, 0, false, true);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tswiper.allowSlidePrev = allowSlidePrev;\n\t\tswiper.allowSlideNext = allowSlideNext;\n\t\tif (swiper.controller && swiper.controller.control && !byController) {\n\t\t\tconst loopParams = {\n\t\t\t\tslideRealIndex,\n\t\t\t\tdirection,\n\t\t\t\tsetTranslate,\n\t\t\t\tactiveSlideIndex,\n\t\t\t\tbyController: true\n\t\t\t};\n\t\t\tif (Array.isArray(swiper.controller.control)) {\n\t\t\t\tswiper.controller.control.forEach(c => {\n\t\t\t\t\tif (!c.destroyed && c.params.loop) c.loopFix({\n\t\t\t\t\t\t...loopParams,\n\t\t\t\t\t\tslideTo: c.params.slidesPerView === params.slidesPerView ? slideTo : false\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t} else if (swiper.controller.control instanceof swiper.constructor && swiper.controller.control.params.loop) {\n\t\t\t\tswiper.controller.control.loopFix({\n\t\t\t\t\t...loopParams,\n\t\t\t\t\tslideTo: swiper.controller.control.params.slidesPerView === params.slidesPerView ? slideTo : false\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\tswiper.emit('loopFix');\n\t}\n\n\tfunction loopDestroy() {\n\t\tconst swiper = this;\n\t\tconst {\n\t\t\tparams,\n\t\t\tslidesEl\n\t\t} = swiper;\n\t\tif (!params.loop || swiper.virtual && swiper.params.virtual.enabled) return;\n\t\tswiper.recalcSlides();\n\t\tconst newSlidesOrder = [];\n\t\tswiper.slides.forEach(slideEl => {\n\t\t\tconst index = typeof slideEl.swiperSlideIndex === 'undefined' ? slideEl.getAttribute('data-swiper-slide-index') * 1 : slideEl.swiperSlideIndex;\n\t\t\tnewSlidesOrder[index] = slideEl;\n\t\t});\n\t\tswiper.slides.forEach(slideEl => {\n\t\t\tslideEl.removeAttribute('data-swiper-slide-index');\n\t\t});\n\t\tnewSlidesOrder.forEach(slideEl => {\n\t\t\tslidesEl.append(slideEl);\n\t\t});\n\t\tswiper.recalcSlides();\n\t\tswiper.slideTo(swiper.realIndex, 0);\n\t}\n\n\tvar loop = {\n\t\tloopCreate,\n\t\tloopFix,\n\t\tloopDestroy\n\t};\n\n\tfunction setGrabCursor(moving) {\n\t\tconst swiper = this;\n\t\tif (!swiper.params.simulateTouch || swiper.params.watchOverflow && swiper.isLocked || swiper.params.cssMode) return;\n\t\tconst el = swiper.params.touchEventsTarget === 'container' ? swiper.el : swiper.wrapperEl;\n\t\tif (swiper.isElement) {\n\t\t\tswiper.__preventObserver__ = true;\n\t\t}\n\t\tel.style.cursor = 'move';\n\t\tel.style.cursor = moving ? 'grabbing' : 'grab';\n\t\tif (swiper.isElement) {\n\t\t\trequestAnimationFrame(() => {\n\t\t\t\tswiper.__preventObserver__ = false;\n\t\t\t});\n\t\t}\n\t}\n\n\tfunction unsetGrabCursor() {\n\t\tconst swiper = this;\n\t\tif (swiper.params.watchOverflow && swiper.isLocked || swiper.params.cssMode) {\n\t\t\treturn;\n\t\t}\n\t\tif (swiper.isElement) {\n\t\t\tswiper.__preventObserver__ = true;\n\t\t}\n\t\tswiper[swiper.params.touchEventsTarget === 'container' ? 'el' : 'wrapperEl'].style.cursor = '';\n\t\tif (swiper.isElement) {\n\t\t\trequestAnimationFrame(() => {\n\t\t\t\tswiper.__preventObserver__ = false;\n\t\t\t});\n\t\t}\n\t}\n\n\tvar grabCursor = {\n\t\tsetGrabCursor,\n\t\tunsetGrabCursor\n\t};\n\n\t// Modified from https://stackoverflow.com/questions/54520554/custom-element-getrootnode-closest-function-crossing-multiple-parent-shadowd\n\tfunction closestElement(selector, base) {\n\t\tif (base === void 0) {\n\t\t\tbase = this;\n\t\t}\n\t\tfunction __closestFrom(el) {\n\t\t\tif (!el || el === getDocument() || el === getWindow()) return null;\n\t\t\tif (el.assignedSlot) el = el.assignedSlot;\n\t\t\tconst found = el.closest(selector);\n\t\t\tif (!found && !el.getRootNode) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\treturn found || __closestFrom(el.getRootNode().host);\n\t\t}\n\t\treturn __closestFrom(base);\n\t}\n\tfunction preventEdgeSwipe(swiper, event, startX) {\n\t\tconst window = getWindow();\n\t\tconst {\n\t\t\tparams\n\t\t} = swiper;\n\t\tconst edgeSwipeDetection = params.edgeSwipeDetection;\n\t\tconst edgeSwipeThreshold = params.edgeSwipeThreshold;\n\t\tif (edgeSwipeDetection && (startX <= edgeSwipeThreshold || startX >= window.innerWidth - edgeSwipeThreshold)) {\n\t\t\tif (edgeSwipeDetection === 'prevent') {\n\t\t\t\tevent.preventDefault();\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\tfunction onTouchStart(event) {\n\t\tconst swiper = this;\n\t\tconst document = getDocument();\n\t\tlet e = event;\n\t\tif (e.originalEvent) e = e.originalEvent;\n\t\tconst data = swiper.touchEventsData;\n\t\tif (e.type === 'pointerdown') {\n\t\t\tif (data.pointerId !== null && data.pointerId !== e.pointerId) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tdata.pointerId = e.pointerId;\n\t\t} else if (e.type === 'touchstart' && e.targetTouches.length === 1) {\n\t\t\tdata.touchId = e.targetTouches[0].identifier;\n\t\t}\n\t\tif (e.type === 'touchstart') {\n\t\t\t// don't proceed touch event\n\t\t\tpreventEdgeSwipe(swiper, e, e.targetTouches[0].pageX);\n\t\t\treturn;\n\t\t}\n\t\tconst {\n\t\t\tparams,\n\t\t\ttouches,\n\t\t\tenabled\n\t\t} = swiper;\n\t\tif (!enabled) return;\n\t\tif (!params.simulateTouch && e.pointerType === 'mouse') return;\n\t\tif (swiper.animating && params.preventInteractionOnTransition) {\n\t\t\treturn;\n\t\t}\n\t\tif (!swiper.animating && params.cssMode && params.loop) {\n\t\t\tswiper.loopFix();\n\t\t}\n\t\tlet targetEl = e.target;\n\t\tif (params.touchEventsTarget === 'wrapper') {\n\t\t\tif (!swiper.wrapperEl.contains(targetEl)) return;\n\t\t}\n\t\tif ('which' in e && e.which === 3) return;\n\t\tif ('button' in e && e.button > 0) return;\n\t\tif (data.isTouched && data.isMoved) return;\n\n\t\t// change target el for shadow root component\n\t\tconst swipingClassHasValue = !!params.noSwipingClass && params.noSwipingClass !== '';\n\t\t// eslint-disable-next-line\n\t\tconst eventPath = e.composedPath ? e.composedPath() : e.path;\n\t\tif (swipingClassHasValue && e.target && e.target.shadowRoot && eventPath) {\n\t\t\ttargetEl = eventPath[0];\n\t\t}\n\t\tconst noSwipingSelector = params.noSwipingSelector ? params.noSwipingSelector : `.${params.noSwipingClass}`;\n\t\tconst isTargetShadow = !!(e.target && e.target.shadowRoot);\n\n\t\t// use closestElement for shadow root element to get the actual closest for nested shadow root element\n\t\tif (params.noSwiping && (isTargetShadow ? closestElement(noSwipingSelector, targetEl) : targetEl.closest(noSwipingSelector))) {\n\t\t\tswiper.allowClick = true;\n\t\t\treturn;\n\t\t}\n\t\tif (params.swipeHandler) {\n\t\t\tif (!targetEl.closest(params.swipeHandler)) return;\n\t\t}\n\t\ttouches.currentX = e.pageX;\n\t\ttouches.currentY = e.pageY;\n\t\tconst startX = touches.currentX;\n\t\tconst startY = touches.currentY;\n\n\t\t// Do NOT start if iOS edge swipe is detected. Otherwise iOS app cannot swipe-to-go-back anymore\n\n\t\tif (!preventEdgeSwipe(swiper, e, startX)) {\n\t\t\treturn;\n\t\t}\n\t\tObject.assign(data, {\n\t\t\tisTouched: true,\n\t\t\tisMoved: false,\n\t\t\tallowTouchCallbacks: true,\n\t\t\tisScrolling: undefined,\n\t\t\tstartMoving: undefined\n\t\t});\n\t\ttouches.startX = startX;\n\t\ttouches.startY = startY;\n\t\tdata.touchStartTime = now();\n\t\tswiper.allowClick = true;\n\t\tswiper.updateSize();\n\t\tswiper.swipeDirection = undefined;\n\t\tif (params.threshold > 0) data.allowThresholdMove = false;\n\t\tlet preventDefault = true;\n\t\tif (targetEl.matches(data.focusableElements)) {\n\t\t\tpreventDefault = false;\n\t\t\tif (targetEl.nodeName === 'SELECT') {\n\t\t\t\tdata.isTouched = false;\n\t\t\t}\n\t\t}\n\t\tif (document.activeElement && document.activeElement.matches(data.focusableElements) && document.activeElement !== targetEl) {\n\t\t\tdocument.activeElement.blur();\n\t\t}\n\t\tconst shouldPreventDefault = preventDefault && swiper.allowTouchMove && params.touchStartPreventDefault;\n\t\tif ((params.touchStartForcePreventDefault || shouldPreventDefault) && !targetEl.isContentEditable) {\n\t\t\te.preventDefault();\n\t\t}\n\t\tif (params.freeMode && params.freeMode.enabled && swiper.freeMode && swiper.animating && !params.cssMode) {\n\t\t\tswiper.freeMode.onTouchStart();\n\t\t}\n\t\tswiper.emit('touchStart', e);\n\t}\n\n\tfunction onTouchMove(event) {\n\t\tconst document = getDocument();\n\t\tconst swiper = this;\n\t\tconst data = swiper.touchEventsData;\n\t\tconst {\n\t\t\tparams,\n\t\t\ttouches,\n\t\t\trtlTranslate: rtl,\n\t\t\tenabled\n\t\t} = swiper;\n\t\tif (!enabled) return;\n\t\tif (!params.simulateTouch && event.pointerType === 'mouse') return;\n\t\tlet e = event;\n\t\tif (e.originalEvent) e = e.originalEvent;\n\t\tif (e.type === 'pointermove') {\n\t\t\tif (data.touchId !== null) return; // return from pointer if we use touch\n\t\t\tconst id = e.pointerId;\n\t\t\tif (id !== data.pointerId) return;\n\t\t}\n\t\tlet targetTouch;\n\t\tif (e.type === 'touchmove') {\n\t\t\ttargetTouch = [...e.changedTouches].filter(t => t.identifier === data.touchId)[0];\n\t\t\tif (!targetTouch || targetTouch.identifier !== data.touchId) return;\n\t\t} else {\n\t\t\ttargetTouch = e;\n\t\t}\n\t\tif (!data.isTouched) {\n\t\t\tif (data.startMoving && data.isScrolling) {\n\t\t\t\tswiper.emit('touchMoveOpposite', e);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tconst pageX = targetTouch.pageX;\n\t\tconst pageY = targetTouch.pageY;\n\t\tif (e.preventedByNestedSwiper) {\n\t\t\ttouches.startX = pageX;\n\t\t\ttouches.startY = pageY;\n\t\t\treturn;\n\t\t}\n\t\tif (!swiper.allowTouchMove) {\n\t\t\tif (!e.target.matches(data.focusableElements)) {\n\t\t\t\tswiper.allowClick = false;\n\t\t\t}\n\t\t\tif (data.isTouched) {\n\t\t\t\tObject.assign(touches, {\n\t\t\t\t\tstartX: pageX,\n\t\t\t\t\tstartY: pageY,\n\t\t\t\t\tcurrentX: pageX,\n\t\t\t\t\tcurrentY: pageY\n\t\t\t\t});\n\t\t\t\tdata.touchStartTime = now();\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tif (params.touchReleaseOnEdges && !params.loop) {\n\t\t\tif (swiper.isVertical()) {\n\t\t\t\t// Vertical\n\t\t\t\tif (pageY < touches.startY && swiper.translate <= swiper.maxTranslate() || pageY > touches.startY && swiper.translate >= swiper.minTranslate()) {\n\t\t\t\t\tdata.isTouched = false;\n\t\t\t\t\tdata.isMoved = false;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else if (pageX < touches.startX && swiper.translate <= swiper.maxTranslate() || pageX > touches.startX && swiper.translate >= swiper.minTranslate()) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (document.activeElement) {\n\t\t\tif (e.target === document.activeElement && e.target.matches(data.focusableElements)) {\n\t\t\t\tdata.isMoved = true;\n\t\t\t\tswiper.allowClick = false;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (data.allowTouchCallbacks) {\n\t\t\tswiper.emit('touchMove', e);\n\t\t}\n\t\ttouches.previousX = touches.currentX;\n\t\ttouches.previousY = touches.currentY;\n\t\ttouches.currentX = pageX;\n\t\ttouches.currentY = pageY;\n\t\tconst diffX = touches.currentX - touches.startX;\n\t\tconst diffY = touches.currentY - touches.startY;\n\t\tif (swiper.params.threshold && Math.sqrt(diffX ** 2 + diffY ** 2) < swiper.params.threshold) return;\n\t\tif (typeof data.isScrolling === 'undefined') {\n\t\t\tlet touchAngle;\n\t\t\tif (swiper.isHorizontal() && touches.currentY === touches.startY || swiper.isVertical() && touches.currentX === touches.startX) {\n\t\t\t\tdata.isScrolling = false;\n\t\t\t} else {\n\t\t\t\t// eslint-disable-next-line\n\t\t\t\tif (diffX * diffX + diffY * diffY >= 25) {\n\t\t\t\t\ttouchAngle = Math.atan2(Math.abs(diffY), Math.abs(diffX)) * 180 / Math.PI;\n\t\t\t\t\tdata.isScrolling = swiper.isHorizontal() ? touchAngle > params.touchAngle : 90 - touchAngle > params.touchAngle;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (data.isScrolling) {\n\t\t\tswiper.emit('touchMoveOpposite', e);\n\t\t}\n\t\tif (typeof data.startMoving === 'undefined') {\n\t\t\tif (touches.currentX !== touches.startX || touches.currentY !== touches.startY) {\n\t\t\t\tdata.startMoving = true;\n\t\t\t}\n\t\t}\n\t\tif (data.isScrolling || e.type === 'touchmove' && data.preventTouchMoveFromPointerMove) {\n\t\t\tdata.isTouched = false;\n\t\t\treturn;\n\t\t}\n\t\tif (!data.startMoving) {\n\t\t\treturn;\n\t\t}\n\t\tswiper.allowClick = false;\n\t\tif (!params.cssMode && e.cancelable) {\n\t\t\te.preventDefault();\n\t\t}\n\t\tif (params.touchMoveStopPropagation && !params.nested) {\n\t\t\te.stopPropagation();\n\t\t}\n\t\tlet diff = swiper.isHorizontal() ? diffX : diffY;\n\t\tlet touchesDiff = swiper.isHorizontal() ? touches.currentX - touches.previousX : touches.currentY - touches.previousY;\n\t\tif (params.oneWayMovement) {\n\t\t\tdiff = Math.abs(diff) * (rtl ? 1 : -1);\n\t\t\ttouchesDiff = Math.abs(touchesDiff) * (rtl ? 1 : -1);\n\t\t}\n\t\ttouches.diff = diff;\n\t\tdiff *= params.touchRatio;\n\t\tif (rtl) {\n\t\t\tdiff = -diff;\n\t\t\ttouchesDiff = -touchesDiff;\n\t\t}\n\t\tconst prevTouchesDirection = swiper.touchesDirection;\n\t\tswiper.swipeDirection = diff > 0 ? 'prev' : 'next';\n\t\tswiper.touchesDirection = touchesDiff > 0 ? 'prev' : 'next';\n\t\tconst isLoop = swiper.params.loop && !params.cssMode;\n\t\tconst allowLoopFix = swiper.touchesDirection === 'next' && swiper.allowSlideNext || swiper.touchesDirection === 'prev' && swiper.allowSlidePrev;\n\t\tif (!data.isMoved) {\n\t\t\tif (isLoop && allowLoopFix) {\n\t\t\t\tswiper.loopFix({\n\t\t\t\t\tdirection: swiper.swipeDirection\n\t\t\t\t});\n\t\t\t}\n\t\t\tdata.startTranslate = swiper.getTranslate();\n\t\t\tswiper.setTransition(0);\n\t\t\tif (swiper.animating) {\n\t\t\t\tconst evt = new window.CustomEvent('transitionend', {\n\t\t\t\t\tbubbles: true,\n\t\t\t\t\tcancelable: true,\n\t\t\t\t\tdetail: {\n\t\t\t\t\t\tbySwiperTouchMove: true\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tswiper.wrapperEl.dispatchEvent(evt);\n\t\t\t}\n\t\t\tdata.allowMomentumBounce = false;\n\t\t\t// Grab Cursor\n\t\t\tif (params.grabCursor && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {\n\t\t\t\tswiper.setGrabCursor(true);\n\t\t\t}\n\t\t\tswiper.emit('sliderFirstMove', e);\n\t\t}\n\t\tlet loopFixed;\n\t\tnew Date().getTime();\n\t\tif (data.isMoved && data.allowThresholdMove && prevTouchesDirection !== swiper.touchesDirection && isLoop && allowLoopFix && Math.abs(diff) >= 1) {\n\t\t\tObject.assign(touches, {\n\t\t\t\tstartX: pageX,\n\t\t\t\tstartY: pageY,\n\t\t\t\tcurrentX: pageX,\n\t\t\t\tcurrentY: pageY,\n\t\t\t\tstartTranslate: data.currentTranslate\n\t\t\t});\n\t\t\tdata.loopSwapReset = true;\n\t\t\tdata.startTranslate = data.currentTranslate;\n\t\t\treturn;\n\t\t}\n\t\tswiper.emit('sliderMove', e);\n\t\tdata.isMoved = true;\n\t\tdata.currentTranslate = diff + data.startTranslate;\n\t\tlet disableParentSwiper = true;\n\t\tlet resistanceRatio = params.resistanceRatio;\n\t\tif (params.touchReleaseOnEdges) {\n\t\t\tresistanceRatio = 0;\n\t\t}\n\t\tif (diff > 0) {\n\t\t\tif (isLoop && allowLoopFix && !loopFixed && data.allowThresholdMove && data.currentTranslate > (params.centeredSlides ? swiper.minTranslate() - swiper.slidesSizesGrid[swiper.activeIndex + 1] : swiper.minTranslate())) {\n\t\t\t\tswiper.loopFix({\n\t\t\t\t\tdirection: 'prev',\n\t\t\t\t\tsetTranslate: true,\n\t\t\t\t\tactiveSlideIndex: 0\n\t\t\t\t});\n\t\t\t}\n\t\t\tif (data.currentTranslate > swiper.minTranslate()) {\n\t\t\t\tdisableParentSwiper = false;\n\t\t\t\tif (params.resistance) {\n\t\t\t\t\tdata.currentTranslate = swiper.minTranslate() - 1 + (-swiper.minTranslate() + data.startTranslate + diff) ** resistanceRatio;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (diff < 0) {\n\t\t\tif (isLoop && allowLoopFix && !loopFixed && data.allowThresholdMove && data.currentTranslate < (params.centeredSlides ? swiper.maxTranslate() + swiper.slidesSizesGrid[swiper.slidesSizesGrid.length - 1] : swiper.maxTranslate())) {\n\t\t\t\tswiper.loopFix({\n\t\t\t\t\tdirection: 'next',\n\t\t\t\t\tsetTranslate: true,\n\t\t\t\t\tactiveSlideIndex: swiper.slides.length - (params.slidesPerView === 'auto' ? swiper.slidesPerViewDynamic() : Math.ceil(parseFloat(params.slidesPerView, 10)))\n\t\t\t\t});\n\t\t\t}\n\t\t\tif (data.currentTranslate < swiper.maxTranslate()) {\n\t\t\t\tdisableParentSwiper = false;\n\t\t\t\tif (params.resistance) {\n\t\t\t\t\tdata.currentTranslate = swiper.maxTranslate() + 1 - (swiper.maxTranslate() - data.startTranslate - diff) ** resistanceRatio;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (disableParentSwiper) {\n\t\t\te.preventedByNestedSwiper = true;\n\t\t}\n\n\t\t// Directions locks\n\t\tif (!swiper.allowSlideNext && swiper.swipeDirection === 'next' && data.currentTranslate < data.startTranslate) {\n\t\t\tdata.currentTranslate = data.startTranslate;\n\t\t}\n\t\tif (!swiper.allowSlidePrev && swiper.swipeDirection === 'prev' && data.currentTranslate > data.startTranslate) {\n\t\t\tdata.currentTranslate = data.startTranslate;\n\t\t}\n\t\tif (!swiper.allowSlidePrev && !swiper.allowSlideNext) {\n\t\t\tdata.currentTranslate = data.startTranslate;\n\t\t}\n\n\t\t// Threshold\n\t\tif (params.threshold > 0) {\n\t\t\tif (Math.abs(diff) > params.threshold || data.allowThresholdMove) {\n\t\t\t\tif (!data.allowThresholdMove) {\n\t\t\t\t\tdata.allowThresholdMove = true;\n\t\t\t\t\ttouches.startX = touches.currentX;\n\t\t\t\t\ttouches.startY = touches.currentY;\n\t\t\t\t\tdata.currentTranslate = data.startTranslate;\n\t\t\t\t\ttouches.diff = swiper.isHorizontal() ? touches.currentX - touches.startX : touches.currentY - touches.startY;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdata.currentTranslate = data.startTranslate;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (!params.followFinger || params.cssMode) return;\n\n\t\t// Update active index in free mode\n\t\tif (params.freeMode && params.freeMode.enabled && swiper.freeMode || params.watchSlidesProgress) {\n\t\t\tswiper.updateActiveIndex();\n\t\t\tswiper.updateSlidesClasses();\n\t\t}\n\t\tif (params.freeMode && params.freeMode.enabled && swiper.freeMode) {\n\t\t\tswiper.freeMode.onTouchMove();\n\t\t}\n\t\t// Update progress\n\t\tswiper.updateProgress(data.currentTranslate);\n\t\t// Update translate\n\t\tswiper.setTranslate(data.currentTranslate);\n\t}\n\n\tfunction onTouchEnd(event) {\n\t\tconst swiper = this;\n\t\tconst data = swiper.touchEventsData;\n\t\tlet e = event;\n\t\tif (e.originalEvent) e = e.originalEvent;\n\t\tlet targetTouch;\n\t\tconst isTouchEvent = e.type === 'touchend' || e.type === 'touchcancel';\n\t\tif (!isTouchEvent) {\n\t\t\tif (data.touchId !== null) return; // return from pointer if we use touch\n\t\t\tif (e.pointerId !== data.pointerId) return;\n\t\t\ttargetTouch = e;\n\t\t} else {\n\t\t\ttargetTouch = [...e.changedTouches].filter(t => t.identifier === data.touchId)[0];\n\t\t\tif (!targetTouch || targetTouch.identifier !== data.touchId) return;\n\t\t}\n\t\tif (['pointercancel', 'pointerout', 'pointerleave', 'contextmenu'].includes(e.type)) {\n\t\t\tconst proceed = ['pointercancel', 'contextmenu'].includes(e.type) && (swiper.browser.isSafari || swiper.browser.isWebView);\n\t\t\tif (!proceed) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tdata.pointerId = null;\n\t\tdata.touchId = null;\n\t\tconst {\n\t\t\tparams,\n\t\t\ttouches,\n\t\t\trtlTranslate: rtl,\n\t\t\tslidesGrid,\n\t\t\tenabled\n\t\t} = swiper;\n\t\tif (!enabled) return;\n\t\tif (!params.simulateTouch && e.pointerType === 'mouse') return;\n\t\tif (data.allowTouchCallbacks) {\n\t\t\tswiper.emit('touchEnd', e);\n\t\t}\n\t\tdata.allowTouchCallbacks = false;\n\t\tif (!data.isTouched) {\n\t\t\tif (data.isMoved && params.grabCursor) {\n\t\t\t\tswiper.setGrabCursor(false);\n\t\t\t}\n\t\t\tdata.isMoved = false;\n\t\t\tdata.startMoving = false;\n\t\t\treturn;\n\t\t}\n\n\t\t// Return Grab Cursor\n\t\tif (params.grabCursor && data.isMoved && data.isTouched && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {\n\t\t\tswiper.setGrabCursor(false);\n\t\t}\n\n\t\t// Time diff\n\t\tconst touchEndTime = now();\n\t\tconst timeDiff = touchEndTime - data.touchStartTime;\n\n\t\t// Tap, doubleTap, Click\n\t\tif (swiper.allowClick) {\n\t\t\tconst pathTree = e.path || e.composedPath && e.composedPath();\n\t\t\tswiper.updateClickedSlide(pathTree && pathTree[0] || e.target, pathTree);\n\t\t\tswiper.emit('tap click', e);\n\t\t\tif (timeDiff < 300 && touchEndTime - data.lastClickTime < 300) {\n\t\t\t\tswiper.emit('doubleTap doubleClick', e);\n\t\t\t}\n\t\t}\n\t\tdata.lastClickTime = now();\n\t\tnextTick(() => {\n\t\t\tif (!swiper.destroyed) swiper.allowClick = true;\n\t\t});\n\t\tif (!data.isTouched || !data.isMoved || !swiper.swipeDirection || touches.diff === 0 && !data.loopSwapReset || data.currentTranslate === data.startTranslate && !data.loopSwapReset) {\n\t\t\tdata.isTouched = false;\n\t\t\tdata.isMoved = false;\n\t\t\tdata.startMoving = false;\n\t\t\treturn;\n\t\t}\n\t\tdata.isTouched = false;\n\t\tdata.isMoved = false;\n\t\tdata.startMoving = false;\n\t\tlet currentPos;\n\t\tif (params.followFinger) {\n\t\t\tcurrentPos = rtl ? swiper.translate : -swiper.translate;\n\t\t} else {\n\t\t\tcurrentPos = -data.currentTranslate;\n\t\t}\n\t\tif (params.cssMode) {\n\t\t\treturn;\n\t\t}\n\t\tif (params.freeMode && params.freeMode.enabled) {\n\t\t\tswiper.freeMode.onTouchEnd({\n\t\t\t\tcurrentPos\n\t\t\t});\n\t\t\treturn;\n\t\t}\n\n\t\t// Find current slide\n\t\tconst swipeToLast = currentPos >= -swiper.maxTranslate() && !swiper.params.loop;\n\t\tlet stopIndex = 0;\n\t\tlet groupSize = swiper.slidesSizesGrid[0];\n\t\tfor (let i = 0; i < slidesGrid.length; i += i < params.slidesPerGroupSkip ? 1 : params.slidesPerGroup) {\n\t\t\tconst increment = i < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;\n\t\t\tif (typeof slidesGrid[i + increment] !== 'undefined') {\n\t\t\t\tif (swipeToLast || currentPos >= slidesGrid[i] && currentPos < slidesGrid[i + increment]) {\n\t\t\t\t\tstopIndex = i;\n\t\t\t\t\tgroupSize = slidesGrid[i + increment] - slidesGrid[i];\n\t\t\t\t}\n\t\t\t} else if (swipeToLast || currentPos >= slidesGrid[i]) {\n\t\t\t\tstopIndex = i;\n\t\t\t\tgroupSize = slidesGrid[slidesGrid.length - 1] - slidesGrid[slidesGrid.length - 2];\n\t\t\t}\n\t\t}\n\t\tlet rewindFirstIndex = null;\n\t\tlet rewindLastIndex = null;\n\t\tif (params.rewind) {\n\t\t\tif (swiper.isBeginning) {\n\t\t\t\trewindLastIndex = params.virtual && params.virtual.enabled && swiper.virtual ? swiper.virtual.slides.length - 1 : swiper.slides.length - 1;\n\t\t\t} else if (swiper.isEnd) {\n\t\t\t\trewindFirstIndex = 0;\n\t\t\t}\n\t\t}\n\t\t// Find current slide size\n\t\tconst ratio = (currentPos - slidesGrid[stopIndex]) / groupSize;\n\t\tconst increment = stopIndex < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;\n\t\tif (timeDiff > params.longSwipesMs) {\n\t\t\t// Long touches\n\t\t\tif (!params.longSwipes) {\n\t\t\t\tswiper.slideTo(swiper.activeIndex);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (swiper.swipeDirection === 'next') {\n\t\t\t\tif (ratio >= params.longSwipesRatio) swiper.slideTo(params.rewind && swiper.isEnd ? rewindFirstIndex : stopIndex + increment); else swiper.slideTo(stopIndex);\n\t\t\t}\n\t\t\tif (swiper.swipeDirection === 'prev') {\n\t\t\t\tif (ratio > 1 - params.longSwipesRatio) {\n\t\t\t\t\tswiper.slideTo(stopIndex + increment);\n\t\t\t\t} else if (rewindLastIndex !== null && ratio < 0 && Math.abs(ratio) > params.longSwipesRatio) {\n\t\t\t\t\tswiper.slideTo(rewindLastIndex);\n\t\t\t\t} else {\n\t\t\t\t\tswiper.slideTo(stopIndex);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t// Short swipes\n\t\t\tif (!params.shortSwipes) {\n\t\t\t\tswiper.slideTo(swiper.activeIndex);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tconst isNavButtonTarget = swiper.navigation && (e.target === swiper.navigation.nextEl || e.target === swiper.navigation.prevEl);\n\t\t\tif (!isNavButtonTarget) {\n\t\t\t\tif (swiper.swipeDirection === 'next') {\n\t\t\t\t\tswiper.slideTo(rewindFirstIndex !== null ? rewindFirstIndex : stopIndex + increment);\n\t\t\t\t}\n\t\t\t\tif (swiper.swipeDirection === 'prev') {\n\t\t\t\t\tswiper.slideTo(rewindLastIndex !== null ? rewindLastIndex : stopIndex);\n\t\t\t\t}\n\t\t\t} else if (e.target === swiper.navigation.nextEl) {\n\t\t\t\tswiper.slideTo(stopIndex + increment);\n\t\t\t} else {\n\t\t\t\tswiper.slideTo(stopIndex);\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction onResize() {\n\t\tconst swiper = this;\n\t\tconst {\n\t\t\tparams,\n\t\t\tel\n\t\t} = swiper;\n\t\tif (el && el.offsetWidth === 0) return;\n\n\t\t// Breakpoints\n\t\tif (params.breakpoints) {\n\t\t\tswiper.setBreakpoint();\n\t\t}\n\n\t\t// Save locks\n\t\tconst {\n\t\t\tallowSlideNext,\n\t\t\tallowSlidePrev,\n\t\t\tsnapGrid\n\t\t} = swiper;\n\t\tconst isVirtual = swiper.virtual && swiper.params.virtual.enabled;\n\n\t\t// Disable locks on resize\n\t\tswiper.allowSlideNext = true;\n\t\tswiper.allowSlidePrev = true;\n\t\tswiper.updateSize();\n\t\tswiper.updateSlides();\n\t\tswiper.updateSlidesClasses();\n\t\tconst isVirtualLoop = isVirtual && params.loop;\n\t\tif ((params.slidesPerView === 'auto' || params.slidesPerView > 1) && swiper.isEnd && !swiper.isBeginning && !swiper.params.centeredSlides && !isVirtualLoop) {\n\t\t\tswiper.slideTo(swiper.slides.length - 1, 0, false, true);\n\t\t} else {\n\t\t\tif (swiper.params.loop && !isVirtual) {\n\t\t\t\tswiper.slideToLoop(swiper.realIndex, 0, false, true);\n\t\t\t} else {\n\t\t\t\tswiper.slideTo(swiper.activeIndex, 0, false, true);\n\t\t\t}\n\t\t}\n\t\tif (swiper.autoplay && swiper.autoplay.running && swiper.autoplay.paused) {\n\t\t\tclearTimeout(swiper.autoplay.resizeTimeout);\n\t\t\tswiper.autoplay.resizeTimeout = setTimeout(() => {\n\t\t\t\tif (swiper.autoplay && swiper.autoplay.running && swiper.autoplay.paused) {\n\t\t\t\t\tswiper.autoplay.resume();\n\t\t\t\t}\n\t\t\t}, 500);\n\t\t}\n\t\t// Return locks after resize\n\t\tswiper.allowSlidePrev = allowSlidePrev;\n\t\tswiper.allowSlideNext = allowSlideNext;\n\t\tif (swiper.params.watchOverflow && snapGrid !== swiper.snapGrid) {\n\t\t\tswiper.checkOverflow();\n\t\t}\n\t}\n\n\tfunction onClick(e) {\n\t\tconst swiper = this;\n\t\tif (!swiper.enabled) return;\n\t\tif (!swiper.allowClick) {\n\t\t\tif (swiper.params.preventClicks) e.preventDefault();\n\t\t\tif (swiper.params.preventClicksPropagation && swiper.animating) {\n\t\t\t\te.stopPropagation();\n\t\t\t\te.stopImmediatePropagation();\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction onScroll() {\n\t\tconst swiper = this;\n\t\tconst {\n\t\t\twrapperEl,\n\t\t\trtlTranslate,\n\t\t\tenabled\n\t\t} = swiper;\n\t\tif (!enabled) return;\n\t\tswiper.previousTranslate = swiper.translate;\n\t\tif (swiper.isHorizontal()) {\n\t\t\tswiper.translate = -wrapperEl.scrollLeft;\n\t\t} else {\n\t\t\tswiper.translate = -wrapperEl.scrollTop;\n\t\t}\n\t\t// eslint-disable-next-line\n\t\tif (swiper.translate === 0) swiper.translate = 0;\n\t\tswiper.updateActiveIndex();\n\t\tswiper.updateSlidesClasses();\n\t\tlet newProgress;\n\t\tconst translatesDiff = swiper.maxTranslate() - swiper.minTranslate();\n\t\tif (translatesDiff === 0) {\n\t\t\tnewProgress = 0;\n\t\t} else {\n\t\t\tnewProgress = (swiper.translate - swiper.minTranslate()) / translatesDiff;\n\t\t}\n\t\tif (newProgress !== swiper.progress) {\n\t\t\tswiper.updateProgress(rtlTranslate ? -swiper.translate : swiper.translate);\n\t\t}\n\t\tswiper.emit('setTranslate', swiper.translate, false);\n\t}\n\n\tfunction onLoad(e) {\n\t\tconst swiper = this;\n\t\tprocessLazyPreloader(swiper, e.target);\n\t\tif (swiper.params.cssMode || swiper.params.slidesPerView !== 'auto' && !swiper.params.autoHeight) {\n\t\t\treturn;\n\t\t}\n\t\tswiper.update();\n\t}\n\n\tfunction onDocumentTouchStart() {\n\t\tconst swiper = this;\n\t\tif (swiper.documentTouchHandlerProceeded) return;\n\t\tswiper.documentTouchHandlerProceeded = true;\n\t\tif (swiper.params.touchReleaseOnEdges) {\n\t\t\tswiper.el.style.touchAction = 'auto';\n\t\t}\n\t}\n\n\tconst events = (swiper, method) => {\n\t\tconst document = getDocument();\n\t\tconst {\n\t\t\tparams,\n\t\t\tel,\n\t\t\twrapperEl,\n\t\t\tdevice\n\t\t} = swiper;\n\t\tconst capture = !!params.nested;\n\t\tconst domMethod = method === 'on' ? 'addEventListener' : 'removeEventListener';\n\t\tconst swiperMethod = method;\n\t\tif (!el || typeof el === 'string') return;\n\n\t\t// Touch Events\n\t\tdocument[domMethod]('touchstart', swiper.onDocumentTouchStart, {\n\t\t\tpassive: false,\n\t\t\tcapture\n\t\t});\n\t\tel[domMethod]('touchstart', swiper.onTouchStart, {\n\t\t\tpassive: false\n\t\t});\n\t\tel[domMethod]('pointerdown', swiper.onTouchStart, {\n\t\t\tpassive: false\n\t\t});\n\t\tdocument[domMethod]('touchmove', swiper.onTouchMove, {\n\t\t\tpassive: false,\n\t\t\tcapture\n\t\t});\n\t\tdocument[domMethod]('pointermove', swiper.onTouchMove, {\n\t\t\tpassive: false,\n\t\t\tcapture\n\t\t});\n\t\tdocument[domMethod]('touchend', swiper.onTouchEnd, {\n\t\t\tpassive: true\n\t\t});\n\t\tdocument[domMethod]('pointerup', swiper.onTouchEnd, {\n\t\t\tpassive: true\n\t\t});\n\t\tdocument[domMethod]('pointercancel', swiper.onTouchEnd, {\n\t\t\tpassive: true\n\t\t});\n\t\tdocument[domMethod]('touchcancel', swiper.onTouchEnd, {\n\t\t\tpassive: true\n\t\t});\n\t\tdocument[domMethod]('pointerout', swiper.onTouchEnd, {\n\t\t\tpassive: true\n\t\t});\n\t\tdocument[domMethod]('pointerleave', swiper.onTouchEnd, {\n\t\t\tpassive: true\n\t\t});\n\t\tdocument[domMethod]('contextmenu', swiper.onTouchEnd, {\n\t\t\tpassive: true\n\t\t});\n\n\t\t// Prevent Links Clicks\n\t\tif (params.preventClicks || params.preventClicksPropagation) {\n\t\t\tel[domMethod]('click', swiper.onClick, true);\n\t\t}\n\t\tif (params.cssMode) {\n\t\t\twrapperEl[domMethod]('scroll', swiper.onScroll);\n\t\t}\n\n\t\t// Resize handler\n\t\tif (params.updateOnWindowResize) {\n\t\t\tswiper[swiperMethod](device.ios || device.android ? 'resize orientationchange observerUpdate' : 'resize observerUpdate', onResize, true);\n\t\t} else {\n\t\t\tswiper[swiperMethod]('observerUpdate', onResize, true);\n\t\t}\n\n\t\t// Images loader\n\t\tel[domMethod]('load', swiper.onLoad, {\n\t\t\tcapture: true\n\t\t});\n\t};\n\tfunction attachEvents() {\n\t\tconst swiper = this;\n\t\tconst {\n\t\t\tparams\n\t\t} = swiper;\n\t\tswiper.onTouchStart = onTouchStart.bind(swiper);\n\t\tswiper.onTouchMove = onTouchMove.bind(swiper);\n\t\tswiper.onTouchEnd = onTouchEnd.bind(swiper);\n\t\tswiper.onDocumentTouchStart = onDocumentTouchStart.bind(swiper);\n\t\tif (params.cssMode) {\n\t\t\tswiper.onScroll = onScroll.bind(swiper);\n\t\t}\n\t\tswiper.onClick = onClick.bind(swiper);\n\t\tswiper.onLoad = onLoad.bind(swiper);\n\t\tevents(swiper, 'on');\n\t}\n\tfunction detachEvents() {\n\t\tconst swiper = this;\n\t\tevents(swiper, 'off');\n\t}\n\tvar events$1 = {\n\t\tattachEvents,\n\t\tdetachEvents\n\t};\n\n\tconst isGridEnabled = (swiper, params) => {\n\t\treturn swiper.grid && params.grid && params.grid.rows > 1;\n\t};\n\tfunction setBreakpoint() {\n\t\tconst swiper = this;\n\t\tconst {\n\t\t\trealIndex,\n\t\t\tinitialized,\n\t\t\tparams,\n\t\t\tel\n\t\t} = swiper;\n\t\tconst breakpoints = params.breakpoints;\n\t\tif (!breakpoints || breakpoints && Object.keys(breakpoints).length === 0) return;\n\n\t\t// Get breakpoint for window width and update parameters\n\t\tconst breakpoint = swiper.getBreakpoint(breakpoints, swiper.params.breakpointsBase, swiper.el);\n\t\tif (!breakpoint || swiper.currentBreakpoint === breakpoint) return;\n\t\tconst breakpointOnlyParams = breakpoint in breakpoints ? breakpoints[breakpoint] : undefined;\n\t\tconst breakpointParams = breakpointOnlyParams || swiper.originalParams;\n\t\tconst wasMultiRow = isGridEnabled(swiper, params);\n\t\tconst isMultiRow = isGridEnabled(swiper, breakpointParams);\n\t\tconst wasGrabCursor = swiper.params.grabCursor;\n\t\tconst isGrabCursor = breakpointParams.grabCursor;\n\t\tconst wasEnabled = params.enabled;\n\t\tif (wasMultiRow && !isMultiRow) {\n\t\t\tel.classList.remove(`${params.containerModifierClass}grid`, `${params.containerModifierClass}grid-column`);\n\t\t\tswiper.emitContainerClasses();\n\t\t} else if (!wasMultiRow && isMultiRow) {\n\t\t\tel.classList.add(`${params.containerModifierClass}grid`);\n\t\t\tif (breakpointParams.grid.fill && breakpointParams.grid.fill === 'column' || !breakpointParams.grid.fill && params.grid.fill === 'column') {\n\t\t\t\tel.classList.add(`${params.containerModifierClass}grid-column`);\n\t\t\t}\n\t\t\tswiper.emitContainerClasses();\n\t\t}\n\t\tif (wasGrabCursor && !isGrabCursor) {\n\t\t\tswiper.unsetGrabCursor();\n\t\t} else if (!wasGrabCursor && isGrabCursor) {\n\t\t\tswiper.setGrabCursor();\n\t\t}\n\n\t\t// Toggle navigation, pagination, scrollbar\n\t\t['navigation', 'pagination', 'scrollbar'].forEach(prop => {\n\t\t\tif (typeof breakpointParams[prop] === 'undefined') return;\n\t\t\tconst wasModuleEnabled = params[prop] && params[prop].enabled;\n\t\t\tconst isModuleEnabled = breakpointParams[prop] && breakpointParams[prop].enabled;\n\t\t\tif (wasModuleEnabled && !isModuleEnabled) {\n\t\t\t\tswiper[prop].disable();\n\t\t\t}\n\t\t\tif (!wasModuleEnabled && isModuleEnabled) {\n\t\t\t\tswiper[prop].enable();\n\t\t\t}\n\t\t});\n\t\tconst directionChanged = breakpointParams.direction && breakpointParams.direction !== params.direction;\n\t\tconst needsReLoop = params.loop && (breakpointParams.slidesPerView !== params.slidesPerView || directionChanged);\n\t\tconst wasLoop = params.loop;\n\t\tif (directionChanged && initialized) {\n\t\t\tswiper.changeDirection();\n\t\t}\n\t\textend(swiper.params, breakpointParams);\n\t\tconst isEnabled = swiper.params.enabled;\n\t\tconst hasLoop = swiper.params.loop;\n\t\tObject.assign(swiper, {\n\t\t\tallowTouchMove: swiper.params.allowTouchMove,\n\t\t\tallowSlideNext: swiper.params.allowSlideNext,\n\t\t\tallowSlidePrev: swiper.params.allowSlidePrev\n\t\t});\n\t\tif (wasEnabled && !isEnabled) {\n\t\t\tswiper.disable();\n\t\t} else if (!wasEnabled && isEnabled) {\n\t\t\tswiper.enable();\n\t\t}\n\t\tswiper.currentBreakpoint = breakpoint;\n\t\tswiper.emit('_beforeBreakpoint', breakpointParams);\n\t\tif (initialized) {\n\t\t\tif (needsReLoop) {\n\t\t\t\tswiper.loopDestroy();\n\t\t\t\tswiper.loopCreate(realIndex);\n\t\t\t\tswiper.updateSlides();\n\t\t\t} else if (!wasLoop && hasLoop) {\n\t\t\t\tswiper.loopCreate(realIndex);\n\t\t\t\tswiper.updateSlides();\n\t\t\t} else if (wasLoop && !hasLoop) {\n\t\t\t\tswiper.loopDestroy();\n\t\t\t}\n\t\t}\n\t\tswiper.emit('breakpoint', breakpointParams);\n\t}\n\n\tfunction getBreakpoint(breakpoints, base, containerEl) {\n\t\tif (base === void 0) {\n\t\t\tbase = 'window';\n\t\t}\n\t\tif (!breakpoints || base === 'container' && !containerEl) return undefined;\n\t\tlet breakpoint = false;\n\t\tconst window = getWindow();\n\t\tconst currentHeight = base === 'window' ? window.innerHeight : containerEl.clientHeight;\n\t\tconst points = Object.keys(breakpoints).map(point => {\n\t\t\tif (typeof point === 'string' && point.indexOf('@') === 0) {\n\t\t\t\tconst minRatio = parseFloat(point.substr(1));\n\t\t\t\tconst value = currentHeight * minRatio;\n\t\t\t\treturn {\n\t\t\t\t\tvalue,\n\t\t\t\t\tpoint\n\t\t\t\t};\n\t\t\t}\n\t\t\treturn {\n\t\t\t\tvalue: point,\n\t\t\t\tpoint\n\t\t\t};\n\t\t});\n\t\tpoints.sort((a, b) => parseInt(a.value, 10) - parseInt(b.value, 10));\n\t\tfor (let i = 0; i < points.length; i += 1) {\n\t\t\tconst {\n\t\t\t\tpoint,\n\t\t\t\tvalue\n\t\t\t} = points[i];\n\t\t\tif (base === 'window') {\n\t\t\t\tif (window.matchMedia(`(min-width: ${value}px)`).matches) {\n\t\t\t\t\tbreakpoint = point;\n\t\t\t\t}\n\t\t\t} else if (value <= containerEl.clientWidth) {\n\t\t\t\tbreakpoint = point;\n\t\t\t}\n\t\t}\n\t\treturn breakpoint || 'max';\n\t}\n\n\tvar breakpoints = {\n\t\tsetBreakpoint,\n\t\tgetBreakpoint\n\t};\n\n\tfunction prepareClasses(entries, prefix) {\n\t\tconst resultClasses = [];\n\t\tentries.forEach(item => {\n\t\t\tif (typeof item === 'object') {\n\t\t\t\tObject.keys(item).forEach(classNames => {\n\t\t\t\t\tif (item[classNames]) {\n\t\t\t\t\t\tresultClasses.push(prefix + classNames);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t} else if (typeof item === 'string') {\n\t\t\t\tresultClasses.push(prefix + item);\n\t\t\t}\n\t\t});\n\t\treturn resultClasses;\n\t}\n\tfunction addClasses() {\n\t\tconst swiper = this;\n\t\tconst {\n\t\t\tclassNames,\n\t\t\tparams,\n\t\t\trtl,\n\t\t\tel,\n\t\t\tdevice\n\t\t} = swiper;\n\t\t// prettier-ignore\n\t\tconst suffixes = prepareClasses(['initialized', params.direction, {\n\t\t\t'free-mode': swiper.params.freeMode && params.freeMode.enabled\n\t\t}, {\n\t\t\t\t'autoheight': params.autoHeight\n\t\t\t}, {\n\t\t\t\t'rtl': rtl\n\t\t\t}, {\n\t\t\t\t'grid': params.grid && params.grid.rows > 1\n\t\t\t}, {\n\t\t\t\t'grid-column': params.grid && params.grid.rows > 1 && params.grid.fill === 'column'\n\t\t\t}, {\n\t\t\t\t'android': device.android\n\t\t\t}, {\n\t\t\t\t'ios': device.ios\n\t\t\t}, {\n\t\t\t\t'css-mode': params.cssMode\n\t\t\t}, {\n\t\t\t\t'centered': params.cssMode && params.centeredSlides\n\t\t\t}, {\n\t\t\t\t'watch-progress': params.watchSlidesProgress\n\t\t\t}], params.containerModifierClass);\n\t\tclassNames.push(...suffixes);\n\t\tel.classList.add(...classNames);\n\t\tswiper.emitContainerClasses();\n\t}\n\n\tfunction removeClasses() {\n\t\tconst swiper = this;\n\t\tconst {\n\t\t\tel,\n\t\t\tclassNames\n\t\t} = swiper;\n\t\tif (!el || typeof el === 'string') return;\n\t\tel.classList.remove(...classNames);\n\t\tswiper.emitContainerClasses();\n\t}\n\n\tvar classes = {\n\t\taddClasses,\n\t\tremoveClasses\n\t};\n\n\tfunction checkOverflow() {\n\t\tconst swiper = this;\n\t\tconst {\n\t\t\tisLocked: wasLocked,\n\t\t\tparams\n\t\t} = swiper;\n\t\tconst {\n\t\t\tslidesOffsetBefore\n\t\t} = params;\n\t\tif (slidesOffsetBefore) {\n\t\t\tconst lastSlideIndex = swiper.slides.length - 1;\n\t\t\tconst lastSlideRightEdge = swiper.slidesGrid[lastSlideIndex] + swiper.slidesSizesGrid[lastSlideIndex] + slidesOffsetBefore * 2;\n\t\t\tswiper.isLocked = swiper.size > lastSlideRightEdge;\n\t\t} else {\n\t\t\tswiper.isLocked = swiper.snapGrid.length === 1;\n\t\t}\n\t\tif (params.allowSlideNext === true) {\n\t\t\tswiper.allowSlideNext = !swiper.isLocked;\n\t\t}\n\t\tif (params.allowSlidePrev === true) {\n\t\t\tswiper.allowSlidePrev = !swiper.isLocked;\n\t\t}\n\t\tif (wasLocked && wasLocked !== swiper.isLocked) {\n\t\t\tswiper.isEnd = false;\n\t\t}\n\t\tif (wasLocked !== swiper.isLocked) {\n\t\t\tswiper.emit(swiper.isLocked ? 'lock' : 'unlock');\n\t\t}\n\t}\n\tvar checkOverflow$1 = {\n\t\tcheckOverflow\n\t};\n\n\tvar defaults = {\n\t\tinit: true,\n\t\tdirection: 'horizontal',\n\t\toneWayMovement: false,\n\t\tswiperElementNodeName: 'SWIPER-CONTAINER',\n\t\ttouchEventsTarget: 'wrapper',\n\t\tinitialSlide: 0,\n\t\tspeed: 300,\n\t\tcssMode: false,\n\t\tupdateOnWindowResize: true,\n\t\tresizeObserver: true,\n\t\tnested: false,\n\t\tcreateElements: false,\n\t\teventsPrefix: 'swiper',\n\t\tenabled: true,\n\t\tfocusableElements: 'input, select, option, textarea, button, video, label',\n\t\t// Overrides\n\t\twidth: null,\n\t\theight: null,\n\t\t//\n\t\tpreventInteractionOnTransition: false,\n\t\t// ssr\n\t\tuserAgent: null,\n\t\turl: null,\n\t\t// To support iOS's swipe-to-go-back gesture (when being used in-app).\n\t\tedgeSwipeDetection: false,\n\t\tedgeSwipeThreshold: 20,\n\t\t// Autoheight\n\t\tautoHeight: false,\n\t\t// Set wrapper width\n\t\tsetWrapperSize: false,\n\t\t// Virtual Translate\n\t\tvirtualTranslate: false,\n\t\t// Effects\n\t\teffect: 'slide',\n\t\t// 'slide' or 'fade' or 'cube' or 'coverflow' or 'flip'\n\n\t\t// Breakpoints\n\t\tbreakpoints: undefined,\n\t\tbreakpointsBase: 'window',\n\t\t// Slides grid\n\t\tspaceBetween: 0,\n\t\tslidesPerView: 1,\n\t\tslidesPerGroup: 1,\n\t\tslidesPerGroupSkip: 0,\n\t\tslidesPerGroupAuto: false,\n\t\tcenteredSlides: false,\n\t\tcenteredSlidesBounds: false,\n\t\tslidesOffsetBefore: 0,\n\t\t// in px\n\t\tslidesOffsetAfter: 0,\n\t\t// in px\n\t\tnormalizeSlideIndex: true,\n\t\tcenterInsufficientSlides: false,\n\t\t// Disable swiper and hide navigation when container not overflow\n\t\twatchOverflow: true,\n\t\t// Round length\n\t\troundLengths: false,\n\t\t// Touches\n\t\ttouchRatio: 1,\n\t\ttouchAngle: 45,\n\t\tsimulateTouch: true,\n\t\tshortSwipes: true,\n\t\tlongSwipes: true,\n\t\tlongSwipesRatio: 0.5,\n\t\tlongSwipesMs: 300,\n\t\tfollowFinger: true,\n\t\tallowTouchMove: true,\n\t\tthreshold: 5,\n\t\ttouchMoveStopPropagation: false,\n\t\ttouchStartPreventDefault: true,\n\t\ttouchStartForcePreventDefault: false,\n\t\ttouchReleaseOnEdges: false,\n\t\t// Unique Navigation Elements\n\t\tuniqueNavElements: true,\n\t\t// Resistance\n\t\tresistance: true,\n\t\tresistanceRatio: 0.85,\n\t\t// Progress\n\t\twatchSlidesProgress: false,\n\t\t// Cursor\n\t\tgrabCursor: false,\n\t\t// Clicks\n\t\tpreventClicks: true,\n\t\tpreventClicksPropagation: true,\n\t\tslideToClickedSlide: false,\n\t\t// loop\n\t\tloop: false,\n\t\tloopAddBlankSlides: true,\n\t\tloopAdditionalSlides: 0,\n\t\tloopPreventsSliding: true,\n\t\t// rewind\n\t\trewind: false,\n\t\t// Swiping/no swiping\n\t\tallowSlidePrev: true,\n\t\tallowSlideNext: true,\n\t\tswipeHandler: null,\n\t\t// '.swipe-handler',\n\t\tnoSwiping: true,\n\t\tnoSwipingClass: 'swiper-no-swiping',\n\t\tnoSwipingSelector: null,\n\t\t// Passive Listeners\n\t\tpassiveListeners: true,\n\t\tmaxBackfaceHiddenSlides: 10,\n\t\t// NS\n\t\tcontainerModifierClass: 'swiper-',\n\t\t// NEW\n\t\tslideClass: 'swiper-slide',\n\t\tslideBlankClass: 'swiper-slide-blank',\n\t\tslideActiveClass: 'swiper-slide-active',\n\t\tslideVisibleClass: 'swiper-slide-visible',\n\t\tslideFullyVisibleClass: 'swiper-slide-fully-visible',\n\t\tslideNextClass: 'swiper-slide-next',\n\t\tslidePrevClass: 'swiper-slide-prev',\n\t\twrapperClass: 'swiper-wrapper',\n\t\tlazyPreloaderClass: 'swiper-lazy-preloader',\n\t\tlazyPreloadPrevNext: 0,\n\t\t// Callbacks\n\t\trunCallbacksOnInit: true,\n\t\t// Internals\n\t\t_emitClasses: false\n\t};\n\n\tfunction moduleExtendParams(params, allModulesParams) {\n\t\treturn function extendParams(obj) {\n\t\t\tif (obj === void 0) {\n\t\t\t\tobj = {};\n\t\t\t}\n\t\t\tconst moduleParamName = Object.keys(obj)[0];\n\t\t\tconst moduleParams = obj[moduleParamName];\n\t\t\tif (typeof moduleParams !== 'object' || moduleParams === null) {\n\t\t\t\textend(allModulesParams, obj);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (params[moduleParamName] === true) {\n\t\t\t\tparams[moduleParamName] = {\n\t\t\t\t\tenabled: true\n\t\t\t\t};\n\t\t\t}\n\t\t\tif (moduleParamName === 'navigation' && params[moduleParamName] && params[moduleParamName].enabled && !params[moduleParamName].prevEl && !params[moduleParamName].nextEl) {\n\t\t\t\tparams[moduleParamName].auto = true;\n\t\t\t}\n\t\t\tif (['pagination', 'scrollbar'].indexOf(moduleParamName) >= 0 && params[moduleParamName] && params[moduleParamName].enabled && !params[moduleParamName].el) {\n\t\t\t\tparams[moduleParamName].auto = true;\n\t\t\t}\n\t\t\tif (!(moduleParamName in params && 'enabled' in moduleParams)) {\n\t\t\t\textend(allModulesParams, obj);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (typeof params[moduleParamName] === 'object' && !('enabled' in params[moduleParamName])) {\n\t\t\t\tparams[moduleParamName].enabled = true;\n\t\t\t}\n\t\t\tif (!params[moduleParamName]) params[moduleParamName] = {\n\t\t\t\tenabled: false\n\t\t\t};\n\t\t\textend(allModulesParams, obj);\n\t\t};\n\t}\n\n\t/* eslint no-param-reassign: \"off\" */\n\tconst prototypes = {\n\t\teventsEmitter,\n\t\tupdate,\n\t\ttranslate,\n\t\ttransition,\n\t\tslide,\n\t\tloop,\n\t\tgrabCursor,\n\t\tevents: events$1,\n\t\tbreakpoints,\n\t\tcheckOverflow: checkOverflow$1,\n\t\tclasses\n\t};\n\tconst extendedDefaults = {};\n\tclass Swiper {\n\t\tconstructor() {\n\t\t\tlet el;\n\t\t\tlet params;\n\t\t\tfor (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n\t\t\t\targs[_key] = arguments[_key];\n\t\t\t}\n\t\t\tif (args.length === 1 && args[0].constructor && Object.prototype.toString.call(args[0]).slice(8, -1) === 'Object') {\n\t\t\t\tparams = args[0];\n\t\t\t} else {\n\t\t\t\t[el, params] = args;\n\t\t\t}\n\t\t\tif (!params) params = {};\n\t\t\tparams = extend({}, params);\n\t\t\tif (el && !params.el) params.el = el;\n\t\t\tconst document = getDocument();\n\t\t\tif (params.el && typeof params.el === 'string' && document.querySelectorAll(params.el).length > 1) {\n\t\t\t\tconst swipers = [];\n\t\t\t\tdocument.querySelectorAll(params.el).forEach(containerEl => {\n\t\t\t\t\tconst newParams = extend({}, params, {\n\t\t\t\t\t\tel: containerEl\n\t\t\t\t\t});\n\t\t\t\t\tswipers.push(new Swiper(newParams));\n\t\t\t\t});\n\t\t\t\t// eslint-disable-next-line no-constructor-return\n\t\t\t\treturn swipers;\n\t\t\t}\n\n\t\t\t// Swiper Instance\n\t\t\tconst swiper = this;\n\t\t\tswiper.__swiper__ = true;\n\t\t\tswiper.support = getSupport();\n\t\t\tswiper.device = getDevice({\n\t\t\t\tuserAgent: params.userAgent\n\t\t\t});\n\t\t\tswiper.browser = getBrowser();\n\t\t\tswiper.eventsListeners = {};\n\t\t\tswiper.eventsAnyListeners = [];\n\t\t\tswiper.modules = [...swiper.__modules__];\n\t\t\tif (params.modules && Array.isArray(params.modules)) {\n\t\t\t\tswiper.modules.push(...params.modules);\n\t\t\t}\n\t\t\tconst allModulesParams = {};\n\t\t\tswiper.modules.forEach(mod => {\n\t\t\t\tmod({\n\t\t\t\t\tparams,\n\t\t\t\t\tswiper,\n\t\t\t\t\textendParams: moduleExtendParams(params, allModulesParams),\n\t\t\t\t\ton: swiper.on.bind(swiper),\n\t\t\t\t\tonce: swiper.once.bind(swiper),\n\t\t\t\t\toff: swiper.off.bind(swiper),\n\t\t\t\t\temit: swiper.emit.bind(swiper)\n\t\t\t\t});\n\t\t\t});\n\n\t\t\t// Extend defaults with modules params\n\t\t\tconst swiperParams = extend({}, defaults, allModulesParams);\n\n\t\t\t// Extend defaults with passed params\n\t\t\tswiper.params = extend({}, swiperParams, extendedDefaults, params);\n\t\t\tswiper.originalParams = extend({}, swiper.params);\n\t\t\tswiper.passedParams = extend({}, params);\n\n\t\t\t// add event listeners\n\t\t\tif (swiper.params && swiper.params.on) {\n\t\t\t\tObject.keys(swiper.params.on).forEach(eventName => {\n\t\t\t\t\tswiper.on(eventName, swiper.params.on[eventName]);\n\t\t\t\t});\n\t\t\t}\n\t\t\tif (swiper.params && swiper.params.onAny) {\n\t\t\t\tswiper.onAny(swiper.params.onAny);\n\t\t\t}\n\n\t\t\t// Extend Swiper\n\t\t\tObject.assign(swiper, {\n\t\t\t\tenabled: swiper.params.enabled,\n\t\t\t\tel,\n\t\t\t\t// Classes\n\t\t\t\tclassNames: [],\n\t\t\t\t// Slides\n\t\t\t\tslides: [],\n\t\t\t\tslidesGrid: [],\n\t\t\t\tsnapGrid: [],\n\t\t\t\tslidesSizesGrid: [],\n\t\t\t\t// isDirection\n\t\t\t\tisHorizontal() {\n\t\t\t\t\treturn swiper.params.direction === 'horizontal';\n\t\t\t\t},\n\t\t\t\tisVertical() {\n\t\t\t\t\treturn swiper.params.direction === 'vertical';\n\t\t\t\t},\n\t\t\t\t// Indexes\n\t\t\t\tactiveIndex: 0,\n\t\t\t\trealIndex: 0,\n\t\t\t\t//\n\t\t\t\tisBeginning: true,\n\t\t\t\tisEnd: false,\n\t\t\t\t// Props\n\t\t\t\ttranslate: 0,\n\t\t\t\tpreviousTranslate: 0,\n\t\t\t\tprogress: 0,\n\t\t\t\tvelocity: 0,\n\t\t\t\tanimating: false,\n\t\t\t\tcssOverflowAdjustment() {\n\t\t\t\t\t// Returns 0 unless `translate` is > 2**23\n\t\t\t\t\t// Should be subtracted from css values to prevent overflow\n\t\t\t\t\treturn Math.trunc(this.translate / 2 ** 23) * 2 ** 23;\n\t\t\t\t},\n\t\t\t\t// Locks\n\t\t\t\tallowSlideNext: swiper.params.allowSlideNext,\n\t\t\t\tallowSlidePrev: swiper.params.allowSlidePrev,\n\t\t\t\t// Touch Events\n\t\t\t\ttouchEventsData: {\n\t\t\t\t\tisTouched: undefined,\n\t\t\t\t\tisMoved: undefined,\n\t\t\t\t\tallowTouchCallbacks: undefined,\n\t\t\t\t\ttouchStartTime: undefined,\n\t\t\t\t\tisScrolling: undefined,\n\t\t\t\t\tcurrentTranslate: undefined,\n\t\t\t\t\tstartTranslate: undefined,\n\t\t\t\t\tallowThresholdMove: undefined,\n\t\t\t\t\t// Form elements to match\n\t\t\t\t\tfocusableElements: swiper.params.focusableElements,\n\t\t\t\t\t// Last click time\n\t\t\t\t\tlastClickTime: 0,\n\t\t\t\t\tclickTimeout: undefined,\n\t\t\t\t\t// Velocities\n\t\t\t\t\tvelocities: [],\n\t\t\t\t\tallowMomentumBounce: undefined,\n\t\t\t\t\tstartMoving: undefined,\n\t\t\t\t\tpointerId: null,\n\t\t\t\t\ttouchId: null\n\t\t\t\t},\n\t\t\t\t// Clicks\n\t\t\t\tallowClick: true,\n\t\t\t\t// Touches\n\t\t\t\tallowTouchMove: swiper.params.allowTouchMove,\n\t\t\t\ttouches: {\n\t\t\t\t\tstartX: 0,\n\t\t\t\t\tstartY: 0,\n\t\t\t\t\tcurrentX: 0,\n\t\t\t\t\tcurrentY: 0,\n\t\t\t\t\tdiff: 0\n\t\t\t\t},\n\t\t\t\t// Images\n\t\t\t\timagesToLoad: [],\n\t\t\t\timagesLoaded: 0\n\t\t\t});\n\t\t\tswiper.emit('_swiper');\n\n\t\t\t// Init\n\t\t\tif (swiper.params.init) {\n\t\t\t\tswiper.init();\n\t\t\t}\n\n\t\t\t// Return app instance\n\t\t\t// eslint-disable-next-line no-constructor-return\n\t\t\treturn swiper;\n\t\t}\n\t\tgetDirectionLabel(property) {\n\t\t\tif (this.isHorizontal()) {\n\t\t\t\treturn property;\n\t\t\t}\n\t\t\t// prettier-ignore\n\t\t\treturn {\n\t\t\t\t'width': 'height',\n\t\t\t\t'margin-top': 'margin-left',\n\t\t\t\t'margin-bottom ': 'margin-right',\n\t\t\t\t'margin-left': 'margin-top',\n\t\t\t\t'margin-right': 'margin-bottom',\n\t\t\t\t'padding-left': 'padding-top',\n\t\t\t\t'padding-right': 'padding-bottom',\n\t\t\t\t'marginRight': 'marginBottom'\n\t\t\t}[property];\n\t\t}\n\t\tgetSlideIndex(slideEl) {\n\t\t\tconst {\n\t\t\t\tslidesEl,\n\t\t\t\tparams\n\t\t\t} = this;\n\t\t\tconst slides = elementChildren(slidesEl, `.${params.slideClass}, swiper-slide`);\n\t\t\tconst firstSlideIndex = elementIndex(slides[0]);\n\t\t\treturn elementIndex(slideEl) - firstSlideIndex;\n\t\t}\n\t\tgetSlideIndexByData(index) {\n\t\t\treturn this.getSlideIndex(this.slides.filter(slideEl => slideEl.getAttribute('data-swiper-slide-index') * 1 === index)[0]);\n\t\t}\n\t\trecalcSlides() {\n\t\t\tconst swiper = this;\n\t\t\tconst {\n\t\t\t\tslidesEl,\n\t\t\t\tparams\n\t\t\t} = swiper;\n\t\t\tswiper.slides = elementChildren(slidesEl, `.${params.slideClass}, swiper-slide`);\n\t\t}\n\t\tenable() {\n\t\t\tconst swiper = this;\n\t\t\tif (swiper.enabled) return;\n\t\t\tswiper.enabled = true;\n\t\t\tif (swiper.params.grabCursor) {\n\t\t\t\tswiper.setGrabCursor();\n\t\t\t}\n\t\t\tswiper.emit('enable');\n\t\t}\n\t\tdisable() {\n\t\t\tconst swiper = this;\n\t\t\tif (!swiper.enabled) return;\n\t\t\tswiper.enabled = false;\n\t\t\tif (swiper.params.grabCursor) {\n\t\t\t\tswiper.unsetGrabCursor();\n\t\t\t}\n\t\t\tswiper.emit('disable');\n\t\t}\n\t\tsetProgress(progress, speed) {\n\t\t\tconst swiper = this;\n\t\t\tprogress = Math.min(Math.max(progress, 0), 1);\n\t\t\tconst min = swiper.minTranslate();\n\t\t\tconst max = swiper.maxTranslate();\n\t\t\tconst current = (max - min) * progress + min;\n\t\t\tswiper.translateTo(current, typeof speed === 'undefined' ? 0 : speed);\n\t\t\tswiper.updateActiveIndex();\n\t\t\tswiper.updateSlidesClasses();\n\t\t}\n\t\temitContainerClasses() {\n\t\t\tconst swiper = this;\n\t\t\tif (!swiper.params._emitClasses || !swiper.el) return;\n\t\t\tconst cls = swiper.el.className.split(' ').filter(className => {\n\t\t\t\treturn className.indexOf('swiper') === 0 || className.indexOf(swiper.params.containerModifierClass) === 0;\n\t\t\t});\n\t\t\tswiper.emit('_containerClasses', cls.join(' '));\n\t\t}\n\t\tgetSlideClasses(slideEl) {\n\t\t\tconst swiper = this;\n\t\t\tif (swiper.destroyed) return '';\n\t\t\treturn slideEl.className.split(' ').filter(className => {\n\t\t\t\treturn className.indexOf('swiper-slide') === 0 || className.indexOf(swiper.params.slideClass) === 0;\n\t\t\t}).join(' ');\n\t\t}\n\t\temitSlidesClasses() {\n\t\t\tconst swiper = this;\n\t\t\tif (!swiper.params._emitClasses || !swiper.el) return;\n\t\t\tconst updates = [];\n\t\t\tswiper.slides.forEach(slideEl => {\n\t\t\t\tconst classNames = swiper.getSlideClasses(slideEl);\n\t\t\t\tupdates.push({\n\t\t\t\t\tslideEl,\n\t\t\t\t\tclassNames\n\t\t\t\t});\n\t\t\t\tswiper.emit('_slideClass', slideEl, classNames);\n\t\t\t});\n\t\t\tswiper.emit('_slideClasses', updates);\n\t\t}\n\t\tslidesPerViewDynamic(view, exact) {\n\t\t\tif (view === void 0) {\n\t\t\t\tview = 'current';\n\t\t\t}\n\t\t\tif (exact === void 0) {\n\t\t\t\texact = false;\n\t\t\t}\n\t\t\tconst swiper = this;\n\t\t\tconst {\n\t\t\t\tparams,\n\t\t\t\tslides,\n\t\t\t\tslidesGrid,\n\t\t\t\tslidesSizesGrid,\n\t\t\t\tsize: swiperSize,\n\t\t\t\tactiveIndex\n\t\t\t} = swiper;\n\t\t\tlet spv = 1;\n\t\t\tif (typeof params.slidesPerView === 'number') return params.slidesPerView;\n\t\t\tif (params.centeredSlides) {\n\t\t\t\tlet slideSize = slides[activeIndex] ? Math.ceil(slides[activeIndex].swiperSlideSize) : 0;\n\t\t\t\tlet breakLoop;\n\t\t\t\tfor (let i = activeIndex + 1; i < slides.length; i += 1) {\n\t\t\t\t\tif (slides[i] && !breakLoop) {\n\t\t\t\t\t\tslideSize += Math.ceil(slides[i].swiperSlideSize);\n\t\t\t\t\t\tspv += 1;\n\t\t\t\t\t\tif (slideSize > swiperSize) breakLoop = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (let i = activeIndex - 1; i >= 0; i -= 1) {\n\t\t\t\t\tif (slides[i] && !breakLoop) {\n\t\t\t\t\t\tslideSize += slides[i].swiperSlideSize;\n\t\t\t\t\t\tspv += 1;\n\t\t\t\t\t\tif (slideSize > swiperSize) breakLoop = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// eslint-disable-next-line\n\t\t\t\tif (view === 'current') {\n\t\t\t\t\tfor (let i = activeIndex + 1; i < slides.length; i += 1) {\n\t\t\t\t\t\tconst slideInView = exact ? slidesGrid[i] + slidesSizesGrid[i] - slidesGrid[activeIndex] < swiperSize : slidesGrid[i] - slidesGrid[activeIndex] < swiperSize;\n\t\t\t\t\t\tif (slideInView) {\n\t\t\t\t\t\t\tspv += 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// previous\n\t\t\t\t\tfor (let i = activeIndex - 1; i >= 0; i -= 1) {\n\t\t\t\t\t\tconst slideInView = slidesGrid[activeIndex] - slidesGrid[i] < swiperSize;\n\t\t\t\t\t\tif (slideInView) {\n\t\t\t\t\t\t\tspv += 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn spv;\n\t\t}\n\t\tupdate() {\n\t\t\tconst swiper = this;\n\t\t\tif (!swiper || swiper.destroyed) return;\n\t\t\tconst {\n\t\t\t\tsnapGrid,\n\t\t\t\tparams\n\t\t\t} = swiper;\n\t\t\t// Breakpoints\n\t\t\tif (params.breakpoints) {\n\t\t\t\tswiper.setBreakpoint();\n\t\t\t}\n\t\t\t[...swiper.el.querySelectorAll('[loading=\"lazy\"]')].forEach(imageEl => {\n\t\t\t\tif (imageEl.complete) {\n\t\t\t\t\tprocessLazyPreloader(swiper, imageEl);\n\t\t\t\t}\n\t\t\t});\n\t\t\tswiper.updateSize();\n\t\t\tswiper.updateSlides();\n\t\t\tswiper.updateProgress();\n\t\t\tswiper.updateSlidesClasses();\n\t\t\tfunction setTranslate() {\n\t\t\t\tconst translateValue = swiper.rtlTranslate ? swiper.translate * -1 : swiper.translate;\n\t\t\t\tconst newTranslate = Math.min(Math.max(translateValue, swiper.maxTranslate()), swiper.minTranslate());\n\t\t\t\tswiper.setTranslate(newTranslate);\n\t\t\t\tswiper.updateActiveIndex();\n\t\t\t\tswiper.updateSlidesClasses();\n\t\t\t}\n\t\t\tlet translated;\n\t\t\tif (params.freeMode && params.freeMode.enabled && !params.cssMode) {\n\t\t\t\tsetTranslate();\n\t\t\t\tif (params.autoHeight) {\n\t\t\t\t\tswiper.updateAutoHeight();\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif ((params.slidesPerView === 'auto' || params.slidesPerView > 1) && swiper.isEnd && !params.centeredSlides) {\n\t\t\t\t\tconst slides = swiper.virtual && params.virtual.enabled ? swiper.virtual.slides : swiper.slides;\n\t\t\t\t\ttranslated = swiper.slideTo(slides.length - 1, 0, false, true);\n\t\t\t\t} else {\n\t\t\t\t\ttranslated = swiper.slideTo(swiper.activeIndex, 0, false, true);\n\t\t\t\t}\n\t\t\t\tif (!translated) {\n\t\t\t\t\tsetTranslate();\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (params.watchOverflow && snapGrid !== swiper.snapGrid) {\n\t\t\t\tswiper.checkOverflow();\n\t\t\t}\n\t\t\tswiper.emit('update');\n\t\t}\n\t\tchangeDirection(newDirection, needUpdate) {\n\t\t\tif (needUpdate === void 0) {\n\t\t\t\tneedUpdate = true;\n\t\t\t}\n\t\t\tconst swiper = this;\n\t\t\tconst currentDirection = swiper.params.direction;\n\t\t\tif (!newDirection) {\n\t\t\t\t// eslint-disable-next-line\n\t\t\t\tnewDirection = currentDirection === 'horizontal' ? 'vertical' : 'horizontal';\n\t\t\t}\n\t\t\tif (newDirection === currentDirection || newDirection !== 'horizontal' && newDirection !== 'vertical') {\n\t\t\t\treturn swiper;\n\t\t\t}\n\t\t\tswiper.el.classList.remove(`${swiper.params.containerModifierClass}${currentDirection}`);\n\t\t\tswiper.el.classList.add(`${swiper.params.containerModifierClass}${newDirection}`);\n\t\t\tswiper.emitContainerClasses();\n\t\t\tswiper.params.direction = newDirection;\n\t\t\tswiper.slides.forEach(slideEl => {\n\t\t\t\tif (newDirection === 'vertical') {\n\t\t\t\t\tslideEl.style.width = '';\n\t\t\t\t} else {\n\t\t\t\t\tslideEl.style.height = '';\n\t\t\t\t}\n\t\t\t});\n\t\t\tswiper.emit('changeDirection');\n\t\t\tif (needUpdate) swiper.update();\n\t\t\treturn swiper;\n\t\t}\n\t\tchangeLanguageDirection(direction) {\n\t\t\tconst swiper = this;\n\t\t\tif (swiper.rtl && direction === 'rtl' || !swiper.rtl && direction === 'ltr') return;\n\t\t\tswiper.rtl = direction === 'rtl';\n\t\t\tswiper.rtlTranslate = swiper.params.direction === 'horizontal' && swiper.rtl;\n\t\t\tif (swiper.rtl) {\n\t\t\t\tswiper.el.classList.add(`${swiper.params.containerModifierClass}rtl`);\n\t\t\t\tswiper.el.dir = 'rtl';\n\t\t\t} else {\n\t\t\t\tswiper.el.classList.remove(`${swiper.params.containerModifierClass}rtl`);\n\t\t\t\tswiper.el.dir = 'ltr';\n\t\t\t}\n\t\t\tswiper.update();\n\t\t}\n\t\tmount(element) {\n\t\t\tconst swiper = this;\n\t\t\tif (swiper.mounted) return true;\n\n\t\t\t// Find el\n\t\t\tlet el = element || swiper.params.el;\n\t\t\tif (typeof el === 'string') {\n\t\t\t\tel = document.querySelector(el);\n\t\t\t}\n\t\t\tif (!el) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tel.swiper = swiper;\n\t\t\tif (el.parentNode && el.parentNode.host && el.parentNode.host.nodeName === swiper.params.swiperElementNodeName.toUpperCase()) {\n\t\t\t\tswiper.isElement = true;\n\t\t\t}\n\t\t\tconst getWrapperSelector = () => {\n\t\t\t\treturn `.${(swiper.params.wrapperClass || '').trim().split(' ').join('.')}`;\n\t\t\t};\n\t\t\tconst getWrapper = () => {\n\t\t\t\tif (el && el.shadowRoot && el.shadowRoot.querySelector) {\n\t\t\t\t\tconst res = el.shadowRoot.querySelector(getWrapperSelector());\n\t\t\t\t\t// Children needs to return slot items\n\t\t\t\t\treturn res;\n\t\t\t\t}\n\t\t\t\treturn elementChildren(el, getWrapperSelector())[0];\n\t\t\t};\n\t\t\t// Find Wrapper\n\t\t\tlet wrapperEl = getWrapper();\n\t\t\tif (!wrapperEl && swiper.params.createElements) {\n\t\t\t\twrapperEl = createElement('div', swiper.params.wrapperClass);\n\t\t\t\tel.append(wrapperEl);\n\t\t\t\telementChildren(el, `.${swiper.params.slideClass}`).forEach(slideEl => {\n\t\t\t\t\twrapperEl.append(slideEl);\n\t\t\t\t});\n\t\t\t}\n\t\t\tObject.assign(swiper, {\n\t\t\t\tel,\n\t\t\t\twrapperEl,\n\t\t\t\tslidesEl: swiper.isElement && !el.parentNode.host.slideSlots ? el.parentNode.host : wrapperEl,\n\t\t\t\thostEl: swiper.isElement ? el.parentNode.host : el,\n\t\t\t\tmounted: true,\n\t\t\t\t// RTL\n\t\t\t\trtl: el.dir.toLowerCase() === 'rtl' || elementStyle(el, 'direction') === 'rtl',\n\t\t\t\trtlTranslate: swiper.params.direction === 'horizontal' && (el.dir.toLowerCase() === 'rtl' || elementStyle(el, 'direction') === 'rtl'),\n\t\t\t\twrongRTL: elementStyle(wrapperEl, 'display') === '-webkit-box'\n\t\t\t});\n\t\t\treturn true;\n\t\t}\n\t\tinit(el) {\n\t\t\tconst swiper = this;\n\t\t\tif (swiper.initialized) return swiper;\n\t\t\tconst mounted = swiper.mount(el);\n\t\t\tif (mounted === false) return swiper;\n\t\t\tswiper.emit('beforeInit');\n\n\t\t\t// Set breakpoint\n\t\t\tif (swiper.params.breakpoints) {\n\t\t\t\tswiper.setBreakpoint();\n\t\t\t}\n\n\t\t\t// Add Classes\n\t\t\tswiper.addClasses();\n\n\t\t\t// Update size\n\t\t\tswiper.updateSize();\n\n\t\t\t// Update slides\n\t\t\tswiper.updateSlides();\n\t\t\tif (swiper.params.watchOverflow) {\n\t\t\t\tswiper.checkOverflow();\n\t\t\t}\n\n\t\t\t// Set Grab Cursor\n\t\t\tif (swiper.params.grabCursor && swiper.enabled) {\n\t\t\t\tswiper.setGrabCursor();\n\t\t\t}\n\n\t\t\t// Slide To Initial Slide\n\t\t\tif (swiper.params.loop && swiper.virtual && swiper.params.virtual.enabled) {\n\t\t\t\tswiper.slideTo(swiper.params.initialSlide + swiper.virtual.slidesBefore, 0, swiper.params.runCallbacksOnInit, false, true);\n\t\t\t} else {\n\t\t\t\tswiper.slideTo(swiper.params.initialSlide, 0, swiper.params.runCallbacksOnInit, false, true);\n\t\t\t}\n\n\t\t\t// Create loop\n\t\t\tif (swiper.params.loop) {\n\t\t\t\tswiper.loopCreate();\n\t\t\t}\n\n\t\t\t// Attach events\n\t\t\tswiper.attachEvents();\n\t\t\tconst lazyElements = [...swiper.el.querySelectorAll('[loading=\"lazy\"]')];\n\t\t\tif (swiper.isElement) {\n\t\t\t\tlazyElements.push(...swiper.hostEl.querySelectorAll('[loading=\"lazy\"]'));\n\t\t\t}\n\t\t\tlazyElements.forEach(imageEl => {\n\t\t\t\tif (imageEl.complete) {\n\t\t\t\t\tprocessLazyPreloader(swiper, imageEl);\n\t\t\t\t} else {\n\t\t\t\t\timageEl.addEventListener('load', e => {\n\t\t\t\t\t\tprocessLazyPreloader(swiper, e.target);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\t\t\tpreload(swiper);\n\n\t\t\t// Init Flag\n\t\t\tswiper.initialized = true;\n\t\t\tpreload(swiper);\n\n\t\t\t// Emit\n\t\t\tswiper.emit('init');\n\t\t\tswiper.emit('afterInit');\n\t\t\treturn swiper;\n\t\t}\n\t\tdestroy(deleteInstance, cleanStyles) {\n\t\t\tif (deleteInstance === void 0) {\n\t\t\t\tdeleteInstance = true;\n\t\t\t}\n\t\t\tif (cleanStyles === void 0) {\n\t\t\t\tcleanStyles = true;\n\t\t\t}\n\t\t\tconst swiper = this;\n\t\t\tconst {\n\t\t\t\tparams,\n\t\t\t\tel,\n\t\t\t\twrapperEl,\n\t\t\t\tslides\n\t\t\t} = swiper;\n\t\t\tif (typeof swiper.params === 'undefined' || swiper.destroyed) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tswiper.emit('beforeDestroy');\n\n\t\t\t// Init Flag\n\t\t\tswiper.initialized = false;\n\n\t\t\t// Detach events\n\t\t\tswiper.detachEvents();\n\n\t\t\t// Destroy loop\n\t\t\tif (params.loop) {\n\t\t\t\tswiper.loopDestroy();\n\t\t\t}\n\n\t\t\t// Cleanup styles\n\t\t\tif (cleanStyles) {\n\t\t\t\tswiper.removeClasses();\n\t\t\t\tif (el && typeof el !== 'string') {\n\t\t\t\t\tel.removeAttribute('style');\n\t\t\t\t}\n\t\t\t\tif (wrapperEl) {\n\t\t\t\t\twrapperEl.removeAttribute('style');\n\t\t\t\t}\n\t\t\t\tif (slides && slides.length) {\n\t\t\t\t\tslides.forEach(slideEl => {\n\t\t\t\t\t\tslideEl.classList.remove(params.slideVisibleClass, params.slideFullyVisibleClass, params.slideActiveClass, params.slideNextClass, params.slidePrevClass);\n\t\t\t\t\t\tslideEl.removeAttribute('style');\n\t\t\t\t\t\tslideEl.removeAttribute('data-swiper-slide-index');\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t\tswiper.emit('destroy');\n\n\t\t\t// Detach emitter events\n\t\t\tObject.keys(swiper.eventsListeners).forEach(eventName => {\n\t\t\t\tswiper.off(eventName);\n\t\t\t});\n\t\t\tif (deleteInstance !== false) {\n\t\t\t\tif (swiper.el && typeof swiper.el !== 'string') {\n\t\t\t\t\tswiper.el.swiper = null;\n\t\t\t\t}\n\t\t\t\tdeleteProps(swiper);\n\t\t\t}\n\t\t\tswiper.destroyed = true;\n\t\t\treturn null;\n\t\t}\n\t\tstatic extendDefaults(newDefaults) {\n\t\t\textend(extendedDefaults, newDefaults);\n\t\t}\n\t\tstatic get extendedDefaults() {\n\t\t\treturn extendedDefaults;\n\t\t}\n\t\tstatic get defaults() {\n\t\t\treturn defaults;\n\t\t}\n\t\tstatic installModule(mod) {\n\t\t\tif (!Swiper.prototype.__modules__) Swiper.prototype.__modules__ = [];\n\t\t\tconst modules = Swiper.prototype.__modules__;\n\t\t\tif (typeof mod === 'function' && modules.indexOf(mod) < 0) {\n\t\t\t\tmodules.push(mod);\n\t\t\t}\n\t\t}\n\t\tstatic use(module) {\n\t\t\tif (Array.isArray(module)) {\n\t\t\t\tmodule.forEach(m => Swiper.installModule(m));\n\t\t\t\treturn Swiper;\n\t\t\t}\n\t\t\tSwiper.installModule(module);\n\t\t\treturn Swiper;\n\t\t}\n\t}\n\tObject.keys(prototypes).forEach(prototypeGroup => {\n\t\tObject.keys(prototypes[prototypeGroup]).forEach(protoMethod => {\n\t\t\tSwiper.prototype[protoMethod] = prototypes[prototypeGroup][protoMethod];\n\t\t});\n\t});\n\tSwiper.use([Resize, Observer]);\n\n\tfunction Virtual(_ref) {\n\t\tlet {\n\t\t\tswiper,\n\t\t\textendParams,\n\t\t\ton,\n\t\t\temit\n\t\t} = _ref;\n\t\textendParams({\n\t\t\tvirtual: {\n\t\t\t\tenabled: false,\n\t\t\t\tslides: [],\n\t\t\t\tcache: true,\n\t\t\t\trenderSlide: null,\n\t\t\t\trenderExternal: null,\n\t\t\t\trenderExternalUpdate: true,\n\t\t\t\taddSlidesBefore: 0,\n\t\t\t\taddSlidesAfter: 0\n\t\t\t}\n\t\t});\n\t\tlet cssModeTimeout;\n\t\tconst document = getDocument();\n\t\tswiper.virtual = {\n\t\t\tcache: {},\n\t\t\tfrom: undefined,\n\t\t\tto: undefined,\n\t\t\tslides: [],\n\t\t\toffset: 0,\n\t\t\tslidesGrid: []\n\t\t};\n\t\tconst tempDOM = document.createElement('div');\n\t\tfunction renderSlide(slide, index) {\n\t\t\tconst params = swiper.params.virtual;\n\t\t\tif (params.cache && swiper.virtual.cache[index]) {\n\t\t\t\treturn swiper.virtual.cache[index];\n\t\t\t}\n\t\t\t// eslint-disable-next-line\n\t\t\tlet slideEl;\n\t\t\tif (params.renderSlide) {\n\t\t\t\tslideEl = params.renderSlide.call(swiper, slide, index);\n\t\t\t\tif (typeof slideEl === 'string') {\n\t\t\t\t\ttempDOM.innerHTML = slideEl;\n\t\t\t\t\tslideEl = tempDOM.children[0];\n\t\t\t\t}\n\t\t\t} else if (swiper.isElement) {\n\t\t\t\tslideEl = createElement('swiper-slide');\n\t\t\t} else {\n\t\t\t\tslideEl = createElement('div', swiper.params.slideClass);\n\t\t\t}\n\t\t\tslideEl.setAttribute('data-swiper-slide-index', index);\n\t\t\tif (!params.renderSlide) {\n\t\t\t\tslideEl.innerHTML = slide;\n\t\t\t}\n\t\t\tif (params.cache) {\n\t\t\t\tswiper.virtual.cache[index] = slideEl;\n\t\t\t}\n\t\t\treturn slideEl;\n\t\t}\n\t\tfunction update(force, beforeInit) {\n\t\t\tconst {\n\t\t\t\tslidesPerView,\n\t\t\t\tslidesPerGroup,\n\t\t\t\tcenteredSlides,\n\t\t\t\tloop: isLoop,\n\t\t\t\tinitialSlide\n\t\t\t} = swiper.params;\n\t\t\tif (beforeInit && !isLoop && initialSlide > 0) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tconst {\n\t\t\t\taddSlidesBefore,\n\t\t\t\taddSlidesAfter\n\t\t\t} = swiper.params.virtual;\n\t\t\tconst {\n\t\t\t\tfrom: previousFrom,\n\t\t\t\tto: previousTo,\n\t\t\t\tslides,\n\t\t\t\tslidesGrid: previousSlidesGrid,\n\t\t\t\toffset: previousOffset\n\t\t\t} = swiper.virtual;\n\t\t\tif (!swiper.params.cssMode) {\n\t\t\t\tswiper.updateActiveIndex();\n\t\t\t}\n\t\t\tconst activeIndex = swiper.activeIndex || 0;\n\t\t\tlet offsetProp;\n\t\t\tif (swiper.rtlTranslate) offsetProp = 'right'; else offsetProp = swiper.isHorizontal() ? 'left' : 'top';\n\t\t\tlet slidesAfter;\n\t\t\tlet slidesBefore;\n\t\t\tif (centeredSlides) {\n\t\t\t\tslidesAfter = Math.floor(slidesPerView / 2) + slidesPerGroup + addSlidesAfter;\n\t\t\t\tslidesBefore = Math.floor(slidesPerView / 2) + slidesPerGroup + addSlidesBefore;\n\t\t\t} else {\n\t\t\t\tslidesAfter = slidesPerView + (slidesPerGroup - 1) + addSlidesAfter;\n\t\t\t\tslidesBefore = (isLoop ? slidesPerView : slidesPerGroup) + addSlidesBefore;\n\t\t\t}\n\t\t\tlet from = activeIndex - slidesBefore;\n\t\t\tlet to = activeIndex + slidesAfter;\n\t\t\tif (!isLoop) {\n\t\t\t\tfrom = Math.max(from, 0);\n\t\t\t\tto = Math.min(to, slides.length - 1);\n\t\t\t}\n\t\t\tlet offset = (swiper.slidesGrid[from] || 0) - (swiper.slidesGrid[0] || 0);\n\t\t\tif (isLoop && activeIndex >= slidesBefore) {\n\t\t\t\tfrom -= slidesBefore;\n\t\t\t\tif (!centeredSlides) offset += swiper.slidesGrid[0];\n\t\t\t} else if (isLoop && activeIndex < slidesBefore) {\n\t\t\t\tfrom = -slidesBefore;\n\t\t\t\tif (centeredSlides) offset += swiper.slidesGrid[0];\n\t\t\t}\n\t\t\tObject.assign(swiper.virtual, {\n\t\t\t\tfrom,\n\t\t\t\tto,\n\t\t\t\toffset,\n\t\t\t\tslidesGrid: swiper.slidesGrid,\n\t\t\t\tslidesBefore,\n\t\t\t\tslidesAfter\n\t\t\t});\n\t\t\tfunction onRendered() {\n\t\t\t\tswiper.updateSlides();\n\t\t\t\tswiper.updateProgress();\n\t\t\t\tswiper.updateSlidesClasses();\n\t\t\t\temit('virtualUpdate');\n\t\t\t}\n\t\t\tif (previousFrom === from && previousTo === to && !force) {\n\t\t\t\tif (swiper.slidesGrid !== previousSlidesGrid && offset !== previousOffset) {\n\t\t\t\t\tswiper.slides.forEach(slideEl => {\n\t\t\t\t\t\tslideEl.style[offsetProp] = `${offset - Math.abs(swiper.cssOverflowAdjustment())}px`;\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tswiper.updateProgress();\n\t\t\t\temit('virtualUpdate');\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (swiper.params.virtual.renderExternal) {\n\t\t\t\tswiper.params.virtual.renderExternal.call(swiper, {\n\t\t\t\t\toffset,\n\t\t\t\t\tfrom,\n\t\t\t\t\tto,\n\t\t\t\t\tslides: function getSlides() {\n\t\t\t\t\t\tconst slidesToRender = [];\n\t\t\t\t\t\tfor (let i = from; i <= to; i += 1) {\n\t\t\t\t\t\t\tslidesToRender.push(slides[i]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn slidesToRender;\n\t\t\t\t\t}()\n\t\t\t\t});\n\t\t\t\tif (swiper.params.virtual.renderExternalUpdate) {\n\t\t\t\t\tonRendered();\n\t\t\t\t} else {\n\t\t\t\t\temit('virtualUpdate');\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tconst prependIndexes = [];\n\t\t\tconst appendIndexes = [];\n\t\t\tconst getSlideIndex = index => {\n\t\t\t\tlet slideIndex = index;\n\t\t\t\tif (index < 0) {\n\t\t\t\t\tslideIndex = slides.length + index;\n\t\t\t\t} else if (slideIndex >= slides.length) {\n\t\t\t\t\t// eslint-disable-next-line\n\t\t\t\t\tslideIndex = slideIndex - slides.length;\n\t\t\t\t}\n\t\t\t\treturn slideIndex;\n\t\t\t};\n\t\t\tif (force) {\n\t\t\t\tswiper.slides.filter(el => el.matches(`.${swiper.params.slideClass}, swiper-slide`)).forEach(slideEl => {\n\t\t\t\t\tslideEl.remove();\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tfor (let i = previousFrom; i <= previousTo; i += 1) {\n\t\t\t\t\tif (i < from || i > to) {\n\t\t\t\t\t\tconst slideIndex = getSlideIndex(i);\n\t\t\t\t\t\tswiper.slides.filter(el => el.matches(`.${swiper.params.slideClass}[data-swiper-slide-index=\"${slideIndex}\"], swiper-slide[data-swiper-slide-index=\"${slideIndex}\"]`)).forEach(slideEl => {\n\t\t\t\t\t\t\tslideEl.remove();\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tconst loopFrom = isLoop ? -slides.length : 0;\n\t\t\tconst loopTo = isLoop ? slides.length * 2 : slides.length;\n\t\t\tfor (let i = loopFrom; i < loopTo; i += 1) {\n\t\t\t\tif (i >= from && i <= to) {\n\t\t\t\t\tconst slideIndex = getSlideIndex(i);\n\t\t\t\t\tif (typeof previousTo === 'undefined' || force) {\n\t\t\t\t\t\tappendIndexes.push(slideIndex);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (i > previousTo) appendIndexes.push(slideIndex);\n\t\t\t\t\t\tif (i < previousFrom) prependIndexes.push(slideIndex);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tappendIndexes.forEach(index => {\n\t\t\t\tswiper.slidesEl.append(renderSlide(slides[index], index));\n\t\t\t});\n\t\t\tif (isLoop) {\n\t\t\t\tfor (let i = prependIndexes.length - 1; i >= 0; i -= 1) {\n\t\t\t\t\tconst index = prependIndexes[i];\n\t\t\t\t\tswiper.slidesEl.prepend(renderSlide(slides[index], index));\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tprependIndexes.sort((a, b) => b - a);\n\t\t\t\tprependIndexes.forEach(index => {\n\t\t\t\t\tswiper.slidesEl.prepend(renderSlide(slides[index], index));\n\t\t\t\t});\n\t\t\t}\n\t\t\telementChildren(swiper.slidesEl, '.swiper-slide, swiper-slide').forEach(slideEl => {\n\t\t\t\tslideEl.style[offsetProp] = `${offset - Math.abs(swiper.cssOverflowAdjustment())}px`;\n\t\t\t});\n\t\t\tonRendered();\n\t\t}\n\t\tfunction appendSlide(slides) {\n\t\t\tif (typeof slides === 'object' && 'length' in slides) {\n\t\t\t\tfor (let i = 0; i < slides.length; i += 1) {\n\t\t\t\t\tif (slides[i]) swiper.virtual.slides.push(slides[i]);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tswiper.virtual.slides.push(slides);\n\t\t\t}\n\t\t\tupdate(true);\n\t\t}\n\t\tfunction prependSlide(slides) {\n\t\t\tconst activeIndex = swiper.activeIndex;\n\t\t\tlet newActiveIndex = activeIndex + 1;\n\t\t\tlet numberOfNewSlides = 1;\n\t\t\tif (Array.isArray(slides)) {\n\t\t\t\tfor (let i = 0; i < slides.length; i += 1) {\n\t\t\t\t\tif (slides[i]) swiper.virtual.slides.unshift(slides[i]);\n\t\t\t\t}\n\t\t\t\tnewActiveIndex = activeIndex + slides.length;\n\t\t\t\tnumberOfNewSlides = slides.length;\n\t\t\t} else {\n\t\t\t\tswiper.virtual.slides.unshift(slides);\n\t\t\t}\n\t\t\tif (swiper.params.virtual.cache) {\n\t\t\t\tconst cache = swiper.virtual.cache;\n\t\t\t\tconst newCache = {};\n\t\t\t\tObject.keys(cache).forEach(cachedIndex => {\n\t\t\t\t\tconst cachedEl = cache[cachedIndex];\n\t\t\t\t\tconst cachedElIndex = cachedEl.getAttribute('data-swiper-slide-index');\n\t\t\t\t\tif (cachedElIndex) {\n\t\t\t\t\t\tcachedEl.setAttribute('data-swiper-slide-index', parseInt(cachedElIndex, 10) + numberOfNewSlides);\n\t\t\t\t\t}\n\t\t\t\t\tnewCache[parseInt(cachedIndex, 10) + numberOfNewSlides] = cachedEl;\n\t\t\t\t});\n\t\t\t\tswiper.virtual.cache = newCache;\n\t\t\t}\n\t\t\tupdate(true);\n\t\t\tswiper.slideTo(newActiveIndex, 0);\n\t\t}\n\t\tfunction removeSlide(slidesIndexes) {\n\t\t\tif (typeof slidesIndexes === 'undefined' || slidesIndexes === null) return;\n\t\t\tlet activeIndex = swiper.activeIndex;\n\t\t\tif (Array.isArray(slidesIndexes)) {\n\t\t\t\tfor (let i = slidesIndexes.length - 1; i >= 0; i -= 1) {\n\t\t\t\t\tif (swiper.params.virtual.cache) {\n\t\t\t\t\t\tdelete swiper.virtual.cache[slidesIndexes[i]];\n\t\t\t\t\t\t// shift cache indexes\n\t\t\t\t\t\tObject.keys(swiper.virtual.cache).forEach(key => {\n\t\t\t\t\t\t\tif (key > slidesIndexes) {\n\t\t\t\t\t\t\t\tswiper.virtual.cache[key - 1] = swiper.virtual.cache[key];\n\t\t\t\t\t\t\t\tswiper.virtual.cache[key - 1].setAttribute('data-swiper-slide-index', key - 1);\n\t\t\t\t\t\t\t\tdelete swiper.virtual.cache[key];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\tswiper.virtual.slides.splice(slidesIndexes[i], 1);\n\t\t\t\t\tif (slidesIndexes[i] < activeIndex) activeIndex -= 1;\n\t\t\t\t\tactiveIndex = Math.max(activeIndex, 0);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (swiper.params.virtual.cache) {\n\t\t\t\t\tdelete swiper.virtual.cache[slidesIndexes];\n\t\t\t\t\t// shift cache indexes\n\t\t\t\t\tObject.keys(swiper.virtual.cache).forEach(key => {\n\t\t\t\t\t\tif (key > slidesIndexes) {\n\t\t\t\t\t\t\tswiper.virtual.cache[key - 1] = swiper.virtual.cache[key];\n\t\t\t\t\t\t\tswiper.virtual.cache[key - 1].setAttribute('data-swiper-slide-index', key - 1);\n\t\t\t\t\t\t\tdelete swiper.virtual.cache[key];\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tswiper.virtual.slides.splice(slidesIndexes, 1);\n\t\t\t\tif (slidesIndexes < activeIndex) activeIndex -= 1;\n\t\t\t\tactiveIndex = Math.max(activeIndex, 0);\n\t\t\t}\n\t\t\tupdate(true);\n\t\t\tswiper.slideTo(activeIndex, 0);\n\t\t}\n\t\tfunction removeAllSlides() {\n\t\t\tswiper.virtual.slides = [];\n\t\t\tif (swiper.params.virtual.cache) {\n\t\t\t\tswiper.virtual.cache = {};\n\t\t\t}\n\t\t\tupdate(true);\n\t\t\tswiper.slideTo(0, 0);\n\t\t}\n\t\ton('beforeInit', () => {\n\t\t\tif (!swiper.params.virtual.enabled) return;\n\t\t\tlet domSlidesAssigned;\n\t\t\tif (typeof swiper.passedParams.virtual.slides === 'undefined') {\n\t\t\t\tconst slides = [...swiper.slidesEl.children].filter(el => el.matches(`.${swiper.params.slideClass}, swiper-slide`));\n\t\t\t\tif (slides && slides.length) {\n\t\t\t\t\tswiper.virtual.slides = [...slides];\n\t\t\t\t\tdomSlidesAssigned = true;\n\t\t\t\t\tslides.forEach((slideEl, slideIndex) => {\n\t\t\t\t\t\tslideEl.setAttribute('data-swiper-slide-index', slideIndex);\n\t\t\t\t\t\tswiper.virtual.cache[slideIndex] = slideEl;\n\t\t\t\t\t\tslideEl.remove();\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!domSlidesAssigned) {\n\t\t\t\tswiper.virtual.slides = swiper.params.virtual.slides;\n\t\t\t}\n\t\t\tswiper.classNames.push(`${swiper.params.containerModifierClass}virtual`);\n\t\t\tswiper.params.watchSlidesProgress = true;\n\t\t\tswiper.originalParams.watchSlidesProgress = true;\n\t\t\tupdate(false, true);\n\t\t});\n\t\ton('setTranslate', () => {\n\t\t\tif (!swiper.params.virtual.enabled) return;\n\t\t\tif (swiper.params.cssMode && !swiper._immediateVirtual) {\n\t\t\t\tclearTimeout(cssModeTimeout);\n\t\t\t\tcssModeTimeout = setTimeout(() => {\n\t\t\t\t\tupdate();\n\t\t\t\t}, 100);\n\t\t\t} else {\n\t\t\t\tupdate();\n\t\t\t}\n\t\t});\n\t\ton('init update resize', () => {\n\t\t\tif (!swiper.params.virtual.enabled) return;\n\t\t\tif (swiper.params.cssMode) {\n\t\t\t\tsetCSSProperty(swiper.wrapperEl, '--swiper-virtual-size', `${swiper.virtualSize}px`);\n\t\t\t}\n\t\t});\n\t\tObject.assign(swiper.virtual, {\n\t\t\tappendSlide,\n\t\t\tprependSlide,\n\t\t\tremoveSlide,\n\t\t\tremoveAllSlides,\n\t\t\tupdate\n\t\t});\n\t}\n\n\t/* eslint-disable consistent-return */\n\tfunction Keyboard(_ref) {\n\t\tlet {\n\t\t\tswiper,\n\t\t\textendParams,\n\t\t\ton,\n\t\t\temit\n\t\t} = _ref;\n\t\tconst document = getDocument();\n\t\tconst window = getWindow();\n\t\tswiper.keyboard = {\n\t\t\tenabled: false\n\t\t};\n\t\textendParams({\n\t\t\tkeyboard: {\n\t\t\t\tenabled: false,\n\t\t\t\tonlyInViewport: true,\n\t\t\t\tpageUpDown: true\n\t\t\t}\n\t\t});\n\t\tfunction handle(event) {\n\t\t\tif (!swiper.enabled) return;\n\t\t\tconst {\n\t\t\t\trtlTranslate: rtl\n\t\t\t} = swiper;\n\t\t\tlet e = event;\n\t\t\tif (e.originalEvent) e = e.originalEvent; // jquery fix\n\t\t\tconst kc = e.keyCode || e.charCode;\n\t\t\tconst pageUpDown = swiper.params.keyboard.pageUpDown;\n\t\t\tconst isPageUp = pageUpDown && kc === 33;\n\t\t\tconst isPageDown = pageUpDown && kc === 34;\n\t\t\tconst isArrowLeft = kc === 37;\n\t\t\tconst isArrowRight = kc === 39;\n\t\t\tconst isArrowUp = kc === 38;\n\t\t\tconst isArrowDown = kc === 40;\n\t\t\t// Directions locks\n\t\t\tif (!swiper.allowSlideNext && (swiper.isHorizontal() && isArrowRight || swiper.isVertical() && isArrowDown || isPageDown)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (!swiper.allowSlidePrev && (swiper.isHorizontal() && isArrowLeft || swiper.isVertical() && isArrowUp || isPageUp)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (e.shiftKey || e.altKey || e.ctrlKey || e.metaKey) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t\tif (document.activeElement && document.activeElement.nodeName && (document.activeElement.nodeName.toLowerCase() === 'input' || document.activeElement.nodeName.toLowerCase() === 'textarea')) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t\tif (swiper.params.keyboard.onlyInViewport && (isPageUp || isPageDown || isArrowLeft || isArrowRight || isArrowUp || isArrowDown)) {\n\t\t\t\tlet inView = false;\n\t\t\t\t// Check that swiper should be inside of visible area of window\n\t\t\t\tif (elementParents(swiper.el, `.${swiper.params.slideClass}, swiper-slide`).length > 0 && elementParents(swiper.el, `.${swiper.params.slideActiveClass}`).length === 0) {\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\t\t\t\tconst el = swiper.el;\n\t\t\t\tconst swiperWidth = el.clientWidth;\n\t\t\t\tconst swiperHeight = el.clientHeight;\n\t\t\t\tconst windowWidth = window.innerWidth;\n\t\t\t\tconst windowHeight = window.innerHeight;\n\t\t\t\tconst swiperOffset = elementOffset(el);\n\t\t\t\tif (rtl) swiperOffset.left -= el.scrollLeft;\n\t\t\t\tconst swiperCoord = [[swiperOffset.left, swiperOffset.top], [swiperOffset.left + swiperWidth, swiperOffset.top], [swiperOffset.left, swiperOffset.top + swiperHeight], [swiperOffset.left + swiperWidth, swiperOffset.top + swiperHeight]];\n\t\t\t\tfor (let i = 0; i < swiperCoord.length; i += 1) {\n\t\t\t\t\tconst point = swiperCoord[i];\n\t\t\t\t\tif (point[0] >= 0 && point[0] <= windowWidth && point[1] >= 0 && point[1] <= windowHeight) {\n\t\t\t\t\t\tif (point[0] === 0 && point[1] === 0) continue; // eslint-disable-line\n\t\t\t\t\t\tinView = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!inView) return undefined;\n\t\t\t}\n\t\t\tif (swiper.isHorizontal()) {\n\t\t\t\tif (isPageUp || isPageDown || isArrowLeft || isArrowRight) {\n\t\t\t\t\tif (e.preventDefault) e.preventDefault(); else e.returnValue = false;\n\t\t\t\t}\n\t\t\t\tif ((isPageDown || isArrowRight) && !rtl || (isPageUp || isArrowLeft) && rtl) swiper.slideNext();\n\t\t\t\tif ((isPageUp || isArrowLeft) && !rtl || (isPageDown || isArrowRight) && rtl) swiper.slidePrev();\n\t\t\t} else {\n\t\t\t\tif (isPageUp || isPageDown || isArrowUp || isArrowDown) {\n\t\t\t\t\tif (e.preventDefault) e.preventDefault(); else e.returnValue = false;\n\t\t\t\t}\n\t\t\t\tif (isPageDown || isArrowDown) swiper.slideNext();\n\t\t\t\tif (isPageUp || isArrowUp) swiper.slidePrev();\n\t\t\t}\n\t\t\temit('keyPress', kc);\n\t\t\treturn undefined;\n\t\t}\n\t\tfunction enable() {\n\t\t\tif (swiper.keyboard.enabled) return;\n\t\t\tdocument.addEventListener('keydown', handle);\n\t\t\tswiper.keyboard.enabled = true;\n\t\t}\n\t\tfunction disable() {\n\t\t\tif (!swiper.keyboard.enabled) return;\n\t\t\tdocument.removeEventListener('keydown', handle);\n\t\t\tswiper.keyboard.enabled = false;\n\t\t}\n\t\ton('init', () => {\n\t\t\tif (swiper.params.keyboard.enabled) {\n\t\t\t\tenable();\n\t\t\t}\n\t\t});\n\t\ton('destroy', () => {\n\t\t\tif (swiper.keyboard.enabled) {\n\t\t\t\tdisable();\n\t\t\t}\n\t\t});\n\t\tObject.assign(swiper.keyboard, {\n\t\t\tenable,\n\t\t\tdisable\n\t\t});\n\t}\n\n\t/* eslint-disable consistent-return */\n\tfunction Mousewheel(_ref) {\n\t\tlet {\n\t\t\tswiper,\n\t\t\textendParams,\n\t\t\ton,\n\t\t\temit\n\t\t} = _ref;\n\t\tconst window = getWindow();\n\t\textendParams({\n\t\t\tmousewheel: {\n\t\t\t\tenabled: false,\n\t\t\t\treleaseOnEdges: false,\n\t\t\t\tinvert: false,\n\t\t\t\tforceToAxis: false,\n\t\t\t\tsensitivity: 1,\n\t\t\t\teventsTarget: 'container',\n\t\t\t\tthresholdDelta: null,\n\t\t\t\tthresholdTime: null,\n\t\t\t\tnoMousewheelClass: 'swiper-no-mousewheel'\n\t\t\t}\n\t\t});\n\t\tswiper.mousewheel = {\n\t\t\tenabled: false\n\t\t};\n\t\tlet timeout;\n\t\tlet lastScrollTime = now();\n\t\tlet lastEventBeforeSnap;\n\t\tconst recentWheelEvents = [];\n\t\tfunction normalize(e) {\n\t\t\t// Reasonable defaults\n\t\t\tconst PIXEL_STEP = 10;\n\t\t\tconst LINE_HEIGHT = 40;\n\t\t\tconst PAGE_HEIGHT = 800;\n\t\t\tlet sX = 0;\n\t\t\tlet sY = 0; // spinX, spinY\n\t\t\tlet pX = 0;\n\t\t\tlet pY = 0; // pixelX, pixelY\n\n\t\t\t// Legacy\n\t\t\tif ('detail' in e) {\n\t\t\t\tsY = e.detail;\n\t\t\t}\n\t\t\tif ('wheelDelta' in e) {\n\t\t\t\tsY = -e.wheelDelta / 120;\n\t\t\t}\n\t\t\tif ('wheelDeltaY' in e) {\n\t\t\t\tsY = -e.wheelDeltaY / 120;\n\t\t\t}\n\t\t\tif ('wheelDeltaX' in e) {\n\t\t\t\tsX = -e.wheelDeltaX / 120;\n\t\t\t}\n\n\t\t\t// side scrolling on FF with DOMMouseScroll\n\t\t\tif ('axis' in e && e.axis === e.HORIZONTAL_AXIS) {\n\t\t\t\tsX = sY;\n\t\t\t\tsY = 0;\n\t\t\t}\n\t\t\tpX = sX * PIXEL_STEP;\n\t\t\tpY = sY * PIXEL_STEP;\n\t\t\tif ('deltaY' in e) {\n\t\t\t\tpY = e.deltaY;\n\t\t\t}\n\t\t\tif ('deltaX' in e) {\n\t\t\t\tpX = e.deltaX;\n\t\t\t}\n\t\t\tif (e.shiftKey && !pX) {\n\t\t\t\t// if user scrolls with shift he wants horizontal scroll\n\t\t\t\tpX = pY;\n\t\t\t\tpY = 0;\n\t\t\t}\n\t\t\tif ((pX || pY) && e.deltaMode) {\n\t\t\t\tif (e.deltaMode === 1) {\n\t\t\t\t\t// delta in LINE units\n\t\t\t\t\tpX *= LINE_HEIGHT;\n\t\t\t\t\tpY *= LINE_HEIGHT;\n\t\t\t\t} else {\n\t\t\t\t\t// delta in PAGE units\n\t\t\t\t\tpX *= PAGE_HEIGHT;\n\t\t\t\t\tpY *= PAGE_HEIGHT;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Fall-back if spin cannot be determined\n\t\t\tif (pX && !sX) {\n\t\t\t\tsX = pX < 1 ? -1 : 1;\n\t\t\t}\n\t\t\tif (pY && !sY) {\n\t\t\t\tsY = pY < 1 ? -1 : 1;\n\t\t\t}\n\t\t\treturn {\n\t\t\t\tspinX: sX,\n\t\t\t\tspinY: sY,\n\t\t\t\tpixelX: pX,\n\t\t\t\tpixelY: pY\n\t\t\t};\n\t\t}\n\t\tfunction handleMouseEnter() {\n\t\t\tif (!swiper.enabled) return;\n\t\t\tswiper.mouseEntered = true;\n\t\t}\n\t\tfunction handleMouseLeave() {\n\t\t\tif (!swiper.enabled) return;\n\t\t\tswiper.mouseEntered = false;\n\t\t}\n\t\tfunction animateSlider(newEvent) {\n\t\t\tif (swiper.params.mousewheel.thresholdDelta && newEvent.delta < swiper.params.mousewheel.thresholdDelta) {\n\t\t\t\t// Prevent if delta of wheel scroll delta is below configured threshold\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (swiper.params.mousewheel.thresholdTime && now() - lastScrollTime < swiper.params.mousewheel.thresholdTime) {\n\t\t\t\t// Prevent if time between scrolls is below configured threshold\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// If the movement is NOT big enough and\n\t\t\t// if the last time the user scrolled was too close to the current one (avoid continuously triggering the slider):\n\t\t\t//   Don't go any further (avoid insignificant scroll movement).\n\t\t\tif (newEvent.delta >= 6 && now() - lastScrollTime < 60) {\n\t\t\t\t// Return false as a default\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t// If user is scrolling towards the end:\n\t\t\t//   If the slider hasn't hit the latest slide or\n\t\t\t//   if the slider is a loop and\n\t\t\t//   if the slider isn't moving right now:\n\t\t\t//     Go to next slide and\n\t\t\t//     emit a scroll event.\n\t\t\t// Else (the user is scrolling towards the beginning) and\n\t\t\t// if the slider hasn't hit the first slide or\n\t\t\t// if the slider is a loop and\n\t\t\t// if the slider isn't moving right now:\n\t\t\t//   Go to prev slide and\n\t\t\t//   emit a scroll event.\n\t\t\tif (newEvent.direction < 0) {\n\t\t\t\tif ((!swiper.isEnd || swiper.params.loop) && !swiper.animating) {\n\t\t\t\t\tswiper.slideNext();\n\t\t\t\t\temit('scroll', newEvent.raw);\n\t\t\t\t}\n\t\t\t} else if ((!swiper.isBeginning || swiper.params.loop) && !swiper.animating) {\n\t\t\t\tswiper.slidePrev();\n\t\t\t\temit('scroll', newEvent.raw);\n\t\t\t}\n\t\t\t// If you got here is because an animation has been triggered so store the current time\n\t\t\tlastScrollTime = new window.Date().getTime();\n\t\t\t// Return false as a default\n\t\t\treturn false;\n\t\t}\n\t\tfunction releaseScroll(newEvent) {\n\t\t\tconst params = swiper.params.mousewheel;\n\t\t\tif (newEvent.direction < 0) {\n\t\t\t\tif (swiper.isEnd && !swiper.params.loop && params.releaseOnEdges) {\n\t\t\t\t\t// Return true to animate scroll on edges\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t} else if (swiper.isBeginning && !swiper.params.loop && params.releaseOnEdges) {\n\t\t\t\t// Return true to animate scroll on edges\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\tfunction handle(event) {\n\t\t\tlet e = event;\n\t\t\tlet disableParentSwiper = true;\n\t\t\tif (!swiper.enabled) return;\n\n\t\t\t// Ignore event if the target or its parents have the swiper-no-mousewheel class\n\t\t\tif (event.target.closest(`.${swiper.params.mousewheel.noMousewheelClass}`)) return;\n\t\t\tconst params = swiper.params.mousewheel;\n\t\t\tif (swiper.params.cssMode) {\n\t\t\t\te.preventDefault();\n\t\t\t}\n\t\t\tlet targetEl = swiper.el;\n\t\t\tif (swiper.params.mousewheel.eventsTarget !== 'container') {\n\t\t\t\ttargetEl = document.querySelector(swiper.params.mousewheel.eventsTarget);\n\t\t\t}\n\t\t\tconst targetElContainsTarget = targetEl && targetEl.contains(e.target);\n\t\t\tif (!swiper.mouseEntered && !targetElContainsTarget && !params.releaseOnEdges) return true;\n\t\t\tif (e.originalEvent) e = e.originalEvent; // jquery fix\n\t\t\tlet delta = 0;\n\t\t\tconst rtlFactor = swiper.rtlTranslate ? -1 : 1;\n\t\t\tconst data = normalize(e);\n\t\t\tif (params.forceToAxis) {\n\t\t\t\tif (swiper.isHorizontal()) {\n\t\t\t\t\tif (Math.abs(data.pixelX) > Math.abs(data.pixelY)) delta = -data.pixelX * rtlFactor; else return true;\n\t\t\t\t} else if (Math.abs(data.pixelY) > Math.abs(data.pixelX)) delta = -data.pixelY; else return true;\n\t\t\t} else {\n\t\t\t\tdelta = Math.abs(data.pixelX) > Math.abs(data.pixelY) ? -data.pixelX * rtlFactor : -data.pixelY;\n\t\t\t}\n\t\t\tif (delta === 0) return true;\n\t\t\tif (params.invert) delta = -delta;\n\n\t\t\t// Get the scroll positions\n\t\t\tlet positions = swiper.getTranslate() + delta * params.sensitivity;\n\t\t\tif (positions >= swiper.minTranslate()) positions = swiper.minTranslate();\n\t\t\tif (positions <= swiper.maxTranslate()) positions = swiper.maxTranslate();\n\n\t\t\t// When loop is true:\n\t\t\t//     the disableParentSwiper will be true.\n\t\t\t// When loop is false:\n\t\t\t//     if the scroll positions is not on edge,\n\t\t\t//     then the disableParentSwiper will be true.\n\t\t\t//     if the scroll on edge positions,\n\t\t\t//     then the disableParentSwiper will be false.\n\t\t\tdisableParentSwiper = swiper.params.loop ? true : !(positions === swiper.minTranslate() || positions === swiper.maxTranslate());\n\t\t\tif (disableParentSwiper && swiper.params.nested) e.stopPropagation();\n\t\t\tif (!swiper.params.freeMode || !swiper.params.freeMode.enabled) {\n\t\t\t\t// Register the new event in a variable which stores the relevant data\n\t\t\t\tconst newEvent = {\n\t\t\t\t\ttime: now(),\n\t\t\t\t\tdelta: Math.abs(delta),\n\t\t\t\t\tdirection: Math.sign(delta),\n\t\t\t\t\traw: event\n\t\t\t\t};\n\n\t\t\t\t// Keep the most recent events\n\t\t\t\tif (recentWheelEvents.length >= 2) {\n\t\t\t\t\trecentWheelEvents.shift(); // only store the last N events\n\t\t\t\t}\n\n\t\t\t\tconst prevEvent = recentWheelEvents.length ? recentWheelEvents[recentWheelEvents.length - 1] : undefined;\n\t\t\t\trecentWheelEvents.push(newEvent);\n\n\t\t\t\t// If there is at least one previous recorded event:\n\t\t\t\t//   If direction has changed or\n\t\t\t\t//   if the scroll is quicker than the previous one:\n\t\t\t\t//     Animate the slider.\n\t\t\t\t// Else (this is the first time the wheel is moved):\n\t\t\t\t//     Animate the slider.\n\t\t\t\tif (prevEvent) {\n\t\t\t\t\tif (newEvent.direction !== prevEvent.direction || newEvent.delta > prevEvent.delta || newEvent.time > prevEvent.time + 150) {\n\t\t\t\t\t\tanimateSlider(newEvent);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tanimateSlider(newEvent);\n\t\t\t\t}\n\n\t\t\t\t// If it's time to release the scroll:\n\t\t\t\t//   Return now so you don't hit the preventDefault.\n\t\t\t\tif (releaseScroll(newEvent)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Freemode or scrollContainer:\n\n\t\t\t\t// If we recently snapped after a momentum scroll, then ignore wheel events\n\t\t\t\t// to give time for the deceleration to finish. Stop ignoring after 500 msecs\n\t\t\t\t// or if it's a new scroll (larger delta or inverse sign as last event before\n\t\t\t\t// an end-of-momentum snap).\n\t\t\t\tconst newEvent = {\n\t\t\t\t\ttime: now(),\n\t\t\t\t\tdelta: Math.abs(delta),\n\t\t\t\t\tdirection: Math.sign(delta)\n\t\t\t\t};\n\t\t\t\tconst ignoreWheelEvents = lastEventBeforeSnap && newEvent.time < lastEventBeforeSnap.time + 500 && newEvent.delta <= lastEventBeforeSnap.delta && newEvent.direction === lastEventBeforeSnap.direction;\n\t\t\t\tif (!ignoreWheelEvents) {\n\t\t\t\t\tlastEventBeforeSnap = undefined;\n\t\t\t\t\tlet position = swiper.getTranslate() + delta * params.sensitivity;\n\t\t\t\t\tconst wasBeginning = swiper.isBeginning;\n\t\t\t\t\tconst wasEnd = swiper.isEnd;\n\t\t\t\t\tif (position >= swiper.minTranslate()) position = swiper.minTranslate();\n\t\t\t\t\tif (position <= swiper.maxTranslate()) position = swiper.maxTranslate();\n\t\t\t\t\tswiper.setTransition(0);\n\t\t\t\t\tswiper.setTranslate(position);\n\t\t\t\t\tswiper.updateProgress();\n\t\t\t\t\tswiper.updateActiveIndex();\n\t\t\t\t\tswiper.updateSlidesClasses();\n\t\t\t\t\tif (!wasBeginning && swiper.isBeginning || !wasEnd && swiper.isEnd) {\n\t\t\t\t\t\tswiper.updateSlidesClasses();\n\t\t\t\t\t}\n\t\t\t\t\tif (swiper.params.loop) {\n\t\t\t\t\t\tswiper.loopFix({\n\t\t\t\t\t\t\tdirection: newEvent.direction < 0 ? 'next' : 'prev',\n\t\t\t\t\t\t\tbyMousewheel: true\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\tif (swiper.params.freeMode.sticky) {\n\t\t\t\t\t\t// When wheel scrolling starts with sticky (aka snap) enabled, then detect\n\t\t\t\t\t\t// the end of a momentum scroll by storing recent (N=15?) wheel events.\n\t\t\t\t\t\t// 1. do all N events have decreasing or same (absolute value) delta?\n\t\t\t\t\t\t// 2. did all N events arrive in the last M (M=500?) msecs?\n\t\t\t\t\t\t// 3. does the earliest event have an (absolute value) delta that's\n\t\t\t\t\t\t//    at least P (P=1?) larger than the most recent event's delta?\n\t\t\t\t\t\t// 4. does the latest event have a delta that's smaller than Q (Q=6?) pixels?\n\t\t\t\t\t\t// If 1-4 are \"yes\" then we're near the end of a momentum scroll deceleration.\n\t\t\t\t\t\t// Snap immediately and ignore remaining wheel events in this scroll.\n\t\t\t\t\t\t// See comment above for \"remaining wheel events in this scroll\" determination.\n\t\t\t\t\t\t// If 1-4 aren't satisfied, then wait to snap until 500ms after the last event.\n\t\t\t\t\t\tclearTimeout(timeout);\n\t\t\t\t\t\ttimeout = undefined;\n\t\t\t\t\t\tif (recentWheelEvents.length >= 15) {\n\t\t\t\t\t\t\trecentWheelEvents.shift(); // only store the last N events\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst prevEvent = recentWheelEvents.length ? recentWheelEvents[recentWheelEvents.length - 1] : undefined;\n\t\t\t\t\t\tconst firstEvent = recentWheelEvents[0];\n\t\t\t\t\t\trecentWheelEvents.push(newEvent);\n\t\t\t\t\t\tif (prevEvent && (newEvent.delta > prevEvent.delta || newEvent.direction !== prevEvent.direction)) {\n\t\t\t\t\t\t\t// Increasing or reverse-sign delta means the user started scrolling again. Clear the wheel event log.\n\t\t\t\t\t\t\trecentWheelEvents.splice(0);\n\t\t\t\t\t\t} else if (recentWheelEvents.length >= 15 && newEvent.time - firstEvent.time < 500 && firstEvent.delta - newEvent.delta >= 1 && newEvent.delta <= 6) {\n\t\t\t\t\t\t\t// We're at the end of the deceleration of a momentum scroll, so there's no need\n\t\t\t\t\t\t\t// to wait for more events. Snap ASAP on the next tick.\n\t\t\t\t\t\t\t// Also, because there's some remaining momentum we'll bias the snap in the\n\t\t\t\t\t\t\t// direction of the ongoing scroll because it's better UX for the scroll to snap\n\t\t\t\t\t\t\t// in the same direction as the scroll instead of reversing to snap.  Therefore,\n\t\t\t\t\t\t\t// if it's already scrolled more than 20% in the current direction, keep going.\n\t\t\t\t\t\t\tconst snapToThreshold = delta > 0 ? 0.8 : 0.2;\n\t\t\t\t\t\t\tlastEventBeforeSnap = newEvent;\n\t\t\t\t\t\t\trecentWheelEvents.splice(0);\n\t\t\t\t\t\t\ttimeout = nextTick(() => {\n\t\t\t\t\t\t\t\tswiper.slideToClosest(swiper.params.speed, true, undefined, snapToThreshold);\n\t\t\t\t\t\t\t}, 0); // no delay; move on next tick\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (!timeout) {\n\t\t\t\t\t\t\t// if we get here, then we haven't detected the end of a momentum scroll, so\n\t\t\t\t\t\t\t// we'll consider a scroll \"complete\" when there haven't been any wheel events\n\t\t\t\t\t\t\t// for 500ms.\n\t\t\t\t\t\t\ttimeout = nextTick(() => {\n\t\t\t\t\t\t\t\tconst snapToThreshold = 0.5;\n\t\t\t\t\t\t\t\tlastEventBeforeSnap = newEvent;\n\t\t\t\t\t\t\t\trecentWheelEvents.splice(0);\n\t\t\t\t\t\t\t\tswiper.slideToClosest(swiper.params.speed, true, undefined, snapToThreshold);\n\t\t\t\t\t\t\t}, 500);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Emit event\n\t\t\t\t\tif (!ignoreWheelEvents) emit('scroll', e);\n\n\t\t\t\t\t// Stop autoplay\n\t\t\t\t\tif (swiper.params.autoplay && swiper.params.autoplayDisableOnInteraction) swiper.autoplay.stop();\n\t\t\t\t\t// Return page scroll on edge positions\n\t\t\t\t\tif (params.releaseOnEdges && (position === swiper.minTranslate() || position === swiper.maxTranslate())) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (e.preventDefault) e.preventDefault(); else e.returnValue = false;\n\t\t\treturn false;\n\t\t}\n\t\tfunction events(method) {\n\t\t\tlet targetEl = swiper.el;\n\t\t\tif (swiper.params.mousewheel.eventsTarget !== 'container') {\n\t\t\t\ttargetEl = document.querySelector(swiper.params.mousewheel.eventsTarget);\n\t\t\t}\n\t\t\ttargetEl[method]('mouseenter', handleMouseEnter);\n\t\t\ttargetEl[method]('mouseleave', handleMouseLeave);\n\t\t\ttargetEl[method]('wheel', handle);\n\t\t}\n\t\tfunction enable() {\n\t\t\tif (swiper.params.cssMode) {\n\t\t\t\tswiper.wrapperEl.removeEventListener('wheel', handle);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif (swiper.mousewheel.enabled) return false;\n\t\t\tevents('addEventListener');\n\t\t\tswiper.mousewheel.enabled = true;\n\t\t\treturn true;\n\t\t}\n\t\tfunction disable() {\n\t\t\tif (swiper.params.cssMode) {\n\t\t\t\tswiper.wrapperEl.addEventListener(event, handle);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif (!swiper.mousewheel.enabled) return false;\n\t\t\tevents('removeEventListener');\n\t\t\tswiper.mousewheel.enabled = false;\n\t\t\treturn true;\n\t\t}\n\t\ton('init', () => {\n\t\t\tif (!swiper.params.mousewheel.enabled && swiper.params.cssMode) {\n\t\t\t\tdisable();\n\t\t\t}\n\t\t\tif (swiper.params.mousewheel.enabled) enable();\n\t\t});\n\t\ton('destroy', () => {\n\t\t\tif (swiper.params.cssMode) {\n\t\t\t\tenable();\n\t\t\t}\n\t\t\tif (swiper.mousewheel.enabled) disable();\n\t\t});\n\t\tObject.assign(swiper.mousewheel, {\n\t\t\tenable,\n\t\t\tdisable\n\t\t});\n\t}\n\n\tfunction createElementIfNotDefined(swiper, originalParams, params, checkProps) {\n\t\tif (swiper.params.createElements) {\n\t\t\tObject.keys(checkProps).forEach(key => {\n\t\t\t\tif (!params[key] && params.auto === true) {\n\t\t\t\t\tlet element = elementChildren(swiper.el, `.${checkProps[key]}`)[0];\n\t\t\t\t\tif (!element) {\n\t\t\t\t\t\telement = createElement('div', checkProps[key]);\n\t\t\t\t\t\telement.className = checkProps[key];\n\t\t\t\t\t\tswiper.el.append(element);\n\t\t\t\t\t}\n\t\t\t\t\tparams[key] = element;\n\t\t\t\t\toriginalParams[key] = element;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\treturn params;\n\t}\n\n\tfunction Navigation(_ref) {\n\t\tlet {\n\t\t\tswiper,\n\t\t\textendParams,\n\t\t\ton,\n\t\t\temit\n\t\t} = _ref;\n\t\textendParams({\n\t\t\tnavigation: {\n\t\t\t\tnextEl: null,\n\t\t\t\tprevEl: null,\n\t\t\t\thideOnClick: false,\n\t\t\t\tdisabledClass: 'swiper-button-disabled',\n\t\t\t\thiddenClass: 'swiper-button-hidden',\n\t\t\t\tlockClass: 'swiper-button-lock',\n\t\t\t\tnavigationDisabledClass: 'swiper-navigation-disabled'\n\t\t\t}\n\t\t});\n\t\tswiper.navigation = {\n\t\t\tnextEl: null,\n\t\t\tprevEl: null\n\t\t};\n\t\tfunction getEl(el) {\n\t\t\tlet res;\n\t\t\tif (el && typeof el === 'string' && swiper.isElement) {\n\t\t\t\tres = swiper.el.querySelector(el);\n\t\t\t\tif (res) return res;\n\t\t\t}\n\t\t\tif (el) {\n\t\t\t\tif (typeof el === 'string') res = [...document.querySelectorAll(el)];\n\t\t\t\tif (swiper.params.uniqueNavElements && typeof el === 'string' && res && res.length > 1 && swiper.el.querySelectorAll(el).length === 1) {\n\t\t\t\t\tres = swiper.el.querySelector(el);\n\t\t\t\t} else if (res && res.length === 1) {\n\t\t\t\t\tres = res[0];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (el && !res) return el;\n\t\t\t// if (Array.isArray(res) && res.length === 1) res = res[0];\n\t\t\treturn res;\n\t\t}\n\t\tfunction toggleEl(el, disabled) {\n\t\t\tconst params = swiper.params.navigation;\n\t\t\tel = makeElementsArray(el);\n\t\t\tel.forEach(subEl => {\n\t\t\t\tif (subEl) {\n\t\t\t\t\tsubEl.classList[disabled ? 'add' : 'remove'](...params.disabledClass.split(' '));\n\t\t\t\t\tif (subEl.tagName === 'BUTTON') subEl.disabled = disabled;\n\t\t\t\t\tif (swiper.params.watchOverflow && swiper.enabled) {\n\t\t\t\t\t\tsubEl.classList[swiper.isLocked ? 'add' : 'remove'](params.lockClass);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\tfunction update() {\n\t\t\t// Update Navigation Buttons\n\t\t\tconst {\n\t\t\t\tnextEl,\n\t\t\t\tprevEl\n\t\t\t} = swiper.navigation;\n\t\t\tif (swiper.params.loop) {\n\t\t\t\ttoggleEl(prevEl, false);\n\t\t\t\ttoggleEl(nextEl, false);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\ttoggleEl(prevEl, swiper.isBeginning && !swiper.params.rewind);\n\t\t\ttoggleEl(nextEl, swiper.isEnd && !swiper.params.rewind);\n\t\t}\n\t\tfunction onPrevClick(e) {\n\t\t\te.preventDefault();\n\t\t\tif (swiper.isBeginning && !swiper.params.loop && !swiper.params.rewind) return;\n\t\t\tswiper.slidePrev();\n\t\t\temit('navigationPrev');\n\t\t}\n\t\tfunction onNextClick(e) {\n\t\t\te.preventDefault();\n\t\t\tif (swiper.isEnd && !swiper.params.loop && !swiper.params.rewind) return;\n\t\t\tswiper.slideNext();\n\t\t\temit('navigationNext');\n\t\t}\n\t\tfunction init() {\n\t\t\tconst params = swiper.params.navigation;\n\t\t\tswiper.params.navigation = createElementIfNotDefined(swiper, swiper.originalParams.navigation, swiper.params.navigation, {\n\t\t\t\tnextEl: 'swiper-button-next',\n\t\t\t\tprevEl: 'swiper-button-prev'\n\t\t\t});\n\t\t\tif (!(params.nextEl || params.prevEl)) return;\n\t\t\tlet nextEl = getEl(params.nextEl);\n\t\t\tlet prevEl = getEl(params.prevEl);\n\t\t\tObject.assign(swiper.navigation, {\n\t\t\t\tnextEl,\n\t\t\t\tprevEl\n\t\t\t});\n\t\t\tnextEl = makeElementsArray(nextEl);\n\t\t\tprevEl = makeElementsArray(prevEl);\n\t\t\tconst initButton = (el, dir) => {\n\t\t\t\tif (el) {\n\t\t\t\t\tel.addEventListener('click', dir === 'next' ? onNextClick : onPrevClick);\n\t\t\t\t}\n\t\t\t\tif (!swiper.enabled && el) {\n\t\t\t\t\tel.classList.add(...params.lockClass.split(' '));\n\t\t\t\t}\n\t\t\t};\n\t\t\tnextEl.forEach(el => initButton(el, 'next'));\n\t\t\tprevEl.forEach(el => initButton(el, 'prev'));\n\t\t}\n\t\tfunction destroy() {\n\t\t\tlet {\n\t\t\t\tnextEl,\n\t\t\t\tprevEl\n\t\t\t} = swiper.navigation;\n\t\t\tnextEl = makeElementsArray(nextEl);\n\t\t\tprevEl = makeElementsArray(prevEl);\n\t\t\tconst destroyButton = (el, dir) => {\n\t\t\t\tel.removeEventListener('click', dir === 'next' ? onNextClick : onPrevClick);\n\t\t\t\tel.classList.remove(...swiper.params.navigation.disabledClass.split(' '));\n\t\t\t};\n\t\t\tnextEl.forEach(el => destroyButton(el, 'next'));\n\t\t\tprevEl.forEach(el => destroyButton(el, 'prev'));\n\t\t}\n\t\ton('init', () => {\n\t\t\tif (swiper.params.navigation.enabled === false) {\n\t\t\t\t// eslint-disable-next-line\n\t\t\t\tdisable();\n\t\t\t} else {\n\t\t\t\tinit();\n\t\t\t\tupdate();\n\t\t\t}\n\t\t});\n\t\ton('toEdge fromEdge lock unlock', () => {\n\t\t\tupdate();\n\t\t});\n\t\ton('destroy', () => {\n\t\t\tdestroy();\n\t\t});\n\t\ton('enable disable', () => {\n\t\t\tlet {\n\t\t\t\tnextEl,\n\t\t\t\tprevEl\n\t\t\t} = swiper.navigation;\n\t\t\tnextEl = makeElementsArray(nextEl);\n\t\t\tprevEl = makeElementsArray(prevEl);\n\t\t\tif (swiper.enabled) {\n\t\t\t\tupdate();\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t[...nextEl, ...prevEl].filter(el => !!el).forEach(el => el.classList.add(swiper.params.navigation.lockClass));\n\t\t});\n\t\ton('click', (_s, e) => {\n\t\t\tlet {\n\t\t\t\tnextEl,\n\t\t\t\tprevEl\n\t\t\t} = swiper.navigation;\n\t\t\tnextEl = makeElementsArray(nextEl);\n\t\t\tprevEl = makeElementsArray(prevEl);\n\t\t\tconst targetEl = e.target;\n\t\t\tlet targetIsButton = prevEl.includes(targetEl) || nextEl.includes(targetEl);\n\t\t\tif (swiper.isElement && !targetIsButton) {\n\t\t\t\tconst path = e.path || e.composedPath && e.composedPath();\n\t\t\t\tif (path) {\n\t\t\t\t\ttargetIsButton = path.find(pathEl => nextEl.includes(pathEl) || prevEl.includes(pathEl));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (swiper.params.navigation.hideOnClick && !targetIsButton) {\n\t\t\t\tif (swiper.pagination && swiper.params.pagination && swiper.params.pagination.clickable && (swiper.pagination.el === targetEl || swiper.pagination.el.contains(targetEl))) return;\n\t\t\t\tlet isHidden;\n\t\t\t\tif (nextEl.length) {\n\t\t\t\t\tisHidden = nextEl[0].classList.contains(swiper.params.navigation.hiddenClass);\n\t\t\t\t} else if (prevEl.length) {\n\t\t\t\t\tisHidden = prevEl[0].classList.contains(swiper.params.navigation.hiddenClass);\n\t\t\t\t}\n\t\t\t\tif (isHidden === true) {\n\t\t\t\t\temit('navigationShow');\n\t\t\t\t} else {\n\t\t\t\t\temit('navigationHide');\n\t\t\t\t}\n\t\t\t\t[...nextEl, ...prevEl].filter(el => !!el).forEach(el => el.classList.toggle(swiper.params.navigation.hiddenClass));\n\t\t\t}\n\t\t});\n\t\tconst enable = () => {\n\t\t\tswiper.el.classList.remove(...swiper.params.navigation.navigationDisabledClass.split(' '));\n\t\t\tinit();\n\t\t\tupdate();\n\t\t};\n\t\tconst disable = () => {\n\t\t\tswiper.el.classList.add(...swiper.params.navigation.navigationDisabledClass.split(' '));\n\t\t\tdestroy();\n\t\t};\n\t\tObject.assign(swiper.navigation, {\n\t\t\tenable,\n\t\t\tdisable,\n\t\t\tupdate,\n\t\t\tinit,\n\t\t\tdestroy\n\t\t});\n\t}\n\n\tfunction classesToSelector(classes) {\n\t\tif (classes === void 0) {\n\t\t\tclasses = '';\n\t\t}\n\t\treturn `.${classes.trim().replace(/([\\.:!+\\/])/g, '\\\\$1') // eslint-disable-line\n\t\t\t.replace(/ /g, '.')}`;\n\t}\n\n\tfunction Pagination(_ref) {\n\t\tlet {\n\t\t\tswiper,\n\t\t\textendParams,\n\t\t\ton,\n\t\t\temit\n\t\t} = _ref;\n\t\tconst pfx = 'swiper-pagination';\n\t\textendParams({\n\t\t\tpagination: {\n\t\t\t\tel: null,\n\t\t\t\tbulletElement: 'span',\n\t\t\t\tclickable: false,\n\t\t\t\thideOnClick: false,\n\t\t\t\trenderBullet: null,\n\t\t\t\trenderProgressbar: null,\n\t\t\t\trenderFraction: null,\n\t\t\t\trenderCustom: null,\n\t\t\t\tprogressbarOpposite: false,\n\t\t\t\ttype: 'bullets',\n\t\t\t\t// 'bullets' or 'progressbar' or 'fraction' or 'custom'\n\t\t\t\tdynamicBullets: false,\n\t\t\t\tdynamicMainBullets: 1,\n\t\t\t\tformatFractionCurrent: number => number,\n\t\t\t\tformatFractionTotal: number => number,\n\t\t\t\tbulletClass: `${pfx}-bullet`,\n\t\t\t\tbulletActiveClass: `${pfx}-bullet-active`,\n\t\t\t\tmodifierClass: `${pfx}-`,\n\t\t\t\tcurrentClass: `${pfx}-current`,\n\t\t\t\ttotalClass: `${pfx}-total`,\n\t\t\t\thiddenClass: `${pfx}-hidden`,\n\t\t\t\tprogressbarFillClass: `${pfx}-progressbar-fill`,\n\t\t\t\tprogressbarOppositeClass: `${pfx}-progressbar-opposite`,\n\t\t\t\tclickableClass: `${pfx}-clickable`,\n\t\t\t\tlockClass: `${pfx}-lock`,\n\t\t\t\thorizontalClass: `${pfx}-horizontal`,\n\t\t\t\tverticalClass: `${pfx}-vertical`,\n\t\t\t\tpaginationDisabledClass: `${pfx}-disabled`\n\t\t\t}\n\t\t});\n\t\tswiper.pagination = {\n\t\t\tel: null,\n\t\t\tbullets: []\n\t\t};\n\t\tlet bulletSize;\n\t\tlet dynamicBulletIndex = 0;\n\t\tfunction isPaginationDisabled() {\n\t\t\treturn !swiper.params.pagination.el || !swiper.pagination.el || Array.isArray(swiper.pagination.el) && swiper.pagination.el.length === 0;\n\t\t}\n\t\tfunction setSideBullets(bulletEl, position) {\n\t\t\tconst {\n\t\t\t\tbulletActiveClass\n\t\t\t} = swiper.params.pagination;\n\t\t\tif (!bulletEl) return;\n\t\t\tbulletEl = bulletEl[`${position === 'prev' ? 'previous' : 'next'}ElementSibling`];\n\t\t\tif (bulletEl) {\n\t\t\t\tbulletEl.classList.add(`${bulletActiveClass}-${position}`);\n\t\t\t\tbulletEl = bulletEl[`${position === 'prev' ? 'previous' : 'next'}ElementSibling`];\n\t\t\t\tif (bulletEl) {\n\t\t\t\t\tbulletEl.classList.add(`${bulletActiveClass}-${position}-${position}`);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfunction onBulletClick(e) {\n\t\t\tconst bulletEl = e.target.closest(classesToSelector(swiper.params.pagination.bulletClass));\n\t\t\tif (!bulletEl) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\te.preventDefault();\n\t\t\tconst index = elementIndex(bulletEl) * swiper.params.slidesPerGroup;\n\t\t\tif (swiper.params.loop) {\n\t\t\t\tif (swiper.realIndex === index) return;\n\t\t\t\tswiper.slideToLoop(index);\n\t\t\t} else {\n\t\t\t\tswiper.slideTo(index);\n\t\t\t}\n\t\t}\n\t\tfunction update() {\n\t\t\t// Render || Update Pagination bullets/items\n\t\t\tconst rtl = swiper.rtl;\n\t\t\tconst params = swiper.params.pagination;\n\t\t\tif (isPaginationDisabled()) return;\n\t\t\tlet el = swiper.pagination.el;\n\t\t\tel = makeElementsArray(el);\n\t\t\t// Current/Total\n\t\t\tlet current;\n\t\t\tlet previousIndex;\n\t\t\tconst slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.slides.length;\n\t\t\tconst total = swiper.params.loop ? Math.ceil(slidesLength / swiper.params.slidesPerGroup) : swiper.snapGrid.length;\n\t\t\tif (swiper.params.loop) {\n\t\t\t\tpreviousIndex = swiper.previousRealIndex || 0;\n\t\t\t\tcurrent = swiper.params.slidesPerGroup > 1 ? Math.floor(swiper.realIndex / swiper.params.slidesPerGroup) : swiper.realIndex;\n\t\t\t} else if (typeof swiper.snapIndex !== 'undefined') {\n\t\t\t\tcurrent = swiper.snapIndex;\n\t\t\t\tpreviousIndex = swiper.previousSnapIndex;\n\t\t\t} else {\n\t\t\t\tpreviousIndex = swiper.previousIndex || 0;\n\t\t\t\tcurrent = swiper.activeIndex || 0;\n\t\t\t}\n\t\t\t// Types\n\t\t\tif (params.type === 'bullets' && swiper.pagination.bullets && swiper.pagination.bullets.length > 0) {\n\t\t\t\tconst bullets = swiper.pagination.bullets;\n\t\t\t\tlet firstIndex;\n\t\t\t\tlet lastIndex;\n\t\t\t\tlet midIndex;\n\t\t\t\tif (params.dynamicBullets) {\n\t\t\t\t\tbulletSize = elementOuterSize(bullets[0], swiper.isHorizontal() ? 'width' : 'height', true);\n\t\t\t\t\tel.forEach(subEl => {\n\t\t\t\t\t\tsubEl.style[swiper.isHorizontal() ? 'width' : 'height'] = `${bulletSize * (params.dynamicMainBullets + 4)}px`;\n\t\t\t\t\t});\n\t\t\t\t\tif (params.dynamicMainBullets > 1 && previousIndex !== undefined) {\n\t\t\t\t\t\tdynamicBulletIndex += current - (previousIndex || 0);\n\t\t\t\t\t\tif (dynamicBulletIndex > params.dynamicMainBullets - 1) {\n\t\t\t\t\t\t\tdynamicBulletIndex = params.dynamicMainBullets - 1;\n\t\t\t\t\t\t} else if (dynamicBulletIndex < 0) {\n\t\t\t\t\t\t\tdynamicBulletIndex = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfirstIndex = Math.max(current - dynamicBulletIndex, 0);\n\t\t\t\t\tlastIndex = firstIndex + (Math.min(bullets.length, params.dynamicMainBullets) - 1);\n\t\t\t\t\tmidIndex = (lastIndex + firstIndex) / 2;\n\t\t\t\t}\n\t\t\t\tbullets.forEach(bulletEl => {\n\t\t\t\t\tconst classesToRemove = [...['', '-next', '-next-next', '-prev', '-prev-prev', '-main'].map(suffix => `${params.bulletActiveClass}${suffix}`)].map(s => typeof s === 'string' && s.includes(' ') ? s.split(' ') : s).flat();\n\t\t\t\t\tbulletEl.classList.remove(...classesToRemove);\n\t\t\t\t});\n\t\t\t\tif (el.length > 1) {\n\t\t\t\t\tbullets.forEach(bullet => {\n\t\t\t\t\t\tconst bulletIndex = elementIndex(bullet);\n\t\t\t\t\t\tif (bulletIndex === current) {\n\t\t\t\t\t\t\tbullet.classList.add(...params.bulletActiveClass.split(' '));\n\t\t\t\t\t\t} else if (swiper.isElement) {\n\t\t\t\t\t\t\tbullet.setAttribute('part', 'bullet');\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (params.dynamicBullets) {\n\t\t\t\t\t\t\tif (bulletIndex >= firstIndex && bulletIndex <= lastIndex) {\n\t\t\t\t\t\t\t\tbullet.classList.add(...`${params.bulletActiveClass}-main`.split(' '));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (bulletIndex === firstIndex) {\n\t\t\t\t\t\t\t\tsetSideBullets(bullet, 'prev');\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (bulletIndex === lastIndex) {\n\t\t\t\t\t\t\t\tsetSideBullets(bullet, 'next');\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tconst bullet = bullets[current];\n\t\t\t\t\tif (bullet) {\n\t\t\t\t\t\tbullet.classList.add(...params.bulletActiveClass.split(' '));\n\t\t\t\t\t}\n\t\t\t\t\tif (swiper.isElement) {\n\t\t\t\t\t\tbullets.forEach((bulletEl, bulletIndex) => {\n\t\t\t\t\t\t\tbulletEl.setAttribute('part', bulletIndex === current ? 'bullet-active' : 'bullet');\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\tif (params.dynamicBullets) {\n\t\t\t\t\t\tconst firstDisplayedBullet = bullets[firstIndex];\n\t\t\t\t\t\tconst lastDisplayedBullet = bullets[lastIndex];\n\t\t\t\t\t\tfor (let i = firstIndex; i <= lastIndex; i += 1) {\n\t\t\t\t\t\t\tif (bullets[i]) {\n\t\t\t\t\t\t\t\tbullets[i].classList.add(...`${params.bulletActiveClass}-main`.split(' '));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsetSideBullets(firstDisplayedBullet, 'prev');\n\t\t\t\t\t\tsetSideBullets(lastDisplayedBullet, 'next');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (params.dynamicBullets) {\n\t\t\t\t\tconst dynamicBulletsLength = Math.min(bullets.length, params.dynamicMainBullets + 4);\n\t\t\t\t\tconst bulletsOffset = (bulletSize * dynamicBulletsLength - bulletSize) / 2 - midIndex * bulletSize;\n\t\t\t\t\tconst offsetProp = rtl ? 'right' : 'left';\n\t\t\t\t\tbullets.forEach(bullet => {\n\t\t\t\t\t\tbullet.style[swiper.isHorizontal() ? offsetProp : 'top'] = `${bulletsOffset}px`;\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t\tel.forEach((subEl, subElIndex) => {\n\t\t\t\tif (params.type === 'fraction') {\n\t\t\t\t\tsubEl.querySelectorAll(classesToSelector(params.currentClass)).forEach(fractionEl => {\n\t\t\t\t\t\tfractionEl.textContent = params.formatFractionCurrent(current + 1);\n\t\t\t\t\t});\n\t\t\t\t\tsubEl.querySelectorAll(classesToSelector(params.totalClass)).forEach(totalEl => {\n\t\t\t\t\t\ttotalEl.textContent = params.formatFractionTotal(total);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tif (params.type === 'progressbar') {\n\t\t\t\t\tlet progressbarDirection;\n\t\t\t\t\tif (params.progressbarOpposite) {\n\t\t\t\t\t\tprogressbarDirection = swiper.isHorizontal() ? 'vertical' : 'horizontal';\n\t\t\t\t\t} else {\n\t\t\t\t\t\tprogressbarDirection = swiper.isHorizontal() ? 'horizontal' : 'vertical';\n\t\t\t\t\t}\n\t\t\t\t\tconst scale = (current + 1) / total;\n\t\t\t\t\tlet scaleX = 1;\n\t\t\t\t\tlet scaleY = 1;\n\t\t\t\t\tif (progressbarDirection === 'horizontal') {\n\t\t\t\t\t\tscaleX = scale;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tscaleY = scale;\n\t\t\t\t\t}\n\t\t\t\t\tsubEl.querySelectorAll(classesToSelector(params.progressbarFillClass)).forEach(progressEl => {\n\t\t\t\t\t\tprogressEl.style.transform = `translate3d(0,0,0) scaleX(${scaleX}) scaleY(${scaleY})`;\n\t\t\t\t\t\tprogressEl.style.transitionDuration = `${swiper.params.speed}ms`;\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tif (params.type === 'custom' && params.renderCustom) {\n\t\t\t\t\tsubEl.innerHTML = params.renderCustom(swiper, current + 1, total);\n\t\t\t\t\tif (subElIndex === 0) emit('paginationRender', subEl);\n\t\t\t\t} else {\n\t\t\t\t\tif (subElIndex === 0) emit('paginationRender', subEl);\n\t\t\t\t\temit('paginationUpdate', subEl);\n\t\t\t\t}\n\t\t\t\tif (swiper.params.watchOverflow && swiper.enabled) {\n\t\t\t\t\tsubEl.classList[swiper.isLocked ? 'add' : 'remove'](params.lockClass);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\tfunction render() {\n\t\t\t// Render Container\n\t\t\tconst params = swiper.params.pagination;\n\t\t\tif (isPaginationDisabled()) return;\n\t\t\tconst slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.grid && swiper.params.grid.rows > 1 ? swiper.slides.length / Math.ceil(swiper.params.grid.rows) : swiper.slides.length;\n\t\t\tlet el = swiper.pagination.el;\n\t\t\tel = makeElementsArray(el);\n\t\t\tlet paginationHTML = '';\n\t\t\tif (params.type === 'bullets') {\n\t\t\t\tlet numberOfBullets = swiper.params.loop ? Math.ceil(slidesLength / swiper.params.slidesPerGroup) : swiper.snapGrid.length;\n\t\t\t\tif (swiper.params.freeMode && swiper.params.freeMode.enabled && numberOfBullets > slidesLength) {\n\t\t\t\t\tnumberOfBullets = slidesLength;\n\t\t\t\t}\n\t\t\t\tfor (let i = 0; i < numberOfBullets; i += 1) {\n\t\t\t\t\tif (params.renderBullet) {\n\t\t\t\t\t\tpaginationHTML += params.renderBullet.call(swiper, i, params.bulletClass);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// prettier-ignore\n\t\t\t\t\t\tpaginationHTML += `<${params.bulletElement} ${swiper.isElement ? 'part=\"bullet\"' : ''} class=\"${params.bulletClass}\"></${params.bulletElement}>`;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (params.type === 'fraction') {\n\t\t\t\tif (params.renderFraction) {\n\t\t\t\t\tpaginationHTML = params.renderFraction.call(swiper, params.currentClass, params.totalClass);\n\t\t\t\t} else {\n\t\t\t\t\tpaginationHTML = `<span class=\"${params.currentClass}\"></span>` + ' / ' + `<span class=\"${params.totalClass}\"></span>`;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (params.type === 'progressbar') {\n\t\t\t\tif (params.renderProgressbar) {\n\t\t\t\t\tpaginationHTML = params.renderProgressbar.call(swiper, params.progressbarFillClass);\n\t\t\t\t} else {\n\t\t\t\t\tpaginationHTML = `<span class=\"${params.progressbarFillClass}\"></span>`;\n\t\t\t\t}\n\t\t\t}\n\t\t\tswiper.pagination.bullets = [];\n\t\t\tel.forEach(subEl => {\n\t\t\t\tif (params.type !== 'custom') {\n\t\t\t\t\tsubEl.innerHTML = paginationHTML || '';\n\t\t\t\t}\n\t\t\t\tif (params.type === 'bullets') {\n\t\t\t\t\tswiper.pagination.bullets.push(...subEl.querySelectorAll(classesToSelector(params.bulletClass)));\n\t\t\t\t}\n\t\t\t});\n\t\t\tif (params.type !== 'custom') {\n\t\t\t\temit('paginationRender', el[0]);\n\t\t\t}\n\t\t}\n\t\tfunction init() {\n\t\t\tswiper.params.pagination = createElementIfNotDefined(swiper, swiper.originalParams.pagination, swiper.params.pagination, {\n\t\t\t\tel: 'swiper-pagination'\n\t\t\t});\n\t\t\tconst params = swiper.params.pagination;\n\t\t\tif (!params.el) return;\n\t\t\tlet el;\n\t\t\tif (typeof params.el === 'string' && swiper.isElement) {\n\t\t\t\tel = swiper.el.querySelector(params.el);\n\t\t\t}\n\t\t\tif (!el && typeof params.el === 'string') {\n\t\t\t\tel = [...document.querySelectorAll(params.el)];\n\t\t\t}\n\t\t\tif (!el) {\n\t\t\t\tel = params.el;\n\t\t\t}\n\t\t\tif (!el || el.length === 0) return;\n\t\t\tif (swiper.params.uniqueNavElements && typeof params.el === 'string' && Array.isArray(el) && el.length > 1) {\n\t\t\t\tel = [...swiper.el.querySelectorAll(params.el)];\n\t\t\t\t// check if it belongs to another nested Swiper\n\t\t\t\tif (el.length > 1) {\n\t\t\t\t\tel = el.filter(subEl => {\n\t\t\t\t\t\tif (elementParents(subEl, '.swiper')[0] !== swiper.el) return false;\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t})[0];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (Array.isArray(el) && el.length === 1) el = el[0];\n\t\t\tObject.assign(swiper.pagination, {\n\t\t\t\tel\n\t\t\t});\n\t\t\tel = makeElementsArray(el);\n\t\t\tel.forEach(subEl => {\n\t\t\t\tif (params.type === 'bullets' && params.clickable) {\n\t\t\t\t\tsubEl.classList.add(...(params.clickableClass || '').split(' '));\n\t\t\t\t}\n\t\t\t\tsubEl.classList.add(params.modifierClass + params.type);\n\t\t\t\tsubEl.classList.add(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);\n\t\t\t\tif (params.type === 'bullets' && params.dynamicBullets) {\n\t\t\t\t\tsubEl.classList.add(`${params.modifierClass}${params.type}-dynamic`);\n\t\t\t\t\tdynamicBulletIndex = 0;\n\t\t\t\t\tif (params.dynamicMainBullets < 1) {\n\t\t\t\t\t\tparams.dynamicMainBullets = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (params.type === 'progressbar' && params.progressbarOpposite) {\n\t\t\t\t\tsubEl.classList.add(params.progressbarOppositeClass);\n\t\t\t\t}\n\t\t\t\tif (params.clickable) {\n\t\t\t\t\tsubEl.addEventListener('click', onBulletClick);\n\t\t\t\t}\n\t\t\t\tif (!swiper.enabled) {\n\t\t\t\t\tsubEl.classList.add(params.lockClass);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\tfunction destroy() {\n\t\t\tconst params = swiper.params.pagination;\n\t\t\tif (isPaginationDisabled()) return;\n\t\t\tlet el = swiper.pagination.el;\n\t\t\tif (el) {\n\t\t\t\tel = makeElementsArray(el);\n\t\t\t\tel.forEach(subEl => {\n\t\t\t\t\tsubEl.classList.remove(params.hiddenClass);\n\t\t\t\t\tsubEl.classList.remove(params.modifierClass + params.type);\n\t\t\t\t\tsubEl.classList.remove(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);\n\t\t\t\t\tif (params.clickable) {\n\t\t\t\t\t\tsubEl.classList.remove(...(params.clickableClass || '').split(' '));\n\t\t\t\t\t\tsubEl.removeEventListener('click', onBulletClick);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t\tif (swiper.pagination.bullets) swiper.pagination.bullets.forEach(subEl => subEl.classList.remove(...params.bulletActiveClass.split(' ')));\n\t\t}\n\t\ton('changeDirection', () => {\n\t\t\tif (!swiper.pagination || !swiper.pagination.el) return;\n\t\t\tconst params = swiper.params.pagination;\n\t\t\tlet {\n\t\t\t\tel\n\t\t\t} = swiper.pagination;\n\t\t\tel = makeElementsArray(el);\n\t\t\tel.forEach(subEl => {\n\t\t\t\tsubEl.classList.remove(params.horizontalClass, params.verticalClass);\n\t\t\t\tsubEl.classList.add(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);\n\t\t\t});\n\t\t});\n\t\ton('init', () => {\n\t\t\tif (swiper.params.pagination.enabled === false) {\n\t\t\t\t// eslint-disable-next-line\n\t\t\t\tdisable();\n\t\t\t} else {\n\t\t\t\tinit();\n\t\t\t\trender();\n\t\t\t\tupdate();\n\t\t\t}\n\t\t});\n\t\ton('activeIndexChange', () => {\n\t\t\tif (typeof swiper.snapIndex === 'undefined') {\n\t\t\t\tupdate();\n\t\t\t}\n\t\t});\n\t\ton('snapIndexChange', () => {\n\t\t\tupdate();\n\t\t});\n\t\ton('snapGridLengthChange', () => {\n\t\t\trender();\n\t\t\tupdate();\n\t\t});\n\t\ton('destroy', () => {\n\t\t\tdestroy();\n\t\t});\n\t\ton('enable disable', () => {\n\t\t\tlet {\n\t\t\t\tel\n\t\t\t} = swiper.pagination;\n\t\t\tif (el) {\n\t\t\t\tel = makeElementsArray(el);\n\t\t\t\tel.forEach(subEl => subEl.classList[swiper.enabled ? 'remove' : 'add'](swiper.params.pagination.lockClass));\n\t\t\t}\n\t\t});\n\t\ton('lock unlock', () => {\n\t\t\tupdate();\n\t\t});\n\t\ton('click', (_s, e) => {\n\t\t\tconst targetEl = e.target;\n\t\t\tconst el = makeElementsArray(swiper.pagination.el);\n\t\t\tif (swiper.params.pagination.el && swiper.params.pagination.hideOnClick && el && el.length > 0 && !targetEl.classList.contains(swiper.params.pagination.bulletClass)) {\n\t\t\t\tif (swiper.navigation && (swiper.navigation.nextEl && targetEl === swiper.navigation.nextEl || swiper.navigation.prevEl && targetEl === swiper.navigation.prevEl)) return;\n\t\t\t\tconst isHidden = el[0].classList.contains(swiper.params.pagination.hiddenClass);\n\t\t\t\tif (isHidden === true) {\n\t\t\t\t\temit('paginationShow');\n\t\t\t\t} else {\n\t\t\t\t\temit('paginationHide');\n\t\t\t\t}\n\t\t\t\tel.forEach(subEl => subEl.classList.toggle(swiper.params.pagination.hiddenClass));\n\t\t\t}\n\t\t});\n\t\tconst enable = () => {\n\t\t\tswiper.el.classList.remove(swiper.params.pagination.paginationDisabledClass);\n\t\t\tlet {\n\t\t\t\tel\n\t\t\t} = swiper.pagination;\n\t\t\tif (el) {\n\t\t\t\tel = makeElementsArray(el);\n\t\t\t\tel.forEach(subEl => subEl.classList.remove(swiper.params.pagination.paginationDisabledClass));\n\t\t\t}\n\t\t\tinit();\n\t\t\trender();\n\t\t\tupdate();\n\t\t};\n\t\tconst disable = () => {\n\t\t\tswiper.el.classList.add(swiper.params.pagination.paginationDisabledClass);\n\t\t\tlet {\n\t\t\t\tel\n\t\t\t} = swiper.pagination;\n\t\t\tif (el) {\n\t\t\t\tel = makeElementsArray(el);\n\t\t\t\tel.forEach(subEl => subEl.classList.add(swiper.params.pagination.paginationDisabledClass));\n\t\t\t}\n\t\t\tdestroy();\n\t\t};\n\t\tObject.assign(swiper.pagination, {\n\t\t\tenable,\n\t\t\tdisable,\n\t\t\trender,\n\t\t\tupdate,\n\t\t\tinit,\n\t\t\tdestroy\n\t\t});\n\t}\n\n\tfunction Scrollbar(_ref) {\n\t\tlet {\n\t\t\tswiper,\n\t\t\textendParams,\n\t\t\ton,\n\t\t\temit\n\t\t} = _ref;\n\t\tconst document = getDocument();\n\t\tlet isTouched = false;\n\t\tlet timeout = null;\n\t\tlet dragTimeout = null;\n\t\tlet dragStartPos;\n\t\tlet dragSize;\n\t\tlet trackSize;\n\t\tlet divider;\n\t\textendParams({\n\t\t\tscrollbar: {\n\t\t\t\tel: null,\n\t\t\t\tdragSize: 'auto',\n\t\t\t\thide: false,\n\t\t\t\tdraggable: false,\n\t\t\t\tsnapOnRelease: true,\n\t\t\t\tlockClass: 'swiper-scrollbar-lock',\n\t\t\t\tdragClass: 'swiper-scrollbar-drag',\n\t\t\t\tscrollbarDisabledClass: 'swiper-scrollbar-disabled',\n\t\t\t\thorizontalClass: `swiper-scrollbar-horizontal`,\n\t\t\t\tverticalClass: `swiper-scrollbar-vertical`\n\t\t\t}\n\t\t});\n\t\tswiper.scrollbar = {\n\t\t\tel: null,\n\t\t\tdragEl: null\n\t\t};\n\t\tfunction setTranslate() {\n\t\t\tif (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;\n\t\t\tconst {\n\t\t\t\tscrollbar,\n\t\t\t\trtlTranslate: rtl\n\t\t\t} = swiper;\n\t\t\tconst {\n\t\t\t\tdragEl,\n\t\t\t\tel\n\t\t\t} = scrollbar;\n\t\t\tconst params = swiper.params.scrollbar;\n\t\t\tconst progress = swiper.params.loop ? swiper.progressLoop : swiper.progress;\n\t\t\tlet newSize = dragSize;\n\t\t\tlet newPos = (trackSize - dragSize) * progress;\n\t\t\tif (rtl) {\n\t\t\t\tnewPos = -newPos;\n\t\t\t\tif (newPos > 0) {\n\t\t\t\t\tnewSize = dragSize - newPos;\n\t\t\t\t\tnewPos = 0;\n\t\t\t\t} else if (-newPos + dragSize > trackSize) {\n\t\t\t\t\tnewSize = trackSize + newPos;\n\t\t\t\t}\n\t\t\t} else if (newPos < 0) {\n\t\t\t\tnewSize = dragSize + newPos;\n\t\t\t\tnewPos = 0;\n\t\t\t} else if (newPos + dragSize > trackSize) {\n\t\t\t\tnewSize = trackSize - newPos;\n\t\t\t}\n\t\t\tif (swiper.isHorizontal()) {\n\t\t\t\tdragEl.style.transform = `translate3d(${newPos}px, 0, 0)`;\n\t\t\t\tdragEl.style.width = `${newSize}px`;\n\t\t\t} else {\n\t\t\t\tdragEl.style.transform = `translate3d(0px, ${newPos}px, 0)`;\n\t\t\t\tdragEl.style.height = `${newSize}px`;\n\t\t\t}\n\t\t\tif (params.hide) {\n\t\t\t\tclearTimeout(timeout);\n\t\t\t\tel.style.opacity = 1;\n\t\t\t\ttimeout = setTimeout(() => {\n\t\t\t\t\tel.style.opacity = 0;\n\t\t\t\t\tel.style.transitionDuration = '400ms';\n\t\t\t\t}, 1000);\n\t\t\t}\n\t\t}\n\t\tfunction setTransition(duration) {\n\t\t\tif (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;\n\t\t\tswiper.scrollbar.dragEl.style.transitionDuration = `${duration}ms`;\n\t\t}\n\t\tfunction updateSize() {\n\t\t\tif (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;\n\t\t\tconst {\n\t\t\t\tscrollbar\n\t\t\t} = swiper;\n\t\t\tconst {\n\t\t\t\tdragEl,\n\t\t\t\tel\n\t\t\t} = scrollbar;\n\t\t\tdragEl.style.width = '';\n\t\t\tdragEl.style.height = '';\n\t\t\ttrackSize = swiper.isHorizontal() ? el.offsetWidth : el.offsetHeight;\n\t\t\tdivider = swiper.size / (swiper.virtualSize + swiper.params.slidesOffsetBefore - (swiper.params.centeredSlides ? swiper.snapGrid[0] : 0));\n\t\t\tif (swiper.params.scrollbar.dragSize === 'auto') {\n\t\t\t\tdragSize = trackSize * divider;\n\t\t\t} else {\n\t\t\t\tdragSize = parseInt(swiper.params.scrollbar.dragSize, 10);\n\t\t\t}\n\t\t\tif (swiper.isHorizontal()) {\n\t\t\t\tdragEl.style.width = `${dragSize}px`;\n\t\t\t} else {\n\t\t\t\tdragEl.style.height = `${dragSize}px`;\n\t\t\t}\n\t\t\tif (divider >= 1) {\n\t\t\t\tel.style.display = 'none';\n\t\t\t} else {\n\t\t\t\tel.style.display = '';\n\t\t\t}\n\t\t\tif (swiper.params.scrollbar.hide) {\n\t\t\t\tel.style.opacity = 0;\n\t\t\t}\n\t\t\tif (swiper.params.watchOverflow && swiper.enabled) {\n\t\t\t\tscrollbar.el.classList[swiper.isLocked ? 'add' : 'remove'](swiper.params.scrollbar.lockClass);\n\t\t\t}\n\t\t}\n\t\tfunction getPointerPosition(e) {\n\t\t\treturn swiper.isHorizontal() ? e.clientX : e.clientY;\n\t\t}\n\t\tfunction setDragPosition(e) {\n\t\t\tconst {\n\t\t\t\tscrollbar,\n\t\t\t\trtlTranslate: rtl\n\t\t\t} = swiper;\n\t\t\tconst {\n\t\t\t\tel\n\t\t\t} = scrollbar;\n\t\t\tlet positionRatio;\n\t\t\tpositionRatio = (getPointerPosition(e) - elementOffset(el)[swiper.isHorizontal() ? 'left' : 'top'] - (dragStartPos !== null ? dragStartPos : dragSize / 2)) / (trackSize - dragSize);\n\t\t\tpositionRatio = Math.max(Math.min(positionRatio, 1), 0);\n\t\t\tif (rtl) {\n\t\t\t\tpositionRatio = 1 - positionRatio;\n\t\t\t}\n\t\t\tconst position = swiper.minTranslate() + (swiper.maxTranslate() - swiper.minTranslate()) * positionRatio;\n\t\t\tswiper.updateProgress(position);\n\t\t\tswiper.setTranslate(position);\n\t\t\tswiper.updateActiveIndex();\n\t\t\tswiper.updateSlidesClasses();\n\t\t}\n\t\tfunction onDragStart(e) {\n\t\t\tconst params = swiper.params.scrollbar;\n\t\t\tconst {\n\t\t\t\tscrollbar,\n\t\t\t\twrapperEl\n\t\t\t} = swiper;\n\t\t\tconst {\n\t\t\t\tel,\n\t\t\t\tdragEl\n\t\t\t} = scrollbar;\n\t\t\tisTouched = true;\n\t\t\tdragStartPos = e.target === dragEl ? getPointerPosition(e) - e.target.getBoundingClientRect()[swiper.isHorizontal() ? 'left' : 'top'] : null;\n\t\t\te.preventDefault();\n\t\t\te.stopPropagation();\n\t\t\twrapperEl.style.transitionDuration = '100ms';\n\t\t\tdragEl.style.transitionDuration = '100ms';\n\t\t\tsetDragPosition(e);\n\t\t\tclearTimeout(dragTimeout);\n\t\t\tel.style.transitionDuration = '0ms';\n\t\t\tif (params.hide) {\n\t\t\t\tel.style.opacity = 1;\n\t\t\t}\n\t\t\tif (swiper.params.cssMode) {\n\t\t\t\tswiper.wrapperEl.style['scroll-snap-type'] = 'none';\n\t\t\t}\n\t\t\temit('scrollbarDragStart', e);\n\t\t}\n\t\tfunction onDragMove(e) {\n\t\t\tconst {\n\t\t\t\tscrollbar,\n\t\t\t\twrapperEl\n\t\t\t} = swiper;\n\t\t\tconst {\n\t\t\t\tel,\n\t\t\t\tdragEl\n\t\t\t} = scrollbar;\n\t\t\tif (!isTouched) return;\n\t\t\tif (e.preventDefault && e.cancelable) e.preventDefault(); else e.returnValue = false;\n\t\t\tsetDragPosition(e);\n\t\t\twrapperEl.style.transitionDuration = '0ms';\n\t\t\tel.style.transitionDuration = '0ms';\n\t\t\tdragEl.style.transitionDuration = '0ms';\n\t\t\temit('scrollbarDragMove', e);\n\t\t}\n\t\tfunction onDragEnd(e) {\n\t\t\tconst params = swiper.params.scrollbar;\n\t\t\tconst {\n\t\t\t\tscrollbar,\n\t\t\t\twrapperEl\n\t\t\t} = swiper;\n\t\t\tconst {\n\t\t\t\tel\n\t\t\t} = scrollbar;\n\t\t\tif (!isTouched) return;\n\t\t\tisTouched = false;\n\t\t\tif (swiper.params.cssMode) {\n\t\t\t\tswiper.wrapperEl.style['scroll-snap-type'] = '';\n\t\t\t\twrapperEl.style.transitionDuration = '';\n\t\t\t}\n\t\t\tif (params.hide) {\n\t\t\t\tclearTimeout(dragTimeout);\n\t\t\t\tdragTimeout = nextTick(() => {\n\t\t\t\t\tel.style.opacity = 0;\n\t\t\t\t\tel.style.transitionDuration = '400ms';\n\t\t\t\t}, 1000);\n\t\t\t}\n\t\t\temit('scrollbarDragEnd', e);\n\t\t\tif (params.snapOnRelease) {\n\t\t\t\tswiper.slideToClosest();\n\t\t\t}\n\t\t}\n\t\tfunction events(method) {\n\t\t\tconst {\n\t\t\t\tscrollbar,\n\t\t\t\tparams\n\t\t\t} = swiper;\n\t\t\tconst el = scrollbar.el;\n\t\t\tif (!el) return;\n\t\t\tconst target = el;\n\t\t\tconst activeListener = params.passiveListeners ? {\n\t\t\t\tpassive: false,\n\t\t\t\tcapture: false\n\t\t\t} : false;\n\t\t\tconst passiveListener = params.passiveListeners ? {\n\t\t\t\tpassive: true,\n\t\t\t\tcapture: false\n\t\t\t} : false;\n\t\t\tif (!target) return;\n\t\t\tconst eventMethod = method === 'on' ? 'addEventListener' : 'removeEventListener';\n\t\t\ttarget[eventMethod]('pointerdown', onDragStart, activeListener);\n\t\t\tdocument[eventMethod]('pointermove', onDragMove, activeListener);\n\t\t\tdocument[eventMethod]('pointerup', onDragEnd, passiveListener);\n\t\t}\n\t\tfunction enableDraggable() {\n\t\t\tif (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;\n\t\t\tevents('on');\n\t\t}\n\t\tfunction disableDraggable() {\n\t\t\tif (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;\n\t\t\tevents('off');\n\t\t}\n\t\tfunction init() {\n\t\t\tconst {\n\t\t\t\tscrollbar,\n\t\t\t\tel: swiperEl\n\t\t\t} = swiper;\n\t\t\tswiper.params.scrollbar = createElementIfNotDefined(swiper, swiper.originalParams.scrollbar, swiper.params.scrollbar, {\n\t\t\t\tel: 'swiper-scrollbar'\n\t\t\t});\n\t\t\tconst params = swiper.params.scrollbar;\n\t\t\tif (!params.el) return;\n\t\t\tlet el;\n\t\t\tif (typeof params.el === 'string' && swiper.isElement) {\n\t\t\t\tel = swiper.el.querySelector(params.el);\n\t\t\t}\n\t\t\tif (!el && typeof params.el === 'string') {\n\t\t\t\tel = document.querySelectorAll(params.el);\n\t\t\t\tif (!el.length) return;\n\t\t\t} else if (!el) {\n\t\t\t\tel = params.el;\n\t\t\t}\n\t\t\tif (swiper.params.uniqueNavElements && typeof params.el === 'string' && el.length > 1 && swiperEl.querySelectorAll(params.el).length === 1) {\n\t\t\t\tel = swiperEl.querySelector(params.el);\n\t\t\t}\n\t\t\tif (el.length > 0) el = el[0];\n\t\t\tel.classList.add(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);\n\t\t\tlet dragEl;\n\t\t\tif (el) {\n\t\t\t\tdragEl = el.querySelector(classesToSelector(swiper.params.scrollbar.dragClass));\n\t\t\t\tif (!dragEl) {\n\t\t\t\t\tdragEl = createElement('div', swiper.params.scrollbar.dragClass);\n\t\t\t\t\tel.append(dragEl);\n\t\t\t\t}\n\t\t\t}\n\t\t\tObject.assign(scrollbar, {\n\t\t\t\tel,\n\t\t\t\tdragEl\n\t\t\t});\n\t\t\tif (params.draggable) {\n\t\t\t\tenableDraggable();\n\t\t\t}\n\t\t\tif (el) {\n\t\t\t\tel.classList[swiper.enabled ? 'remove' : 'add'](...classesToTokens(swiper.params.scrollbar.lockClass));\n\t\t\t}\n\t\t}\n\t\tfunction destroy() {\n\t\t\tconst params = swiper.params.scrollbar;\n\t\t\tconst el = swiper.scrollbar.el;\n\t\t\tif (el) {\n\t\t\t\tel.classList.remove(...classesToTokens(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass));\n\t\t\t}\n\t\t\tdisableDraggable();\n\t\t}\n\t\ton('changeDirection', () => {\n\t\t\tif (!swiper.scrollbar || !swiper.scrollbar.el) return;\n\t\t\tconst params = swiper.params.scrollbar;\n\t\t\tlet {\n\t\t\t\tel\n\t\t\t} = swiper.scrollbar;\n\t\t\tel = makeElementsArray(el);\n\t\t\tel.forEach(subEl => {\n\t\t\t\tsubEl.classList.remove(params.horizontalClass, params.verticalClass);\n\t\t\t\tsubEl.classList.add(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);\n\t\t\t});\n\t\t});\n\t\ton('init', () => {\n\t\t\tif (swiper.params.scrollbar.enabled === false) {\n\t\t\t\t// eslint-disable-next-line\n\t\t\t\tdisable();\n\t\t\t} else {\n\t\t\t\tinit();\n\t\t\t\tupdateSize();\n\t\t\t\tsetTranslate();\n\t\t\t}\n\t\t});\n\t\ton('update resize observerUpdate lock unlock changeDirection', () => {\n\t\t\tupdateSize();\n\t\t});\n\t\ton('setTranslate', () => {\n\t\t\tsetTranslate();\n\t\t});\n\t\ton('setTransition', (_s, duration) => {\n\t\t\tsetTransition(duration);\n\t\t});\n\t\ton('enable disable', () => {\n\t\t\tconst {\n\t\t\t\tel\n\t\t\t} = swiper.scrollbar;\n\t\t\tif (el) {\n\t\t\t\tel.classList[swiper.enabled ? 'remove' : 'add'](...classesToTokens(swiper.params.scrollbar.lockClass));\n\t\t\t}\n\t\t});\n\t\ton('destroy', () => {\n\t\t\tdestroy();\n\t\t});\n\t\tconst enable = () => {\n\t\t\tswiper.el.classList.remove(...classesToTokens(swiper.params.scrollbar.scrollbarDisabledClass));\n\t\t\tif (swiper.scrollbar.el) {\n\t\t\t\tswiper.scrollbar.el.classList.remove(...classesToTokens(swiper.params.scrollbar.scrollbarDisabledClass));\n\t\t\t}\n\t\t\tinit();\n\t\t\tupdateSize();\n\t\t\tsetTranslate();\n\t\t};\n\t\tconst disable = () => {\n\t\t\tswiper.el.classList.add(...classesToTokens(swiper.params.scrollbar.scrollbarDisabledClass));\n\t\t\tif (swiper.scrollbar.el) {\n\t\t\t\tswiper.scrollbar.el.classList.add(...classesToTokens(swiper.params.scrollbar.scrollbarDisabledClass));\n\t\t\t}\n\t\t\tdestroy();\n\t\t};\n\t\tObject.assign(swiper.scrollbar, {\n\t\t\tenable,\n\t\t\tdisable,\n\t\t\tupdateSize,\n\t\t\tsetTranslate,\n\t\t\tinit,\n\t\t\tdestroy\n\t\t});\n\t}\n\n\tfunction Parallax(_ref) {\n\t\tlet {\n\t\t\tswiper,\n\t\t\textendParams,\n\t\t\ton\n\t\t} = _ref;\n\t\textendParams({\n\t\t\tparallax: {\n\t\t\t\tenabled: false\n\t\t\t}\n\t\t});\n\t\tconst elementsSelector = '[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]';\n\t\tconst setTransform = (el, progress) => {\n\t\t\tconst {\n\t\t\t\trtl\n\t\t\t} = swiper;\n\t\t\tconst rtlFactor = rtl ? -1 : 1;\n\t\t\tconst p = el.getAttribute('data-swiper-parallax') || '0';\n\t\t\tlet x = el.getAttribute('data-swiper-parallax-x');\n\t\t\tlet y = el.getAttribute('data-swiper-parallax-y');\n\t\t\tconst scale = el.getAttribute('data-swiper-parallax-scale');\n\t\t\tconst opacity = el.getAttribute('data-swiper-parallax-opacity');\n\t\t\tconst rotate = el.getAttribute('data-swiper-parallax-rotate');\n\t\t\tif (x || y) {\n\t\t\t\tx = x || '0';\n\t\t\t\ty = y || '0';\n\t\t\t} else if (swiper.isHorizontal()) {\n\t\t\t\tx = p;\n\t\t\t\ty = '0';\n\t\t\t} else {\n\t\t\t\ty = p;\n\t\t\t\tx = '0';\n\t\t\t}\n\t\t\tif (x.indexOf('%') >= 0) {\n\t\t\t\tx = `${parseInt(x, 10) * progress * rtlFactor}%`;\n\t\t\t} else {\n\t\t\t\tx = `${x * progress * rtlFactor}px`;\n\t\t\t}\n\t\t\tif (y.indexOf('%') >= 0) {\n\t\t\t\ty = `${parseInt(y, 10) * progress}%`;\n\t\t\t} else {\n\t\t\t\ty = `${y * progress}px`;\n\t\t\t}\n\t\t\tif (typeof opacity !== 'undefined' && opacity !== null) {\n\t\t\t\tconst currentOpacity = opacity - (opacity - 1) * (1 - Math.abs(progress));\n\t\t\t\tel.style.opacity = currentOpacity;\n\t\t\t}\n\t\t\tlet transform = `translate3d(${x}, ${y}, 0px)`;\n\t\t\tif (typeof scale !== 'undefined' && scale !== null) {\n\t\t\t\tconst currentScale = scale - (scale - 1) * (1 - Math.abs(progress));\n\t\t\t\ttransform += ` scale(${currentScale})`;\n\t\t\t}\n\t\t\tif (rotate && typeof rotate !== 'undefined' && rotate !== null) {\n\t\t\t\tconst currentRotate = rotate * progress * -1;\n\t\t\t\ttransform += ` rotate(${currentRotate}deg)`;\n\t\t\t}\n\t\t\tel.style.transform = transform;\n\t\t};\n\t\tconst setTranslate = () => {\n\t\t\tconst {\n\t\t\t\tel,\n\t\t\t\tslides,\n\t\t\t\tprogress,\n\t\t\t\tsnapGrid,\n\t\t\t\tisElement\n\t\t\t} = swiper;\n\t\t\tconst elements = elementChildren(el, elementsSelector);\n\t\t\tif (swiper.isElement) {\n\t\t\t\telements.push(...elementChildren(swiper.hostEl, elementsSelector));\n\t\t\t}\n\t\t\telements.forEach(subEl => {\n\t\t\t\tsetTransform(subEl, progress);\n\t\t\t});\n\t\t\tslides.forEach((slideEl, slideIndex) => {\n\t\t\t\tlet slideProgress = slideEl.progress;\n\t\t\t\tif (swiper.params.slidesPerGroup > 1 && swiper.params.slidesPerView !== 'auto') {\n\t\t\t\t\tslideProgress += Math.ceil(slideIndex / 2) - progress * (snapGrid.length - 1);\n\t\t\t\t}\n\t\t\t\tslideProgress = Math.min(Math.max(slideProgress, -1), 1);\n\t\t\t\tslideEl.querySelectorAll(`${elementsSelector}, [data-swiper-parallax-rotate]`).forEach(subEl => {\n\t\t\t\t\tsetTransform(subEl, slideProgress);\n\t\t\t\t});\n\t\t\t});\n\t\t};\n\t\tconst setTransition = function (duration) {\n\t\t\tif (duration === void 0) {\n\t\t\t\tduration = swiper.params.speed;\n\t\t\t}\n\t\t\tconst {\n\t\t\t\tel,\n\t\t\t\thostEl\n\t\t\t} = swiper;\n\t\t\tconst elements = [...el.querySelectorAll(elementsSelector)];\n\t\t\tif (swiper.isElement) {\n\t\t\t\telements.push(...hostEl.querySelectorAll(elementsSelector));\n\t\t\t}\n\t\t\telements.forEach(parallaxEl => {\n\t\t\t\tlet parallaxDuration = parseInt(parallaxEl.getAttribute('data-swiper-parallax-duration'), 10) || duration;\n\t\t\t\tif (duration === 0) parallaxDuration = 0;\n\t\t\t\tparallaxEl.style.transitionDuration = `${parallaxDuration}ms`;\n\t\t\t});\n\t\t};\n\t\ton('beforeInit', () => {\n\t\t\tif (!swiper.params.parallax.enabled) return;\n\t\t\tswiper.params.watchSlidesProgress = true;\n\t\t\tswiper.originalParams.watchSlidesProgress = true;\n\t\t});\n\t\ton('init', () => {\n\t\t\tif (!swiper.params.parallax.enabled) return;\n\t\t\tsetTranslate();\n\t\t});\n\t\ton('setTranslate', () => {\n\t\t\tif (!swiper.params.parallax.enabled) return;\n\t\t\tsetTranslate();\n\t\t});\n\t\ton('setTransition', (_swiper, duration) => {\n\t\t\tif (!swiper.params.parallax.enabled) return;\n\t\t\tsetTransition(duration);\n\t\t});\n\t}\n\n\tfunction Zoom(_ref) {\n\t\tlet {\n\t\t\tswiper,\n\t\t\textendParams,\n\t\t\ton,\n\t\t\temit\n\t\t} = _ref;\n\t\tconst window = getWindow();\n\t\textendParams({\n\t\t\tzoom: {\n\t\t\t\tenabled: false,\n\t\t\t\tlimitToOriginalSize: false,\n\t\t\t\tmaxRatio: 3,\n\t\t\t\tminRatio: 1,\n\t\t\t\ttoggle: true,\n\t\t\t\tcontainerClass: 'swiper-zoom-container',\n\t\t\t\tzoomedSlideClass: 'swiper-slide-zoomed'\n\t\t\t}\n\t\t});\n\t\tswiper.zoom = {\n\t\t\tenabled: false\n\t\t};\n\t\tlet currentScale = 1;\n\t\tlet isScaling = false;\n\t\tlet fakeGestureTouched;\n\t\tlet fakeGestureMoved;\n\t\tconst evCache = [];\n\t\tconst gesture = {\n\t\t\toriginX: 0,\n\t\t\toriginY: 0,\n\t\t\tslideEl: undefined,\n\t\t\tslideWidth: undefined,\n\t\t\tslideHeight: undefined,\n\t\t\timageEl: undefined,\n\t\t\timageWrapEl: undefined,\n\t\t\tmaxRatio: 3\n\t\t};\n\t\tconst image = {\n\t\t\tisTouched: undefined,\n\t\t\tisMoved: undefined,\n\t\t\tcurrentX: undefined,\n\t\t\tcurrentY: undefined,\n\t\t\tminX: undefined,\n\t\t\tminY: undefined,\n\t\t\tmaxX: undefined,\n\t\t\tmaxY: undefined,\n\t\t\twidth: undefined,\n\t\t\theight: undefined,\n\t\t\tstartX: undefined,\n\t\t\tstartY: undefined,\n\t\t\ttouchesStart: {},\n\t\t\ttouchesCurrent: {}\n\t\t};\n\t\tconst velocity = {\n\t\t\tx: undefined,\n\t\t\ty: undefined,\n\t\t\tprevPositionX: undefined,\n\t\t\tprevPositionY: undefined,\n\t\t\tprevTime: undefined\n\t\t};\n\t\tlet scale = 1;\n\t\tObject.defineProperty(swiper.zoom, 'scale', {\n\t\t\tget() {\n\t\t\t\treturn scale;\n\t\t\t},\n\t\t\tset(value) {\n\t\t\t\tif (scale !== value) {\n\t\t\t\t\tconst imageEl = gesture.imageEl;\n\t\t\t\t\tconst slideEl = gesture.slideEl;\n\t\t\t\t\temit('zoomChange', value, imageEl, slideEl);\n\t\t\t\t}\n\t\t\t\tscale = value;\n\t\t\t}\n\t\t});\n\t\tfunction getDistanceBetweenTouches() {\n\t\t\tif (evCache.length < 2) return 1;\n\t\t\tconst x1 = evCache[0].pageX;\n\t\t\tconst y1 = evCache[0].pageY;\n\t\t\tconst x2 = evCache[1].pageX;\n\t\t\tconst y2 = evCache[1].pageY;\n\t\t\tconst distance = Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);\n\t\t\treturn distance;\n\t\t}\n\t\tfunction getMaxRatio() {\n\t\t\tconst params = swiper.params.zoom;\n\t\t\tconst maxRatio = gesture.imageWrapEl.getAttribute('data-swiper-zoom') || params.maxRatio;\n\t\t\tif (params.limitToOriginalSize && gesture.imageEl && gesture.imageEl.naturalWidth) {\n\t\t\t\tconst imageMaxRatio = gesture.imageEl.naturalWidth / gesture.imageEl.offsetWidth;\n\t\t\t\treturn Math.min(imageMaxRatio, maxRatio);\n\t\t\t}\n\t\t\treturn maxRatio;\n\t\t}\n\t\tfunction getScaleOrigin() {\n\t\t\tif (evCache.length < 2) return {\n\t\t\t\tx: null,\n\t\t\t\ty: null\n\t\t\t};\n\t\t\tconst box = gesture.imageEl.getBoundingClientRect();\n\t\t\treturn [(evCache[0].pageX + (evCache[1].pageX - evCache[0].pageX) / 2 - box.x - window.scrollX) / currentScale, (evCache[0].pageY + (evCache[1].pageY - evCache[0].pageY) / 2 - box.y - window.scrollY) / currentScale];\n\t\t}\n\t\tfunction getSlideSelector() {\n\t\t\treturn swiper.isElement ? `swiper-slide` : `.${swiper.params.slideClass}`;\n\t\t}\n\t\tfunction eventWithinSlide(e) {\n\t\t\tconst slideSelector = getSlideSelector();\n\t\t\tif (e.target.matches(slideSelector)) return true;\n\t\t\tif (swiper.slides.filter(slideEl => slideEl.contains(e.target)).length > 0) return true;\n\t\t\treturn false;\n\t\t}\n\t\tfunction eventWithinZoomContainer(e) {\n\t\t\tconst selector = `.${swiper.params.zoom.containerClass}`;\n\t\t\tif (e.target.matches(selector)) return true;\n\t\t\tif ([...swiper.hostEl.querySelectorAll(selector)].filter(containerEl => containerEl.contains(e.target)).length > 0) return true;\n\t\t\treturn false;\n\t\t}\n\n\t\t// Events\n\t\tfunction onGestureStart(e) {\n\t\t\tif (e.pointerType === 'mouse') {\n\t\t\t\tevCache.splice(0, evCache.length);\n\t\t\t}\n\t\t\tif (!eventWithinSlide(e)) return;\n\t\t\tconst params = swiper.params.zoom;\n\t\t\tfakeGestureTouched = false;\n\t\t\tfakeGestureMoved = false;\n\t\t\tevCache.push(e);\n\t\t\tif (evCache.length < 2) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfakeGestureTouched = true;\n\t\t\tgesture.scaleStart = getDistanceBetweenTouches();\n\t\t\tif (!gesture.slideEl) {\n\t\t\t\tgesture.slideEl = e.target.closest(`.${swiper.params.slideClass}, swiper-slide`);\n\t\t\t\tif (!gesture.slideEl) gesture.slideEl = swiper.slides[swiper.activeIndex];\n\t\t\t\tlet imageEl = gesture.slideEl.querySelector(`.${params.containerClass}`);\n\t\t\t\tif (imageEl) {\n\t\t\t\t\timageEl = imageEl.querySelectorAll('picture, img, svg, canvas, .swiper-zoom-target')[0];\n\t\t\t\t}\n\t\t\t\tgesture.imageEl = imageEl;\n\t\t\t\tif (imageEl) {\n\t\t\t\t\tgesture.imageWrapEl = elementParents(gesture.imageEl, `.${params.containerClass}`)[0];\n\t\t\t\t} else {\n\t\t\t\t\tgesture.imageWrapEl = undefined;\n\t\t\t\t}\n\t\t\t\tif (!gesture.imageWrapEl) {\n\t\t\t\t\tgesture.imageEl = undefined;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tgesture.maxRatio = getMaxRatio();\n\t\t\t}\n\t\t\tif (gesture.imageEl) {\n\t\t\t\tconst [originX, originY] = getScaleOrigin();\n\t\t\t\tgesture.originX = originX;\n\t\t\t\tgesture.originY = originY;\n\t\t\t\tgesture.imageEl.style.transitionDuration = '0ms';\n\t\t\t}\n\t\t\tisScaling = true;\n\t\t}\n\t\tfunction onGestureChange(e) {\n\t\t\tif (!eventWithinSlide(e)) return;\n\t\t\tconst params = swiper.params.zoom;\n\t\t\tconst zoom = swiper.zoom;\n\t\t\tconst pointerIndex = evCache.findIndex(cachedEv => cachedEv.pointerId === e.pointerId);\n\t\t\tif (pointerIndex >= 0) evCache[pointerIndex] = e;\n\t\t\tif (evCache.length < 2) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfakeGestureMoved = true;\n\t\t\tgesture.scaleMove = getDistanceBetweenTouches();\n\t\t\tif (!gesture.imageEl) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tzoom.scale = gesture.scaleMove / gesture.scaleStart * currentScale;\n\t\t\tif (zoom.scale > gesture.maxRatio) {\n\t\t\t\tzoom.scale = gesture.maxRatio - 1 + (zoom.scale - gesture.maxRatio + 1) ** 0.5;\n\t\t\t}\n\t\t\tif (zoom.scale < params.minRatio) {\n\t\t\t\tzoom.scale = params.minRatio + 1 - (params.minRatio - zoom.scale + 1) ** 0.5;\n\t\t\t}\n\t\t\tgesture.imageEl.style.transform = `translate3d(0,0,0) scale(${zoom.scale})`;\n\t\t}\n\t\tfunction onGestureEnd(e) {\n\t\t\tif (!eventWithinSlide(e)) return;\n\t\t\tif (e.pointerType === 'mouse' && e.type === 'pointerout') return;\n\t\t\tconst params = swiper.params.zoom;\n\t\t\tconst zoom = swiper.zoom;\n\t\t\tconst pointerIndex = evCache.findIndex(cachedEv => cachedEv.pointerId === e.pointerId);\n\t\t\tif (pointerIndex >= 0) evCache.splice(pointerIndex, 1);\n\t\t\tif (!fakeGestureTouched || !fakeGestureMoved) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfakeGestureTouched = false;\n\t\t\tfakeGestureMoved = false;\n\t\t\tif (!gesture.imageEl) return;\n\t\t\tzoom.scale = Math.max(Math.min(zoom.scale, gesture.maxRatio), params.minRatio);\n\t\t\tgesture.imageEl.style.transitionDuration = `${swiper.params.speed}ms`;\n\t\t\tgesture.imageEl.style.transform = `translate3d(0,0,0) scale(${zoom.scale})`;\n\t\t\tcurrentScale = zoom.scale;\n\t\t\tisScaling = false;\n\t\t\tif (zoom.scale > 1 && gesture.slideEl) {\n\t\t\t\tgesture.slideEl.classList.add(`${params.zoomedSlideClass}`);\n\t\t\t} else if (zoom.scale <= 1 && gesture.slideEl) {\n\t\t\t\tgesture.slideEl.classList.remove(`${params.zoomedSlideClass}`);\n\t\t\t}\n\t\t\tif (zoom.scale === 1) {\n\t\t\t\tgesture.originX = 0;\n\t\t\t\tgesture.originY = 0;\n\t\t\t\tgesture.slideEl = undefined;\n\t\t\t}\n\t\t}\n\t\tlet allowTouchMoveTimeout;\n\t\tfunction allowTouchMove() {\n\t\t\tswiper.touchEventsData.preventTouchMoveFromPointerMove = false;\n\t\t}\n\t\tfunction preventTouchMove() {\n\t\t\tclearTimeout(allowTouchMoveTimeout);\n\t\t\tswiper.touchEventsData.preventTouchMoveFromPointerMove = true;\n\t\t\tallowTouchMoveTimeout = setTimeout(() => {\n\t\t\t\tallowTouchMove();\n\t\t\t});\n\t\t}\n\t\tfunction onTouchStart(e) {\n\t\t\tconst device = swiper.device;\n\t\t\tif (!gesture.imageEl) return;\n\t\t\tif (image.isTouched) return;\n\t\t\tif (device.android && e.cancelable) e.preventDefault();\n\t\t\timage.isTouched = true;\n\t\t\tconst event = evCache.length > 0 ? evCache[0] : e;\n\t\t\timage.touchesStart.x = event.pageX;\n\t\t\timage.touchesStart.y = event.pageY;\n\t\t}\n\t\tfunction onTouchMove(e) {\n\t\t\tif (!eventWithinSlide(e) || !eventWithinZoomContainer(e)) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tconst zoom = swiper.zoom;\n\t\t\tif (!gesture.imageEl) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (!image.isTouched || !gesture.slideEl) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (!image.isMoved) {\n\t\t\t\timage.width = gesture.imageEl.offsetWidth || gesture.imageEl.clientWidth;\n\t\t\t\timage.height = gesture.imageEl.offsetHeight || gesture.imageEl.clientHeight;\n\t\t\t\timage.startX = getTranslate(gesture.imageWrapEl, 'x') || 0;\n\t\t\t\timage.startY = getTranslate(gesture.imageWrapEl, 'y') || 0;\n\t\t\t\tgesture.slideWidth = gesture.slideEl.offsetWidth;\n\t\t\t\tgesture.slideHeight = gesture.slideEl.offsetHeight;\n\t\t\t\tgesture.imageWrapEl.style.transitionDuration = '0ms';\n\t\t\t}\n\t\t\t// Define if we need image drag\n\t\t\tconst scaledWidth = image.width * zoom.scale;\n\t\t\tconst scaledHeight = image.height * zoom.scale;\n\t\t\timage.minX = Math.min(gesture.slideWidth / 2 - scaledWidth / 2, 0);\n\t\t\timage.maxX = -image.minX;\n\t\t\timage.minY = Math.min(gesture.slideHeight / 2 - scaledHeight / 2, 0);\n\t\t\timage.maxY = -image.minY;\n\t\t\timage.touchesCurrent.x = evCache.length > 0 ? evCache[0].pageX : e.pageX;\n\t\t\timage.touchesCurrent.y = evCache.length > 0 ? evCache[0].pageY : e.pageY;\n\t\t\tconst touchesDiff = Math.max(Math.abs(image.touchesCurrent.x - image.touchesStart.x), Math.abs(image.touchesCurrent.y - image.touchesStart.y));\n\t\t\tif (touchesDiff > 5) {\n\t\t\t\tswiper.allowClick = false;\n\t\t\t}\n\t\t\tif (!image.isMoved && !isScaling) {\n\t\t\t\tif (swiper.isHorizontal() && (Math.floor(image.minX) === Math.floor(image.startX) && image.touchesCurrent.x < image.touchesStart.x || Math.floor(image.maxX) === Math.floor(image.startX) && image.touchesCurrent.x > image.touchesStart.x)) {\n\t\t\t\t\timage.isTouched = false;\n\t\t\t\t\tallowTouchMove();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (!swiper.isHorizontal() && (Math.floor(image.minY) === Math.floor(image.startY) && image.touchesCurrent.y < image.touchesStart.y || Math.floor(image.maxY) === Math.floor(image.startY) && image.touchesCurrent.y > image.touchesStart.y)) {\n\t\t\t\t\timage.isTouched = false;\n\t\t\t\t\tallowTouchMove();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (e.cancelable) {\n\t\t\t\te.preventDefault();\n\t\t\t}\n\t\t\te.stopPropagation();\n\t\t\tpreventTouchMove();\n\t\t\timage.isMoved = true;\n\t\t\tconst scaleRatio = (zoom.scale - currentScale) / (gesture.maxRatio - swiper.params.zoom.minRatio);\n\t\t\tconst {\n\t\t\t\toriginX,\n\t\t\t\toriginY\n\t\t\t} = gesture;\n\t\t\timage.currentX = image.touchesCurrent.x - image.touchesStart.x + image.startX + scaleRatio * (image.width - originX * 2);\n\t\t\timage.currentY = image.touchesCurrent.y - image.touchesStart.y + image.startY + scaleRatio * (image.height - originY * 2);\n\t\t\tif (image.currentX < image.minX) {\n\t\t\t\timage.currentX = image.minX + 1 - (image.minX - image.currentX + 1) ** 0.8;\n\t\t\t}\n\t\t\tif (image.currentX > image.maxX) {\n\t\t\t\timage.currentX = image.maxX - 1 + (image.currentX - image.maxX + 1) ** 0.8;\n\t\t\t}\n\t\t\tif (image.currentY < image.minY) {\n\t\t\t\timage.currentY = image.minY + 1 - (image.minY - image.currentY + 1) ** 0.8;\n\t\t\t}\n\t\t\tif (image.currentY > image.maxY) {\n\t\t\t\timage.currentY = image.maxY - 1 + (image.currentY - image.maxY + 1) ** 0.8;\n\t\t\t}\n\n\t\t\t// Velocity\n\t\t\tif (!velocity.prevPositionX) velocity.prevPositionX = image.touchesCurrent.x;\n\t\t\tif (!velocity.prevPositionY) velocity.prevPositionY = image.touchesCurrent.y;\n\t\t\tif (!velocity.prevTime) velocity.prevTime = Date.now();\n\t\t\tvelocity.x = (image.touchesCurrent.x - velocity.prevPositionX) / (Date.now() - velocity.prevTime) / 2;\n\t\t\tvelocity.y = (image.touchesCurrent.y - velocity.prevPositionY) / (Date.now() - velocity.prevTime) / 2;\n\t\t\tif (Math.abs(image.touchesCurrent.x - velocity.prevPositionX) < 2) velocity.x = 0;\n\t\t\tif (Math.abs(image.touchesCurrent.y - velocity.prevPositionY) < 2) velocity.y = 0;\n\t\t\tvelocity.prevPositionX = image.touchesCurrent.x;\n\t\t\tvelocity.prevPositionY = image.touchesCurrent.y;\n\t\t\tvelocity.prevTime = Date.now();\n\t\t\tgesture.imageWrapEl.style.transform = `translate3d(${image.currentX}px, ${image.currentY}px,0)`;\n\t\t}\n\t\tfunction onTouchEnd() {\n\t\t\tconst zoom = swiper.zoom;\n\t\t\tif (!gesture.imageEl) return;\n\t\t\tif (!image.isTouched || !image.isMoved) {\n\t\t\t\timage.isTouched = false;\n\t\t\t\timage.isMoved = false;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\timage.isTouched = false;\n\t\t\timage.isMoved = false;\n\t\t\tlet momentumDurationX = 300;\n\t\t\tlet momentumDurationY = 300;\n\t\t\tconst momentumDistanceX = velocity.x * momentumDurationX;\n\t\t\tconst newPositionX = image.currentX + momentumDistanceX;\n\t\t\tconst momentumDistanceY = velocity.y * momentumDurationY;\n\t\t\tconst newPositionY = image.currentY + momentumDistanceY;\n\n\t\t\t// Fix duration\n\t\t\tif (velocity.x !== 0) momentumDurationX = Math.abs((newPositionX - image.currentX) / velocity.x);\n\t\t\tif (velocity.y !== 0) momentumDurationY = Math.abs((newPositionY - image.currentY) / velocity.y);\n\t\t\tconst momentumDuration = Math.max(momentumDurationX, momentumDurationY);\n\t\t\timage.currentX = newPositionX;\n\t\t\timage.currentY = newPositionY;\n\t\t\t// Define if we need image drag\n\t\t\tconst scaledWidth = image.width * zoom.scale;\n\t\t\tconst scaledHeight = image.height * zoom.scale;\n\t\t\timage.minX = Math.min(gesture.slideWidth / 2 - scaledWidth / 2, 0);\n\t\t\timage.maxX = -image.minX;\n\t\t\timage.minY = Math.min(gesture.slideHeight / 2 - scaledHeight / 2, 0);\n\t\t\timage.maxY = -image.minY;\n\t\t\timage.currentX = Math.max(Math.min(image.currentX, image.maxX), image.minX);\n\t\t\timage.currentY = Math.max(Math.min(image.currentY, image.maxY), image.minY);\n\t\t\tgesture.imageWrapEl.style.transitionDuration = `${momentumDuration}ms`;\n\t\t\tgesture.imageWrapEl.style.transform = `translate3d(${image.currentX}px, ${image.currentY}px,0)`;\n\t\t}\n\t\tfunction onTransitionEnd() {\n\t\t\tconst zoom = swiper.zoom;\n\t\t\tif (gesture.slideEl && swiper.activeIndex !== swiper.slides.indexOf(gesture.slideEl)) {\n\t\t\t\tif (gesture.imageEl) {\n\t\t\t\t\tgesture.imageEl.style.transform = 'translate3d(0,0,0) scale(1)';\n\t\t\t\t}\n\t\t\t\tif (gesture.imageWrapEl) {\n\t\t\t\t\tgesture.imageWrapEl.style.transform = 'translate3d(0,0,0)';\n\t\t\t\t}\n\t\t\t\tgesture.slideEl.classList.remove(`${swiper.params.zoom.zoomedSlideClass}`);\n\t\t\t\tzoom.scale = 1;\n\t\t\t\tcurrentScale = 1;\n\t\t\t\tgesture.slideEl = undefined;\n\t\t\t\tgesture.imageEl = undefined;\n\t\t\t\tgesture.imageWrapEl = undefined;\n\t\t\t\tgesture.originX = 0;\n\t\t\t\tgesture.originY = 0;\n\t\t\t}\n\t\t}\n\t\tfunction zoomIn(e) {\n\t\t\tconst zoom = swiper.zoom;\n\t\t\tconst params = swiper.params.zoom;\n\t\t\tif (!gesture.slideEl) {\n\t\t\t\tif (e && e.target) {\n\t\t\t\t\tgesture.slideEl = e.target.closest(`.${swiper.params.slideClass}, swiper-slide`);\n\t\t\t\t}\n\t\t\t\tif (!gesture.slideEl) {\n\t\t\t\t\tif (swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual) {\n\t\t\t\t\t\tgesture.slideEl = elementChildren(swiper.slidesEl, `.${swiper.params.slideActiveClass}`)[0];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tgesture.slideEl = swiper.slides[swiper.activeIndex];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlet imageEl = gesture.slideEl.querySelector(`.${params.containerClass}`);\n\t\t\t\tif (imageEl) {\n\t\t\t\t\timageEl = imageEl.querySelectorAll('picture, img, svg, canvas, .swiper-zoom-target')[0];\n\t\t\t\t}\n\t\t\t\tgesture.imageEl = imageEl;\n\t\t\t\tif (imageEl) {\n\t\t\t\t\tgesture.imageWrapEl = elementParents(gesture.imageEl, `.${params.containerClass}`)[0];\n\t\t\t\t} else {\n\t\t\t\t\tgesture.imageWrapEl = undefined;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!gesture.imageEl || !gesture.imageWrapEl) return;\n\t\t\tif (swiper.params.cssMode) {\n\t\t\t\tswiper.wrapperEl.style.overflow = 'hidden';\n\t\t\t\tswiper.wrapperEl.style.touchAction = 'none';\n\t\t\t}\n\t\t\tgesture.slideEl.classList.add(`${params.zoomedSlideClass}`);\n\t\t\tlet touchX;\n\t\t\tlet touchY;\n\t\t\tlet offsetX;\n\t\t\tlet offsetY;\n\t\t\tlet diffX;\n\t\t\tlet diffY;\n\t\t\tlet translateX;\n\t\t\tlet translateY;\n\t\t\tlet imageWidth;\n\t\t\tlet imageHeight;\n\t\t\tlet scaledWidth;\n\t\t\tlet scaledHeight;\n\t\t\tlet translateMinX;\n\t\t\tlet translateMinY;\n\t\t\tlet translateMaxX;\n\t\t\tlet translateMaxY;\n\t\t\tlet slideWidth;\n\t\t\tlet slideHeight;\n\t\t\tif (typeof image.touchesStart.x === 'undefined' && e) {\n\t\t\t\ttouchX = e.pageX;\n\t\t\t\ttouchY = e.pageY;\n\t\t\t} else {\n\t\t\t\ttouchX = image.touchesStart.x;\n\t\t\t\ttouchY = image.touchesStart.y;\n\t\t\t}\n\t\t\tconst forceZoomRatio = typeof e === 'number' ? e : null;\n\t\t\tif (currentScale === 1 && forceZoomRatio) {\n\t\t\t\ttouchX = undefined;\n\t\t\t\ttouchY = undefined;\n\t\t\t}\n\t\t\tconst maxRatio = getMaxRatio();\n\t\t\tzoom.scale = forceZoomRatio || maxRatio;\n\t\t\tcurrentScale = forceZoomRatio || maxRatio;\n\t\t\tif (e && !(currentScale === 1 && forceZoomRatio)) {\n\t\t\t\tslideWidth = gesture.slideEl.offsetWidth;\n\t\t\t\tslideHeight = gesture.slideEl.offsetHeight;\n\t\t\t\toffsetX = elementOffset(gesture.slideEl).left + window.scrollX;\n\t\t\t\toffsetY = elementOffset(gesture.slideEl).top + window.scrollY;\n\t\t\t\tdiffX = offsetX + slideWidth / 2 - touchX;\n\t\t\t\tdiffY = offsetY + slideHeight / 2 - touchY;\n\t\t\t\timageWidth = gesture.imageEl.offsetWidth || gesture.imageEl.clientWidth;\n\t\t\t\timageHeight = gesture.imageEl.offsetHeight || gesture.imageEl.clientHeight;\n\t\t\t\tscaledWidth = imageWidth * zoom.scale;\n\t\t\t\tscaledHeight = imageHeight * zoom.scale;\n\t\t\t\ttranslateMinX = Math.min(slideWidth / 2 - scaledWidth / 2, 0);\n\t\t\t\ttranslateMinY = Math.min(slideHeight / 2 - scaledHeight / 2, 0);\n\t\t\t\ttranslateMaxX = -translateMinX;\n\t\t\t\ttranslateMaxY = -translateMinY;\n\t\t\t\ttranslateX = diffX * zoom.scale;\n\t\t\t\ttranslateY = diffY * zoom.scale;\n\t\t\t\tif (translateX < translateMinX) {\n\t\t\t\t\ttranslateX = translateMinX;\n\t\t\t\t}\n\t\t\t\tif (translateX > translateMaxX) {\n\t\t\t\t\ttranslateX = translateMaxX;\n\t\t\t\t}\n\t\t\t\tif (translateY < translateMinY) {\n\t\t\t\t\ttranslateY = translateMinY;\n\t\t\t\t}\n\t\t\t\tif (translateY > translateMaxY) {\n\t\t\t\t\ttranslateY = translateMaxY;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\ttranslateX = 0;\n\t\t\t\ttranslateY = 0;\n\t\t\t}\n\t\t\tif (forceZoomRatio && zoom.scale === 1) {\n\t\t\t\tgesture.originX = 0;\n\t\t\t\tgesture.originY = 0;\n\t\t\t}\n\t\t\tgesture.imageWrapEl.style.transitionDuration = '300ms';\n\t\t\tgesture.imageWrapEl.style.transform = `translate3d(${translateX}px, ${translateY}px,0)`;\n\t\t\tgesture.imageEl.style.transitionDuration = '300ms';\n\t\t\tgesture.imageEl.style.transform = `translate3d(0,0,0) scale(${zoom.scale})`;\n\t\t}\n\t\tfunction zoomOut() {\n\t\t\tconst zoom = swiper.zoom;\n\t\t\tconst params = swiper.params.zoom;\n\t\t\tif (!gesture.slideEl) {\n\t\t\t\tif (swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual) {\n\t\t\t\t\tgesture.slideEl = elementChildren(swiper.slidesEl, `.${swiper.params.slideActiveClass}`)[0];\n\t\t\t\t} else {\n\t\t\t\t\tgesture.slideEl = swiper.slides[swiper.activeIndex];\n\t\t\t\t}\n\t\t\t\tlet imageEl = gesture.slideEl.querySelector(`.${params.containerClass}`);\n\t\t\t\tif (imageEl) {\n\t\t\t\t\timageEl = imageEl.querySelectorAll('picture, img, svg, canvas, .swiper-zoom-target')[0];\n\t\t\t\t}\n\t\t\t\tgesture.imageEl = imageEl;\n\t\t\t\tif (imageEl) {\n\t\t\t\t\tgesture.imageWrapEl = elementParents(gesture.imageEl, `.${params.containerClass}`)[0];\n\t\t\t\t} else {\n\t\t\t\t\tgesture.imageWrapEl = undefined;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!gesture.imageEl || !gesture.imageWrapEl) return;\n\t\t\tif (swiper.params.cssMode) {\n\t\t\t\tswiper.wrapperEl.style.overflow = '';\n\t\t\t\tswiper.wrapperEl.style.touchAction = '';\n\t\t\t}\n\t\t\tzoom.scale = 1;\n\t\t\tcurrentScale = 1;\n\t\t\tgesture.imageWrapEl.style.transitionDuration = '300ms';\n\t\t\tgesture.imageWrapEl.style.transform = 'translate3d(0,0,0)';\n\t\t\tgesture.imageEl.style.transitionDuration = '300ms';\n\t\t\tgesture.imageEl.style.transform = 'translate3d(0,0,0) scale(1)';\n\t\t\tgesture.slideEl.classList.remove(`${params.zoomedSlideClass}`);\n\t\t\tgesture.slideEl = undefined;\n\t\t\tgesture.originX = 0;\n\t\t\tgesture.originY = 0;\n\t\t}\n\n\t\t// Toggle Zoom\n\t\tfunction zoomToggle(e) {\n\t\t\tconst zoom = swiper.zoom;\n\t\t\tif (zoom.scale && zoom.scale !== 1) {\n\t\t\t\t// Zoom Out\n\t\t\t\tzoomOut();\n\t\t\t} else {\n\t\t\t\t// Zoom In\n\t\t\t\tzoomIn(e);\n\t\t\t}\n\t\t}\n\t\tfunction getListeners() {\n\t\t\tconst passiveListener = swiper.params.passiveListeners ? {\n\t\t\t\tpassive: true,\n\t\t\t\tcapture: false\n\t\t\t} : false;\n\t\t\tconst activeListenerWithCapture = swiper.params.passiveListeners ? {\n\t\t\t\tpassive: false,\n\t\t\t\tcapture: true\n\t\t\t} : true;\n\t\t\treturn {\n\t\t\t\tpassiveListener,\n\t\t\t\tactiveListenerWithCapture\n\t\t\t};\n\t\t}\n\n\t\t// Attach/Detach Events\n\t\tfunction enable() {\n\t\t\tconst zoom = swiper.zoom;\n\t\t\tif (zoom.enabled) return;\n\t\t\tzoom.enabled = true;\n\t\t\tconst {\n\t\t\t\tpassiveListener,\n\t\t\t\tactiveListenerWithCapture\n\t\t\t} = getListeners();\n\n\t\t\t// Scale image\n\t\t\tswiper.wrapperEl.addEventListener('pointerdown', onGestureStart, passiveListener);\n\t\t\tswiper.wrapperEl.addEventListener('pointermove', onGestureChange, activeListenerWithCapture);\n\t\t\t['pointerup', 'pointercancel', 'pointerout'].forEach(eventName => {\n\t\t\t\tswiper.wrapperEl.addEventListener(eventName, onGestureEnd, passiveListener);\n\t\t\t});\n\n\t\t\t// Move image\n\t\t\tswiper.wrapperEl.addEventListener('pointermove', onTouchMove, activeListenerWithCapture);\n\t\t}\n\t\tfunction disable() {\n\t\t\tconst zoom = swiper.zoom;\n\t\t\tif (!zoom.enabled) return;\n\t\t\tzoom.enabled = false;\n\t\t\tconst {\n\t\t\t\tpassiveListener,\n\t\t\t\tactiveListenerWithCapture\n\t\t\t} = getListeners();\n\n\t\t\t// Scale image\n\t\t\tswiper.wrapperEl.removeEventListener('pointerdown', onGestureStart, passiveListener);\n\t\t\tswiper.wrapperEl.removeEventListener('pointermove', onGestureChange, activeListenerWithCapture);\n\t\t\t['pointerup', 'pointercancel', 'pointerout'].forEach(eventName => {\n\t\t\t\tswiper.wrapperEl.removeEventListener(eventName, onGestureEnd, passiveListener);\n\t\t\t});\n\n\t\t\t// Move image\n\t\t\tswiper.wrapperEl.removeEventListener('pointermove', onTouchMove, activeListenerWithCapture);\n\t\t}\n\t\ton('init', () => {\n\t\t\tif (swiper.params.zoom.enabled) {\n\t\t\t\tenable();\n\t\t\t}\n\t\t});\n\t\ton('destroy', () => {\n\t\t\tdisable();\n\t\t});\n\t\ton('touchStart', (_s, e) => {\n\t\t\tif (!swiper.zoom.enabled) return;\n\t\t\tonTouchStart(e);\n\t\t});\n\t\ton('touchEnd', (_s, e) => {\n\t\t\tif (!swiper.zoom.enabled) return;\n\t\t\tonTouchEnd();\n\t\t});\n\t\ton('doubleTap', (_s, e) => {\n\t\t\tif (!swiper.animating && swiper.params.zoom.enabled && swiper.zoom.enabled && swiper.params.zoom.toggle) {\n\t\t\t\tzoomToggle(e);\n\t\t\t}\n\t\t});\n\t\ton('transitionEnd', () => {\n\t\t\tif (swiper.zoom.enabled && swiper.params.zoom.enabled) {\n\t\t\t\tonTransitionEnd();\n\t\t\t}\n\t\t});\n\t\ton('slideChange', () => {\n\t\t\tif (swiper.zoom.enabled && swiper.params.zoom.enabled && swiper.params.cssMode) {\n\t\t\t\tonTransitionEnd();\n\t\t\t}\n\t\t});\n\t\tObject.assign(swiper.zoom, {\n\t\t\tenable,\n\t\t\tdisable,\n\t\t\tin: zoomIn,\n\t\t\tout: zoomOut,\n\t\t\ttoggle: zoomToggle\n\t\t});\n\t}\n\n\t/* eslint no-bitwise: [\"error\", { \"allow\": [\">>\"] }] */\n\tfunction Controller(_ref) {\n\t\tlet {\n\t\t\tswiper,\n\t\t\textendParams,\n\t\t\ton\n\t\t} = _ref;\n\t\textendParams({\n\t\t\tcontroller: {\n\t\t\t\tcontrol: undefined,\n\t\t\t\tinverse: false,\n\t\t\t\tby: 'slide' // or 'container'\n\t\t\t}\n\t\t});\n\n\t\tswiper.controller = {\n\t\t\tcontrol: undefined\n\t\t};\n\t\tfunction LinearSpline(x, y) {\n\t\t\tconst binarySearch = function search() {\n\t\t\t\tlet maxIndex;\n\t\t\t\tlet minIndex;\n\t\t\t\tlet guess;\n\t\t\t\treturn (array, val) => {\n\t\t\t\t\tminIndex = -1;\n\t\t\t\t\tmaxIndex = array.length;\n\t\t\t\t\twhile (maxIndex - minIndex > 1) {\n\t\t\t\t\t\tguess = maxIndex + minIndex >> 1;\n\t\t\t\t\t\tif (array[guess] <= val) {\n\t\t\t\t\t\t\tminIndex = guess;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tmaxIndex = guess;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn maxIndex;\n\t\t\t\t};\n\t\t\t}();\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.lastIndex = x.length - 1;\n\t\t\t// Given an x value (x2), return the expected y2 value:\n\t\t\t// (x1,y1) is the known point before given value,\n\t\t\t// (x3,y3) is the known point after given value.\n\t\t\tlet i1;\n\t\t\tlet i3;\n\t\t\tthis.interpolate = function interpolate(x2) {\n\t\t\t\tif (!x2) return 0;\n\n\t\t\t\t// Get the indexes of x1 and x3 (the array indexes before and after given x2):\n\t\t\t\ti3 = binarySearch(this.x, x2);\n\t\t\t\ti1 = i3 - 1;\n\n\t\t\t\t// We have our indexes i1 & i3, so we can calculate already:\n\t\t\t\t// y2 := ((x2−x1) × (y3−y1)) ÷ (x3−x1) + y1\n\t\t\t\treturn (x2 - this.x[i1]) * (this.y[i3] - this.y[i1]) / (this.x[i3] - this.x[i1]) + this.y[i1];\n\t\t\t};\n\t\t\treturn this;\n\t\t}\n\t\tfunction getInterpolateFunction(c) {\n\t\t\tswiper.controller.spline = swiper.params.loop ? new LinearSpline(swiper.slidesGrid, c.slidesGrid) : new LinearSpline(swiper.snapGrid, c.snapGrid);\n\t\t}\n\t\tfunction setTranslate(_t, byController) {\n\t\t\tconst controlled = swiper.controller.control;\n\t\t\tlet multiplier;\n\t\t\tlet controlledTranslate;\n\t\t\tconst Swiper = swiper.constructor;\n\t\t\tfunction setControlledTranslate(c) {\n\t\t\t\tif (c.destroyed) return;\n\n\t\t\t\t// this will create an Interpolate function based on the snapGrids\n\t\t\t\t// x is the Grid of the scrolled scroller and y will be the controlled scroller\n\t\t\t\t// it makes sense to create this only once and recall it for the interpolation\n\t\t\t\t// the function does a lot of value caching for performance\n\t\t\t\tconst translate = swiper.rtlTranslate ? -swiper.translate : swiper.translate;\n\t\t\t\tif (swiper.params.controller.by === 'slide') {\n\t\t\t\t\tgetInterpolateFunction(c);\n\t\t\t\t\t// i am not sure why the values have to be multiplicated this way, tried to invert the snapGrid\n\t\t\t\t\t// but it did not work out\n\t\t\t\t\tcontrolledTranslate = -swiper.controller.spline.interpolate(-translate);\n\t\t\t\t}\n\t\t\t\tif (!controlledTranslate || swiper.params.controller.by === 'container') {\n\t\t\t\t\tmultiplier = (c.maxTranslate() - c.minTranslate()) / (swiper.maxTranslate() - swiper.minTranslate());\n\t\t\t\t\tif (Number.isNaN(multiplier) || !Number.isFinite(multiplier)) {\n\t\t\t\t\t\tmultiplier = 1;\n\t\t\t\t\t}\n\t\t\t\t\tcontrolledTranslate = (translate - swiper.minTranslate()) * multiplier + c.minTranslate();\n\t\t\t\t}\n\t\t\t\tif (swiper.params.controller.inverse) {\n\t\t\t\t\tcontrolledTranslate = c.maxTranslate() - controlledTranslate;\n\t\t\t\t}\n\t\t\t\tc.updateProgress(controlledTranslate);\n\t\t\t\tc.setTranslate(controlledTranslate, swiper);\n\t\t\t\tc.updateActiveIndex();\n\t\t\t\tc.updateSlidesClasses();\n\t\t\t}\n\t\t\tif (Array.isArray(controlled)) {\n\t\t\t\tfor (let i = 0; i < controlled.length; i += 1) {\n\t\t\t\t\tif (controlled[i] !== byController && controlled[i] instanceof Swiper) {\n\t\t\t\t\t\tsetControlledTranslate(controlled[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (controlled instanceof Swiper && byController !== controlled) {\n\t\t\t\tsetControlledTranslate(controlled);\n\t\t\t}\n\t\t}\n\t\tfunction setTransition(duration, byController) {\n\t\t\tconst Swiper = swiper.constructor;\n\t\t\tconst controlled = swiper.controller.control;\n\t\t\tlet i;\n\t\t\tfunction setControlledTransition(c) {\n\t\t\t\tif (c.destroyed) return;\n\t\t\t\tc.setTransition(duration, swiper);\n\t\t\t\tif (duration !== 0) {\n\t\t\t\t\tc.transitionStart();\n\t\t\t\t\tif (c.params.autoHeight) {\n\t\t\t\t\t\tnextTick(() => {\n\t\t\t\t\t\t\tc.updateAutoHeight();\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\telementTransitionEnd(c.wrapperEl, () => {\n\t\t\t\t\t\tif (!controlled) return;\n\t\t\t\t\t\tc.transitionEnd();\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (Array.isArray(controlled)) {\n\t\t\t\tfor (i = 0; i < controlled.length; i += 1) {\n\t\t\t\t\tif (controlled[i] !== byController && controlled[i] instanceof Swiper) {\n\t\t\t\t\t\tsetControlledTransition(controlled[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (controlled instanceof Swiper && byController !== controlled) {\n\t\t\t\tsetControlledTransition(controlled);\n\t\t\t}\n\t\t}\n\t\tfunction removeSpline() {\n\t\t\tif (!swiper.controller.control) return;\n\t\t\tif (swiper.controller.spline) {\n\t\t\t\tswiper.controller.spline = undefined;\n\t\t\t\tdelete swiper.controller.spline;\n\t\t\t}\n\t\t}\n\t\ton('beforeInit', () => {\n\t\t\tif (typeof window !== 'undefined' && (\n\t\t\t\t// eslint-disable-line\n\t\t\t\ttypeof swiper.params.controller.control === 'string' || swiper.params.controller.control instanceof HTMLElement)) {\n\t\t\t\tconst controlElement = document.querySelector(swiper.params.controller.control);\n\t\t\t\tif (controlElement && controlElement.swiper) {\n\t\t\t\t\tswiper.controller.control = controlElement.swiper;\n\t\t\t\t} else if (controlElement) {\n\t\t\t\t\tconst onControllerSwiper = e => {\n\t\t\t\t\t\tswiper.controller.control = e.detail[0];\n\t\t\t\t\t\tswiper.update();\n\t\t\t\t\t\tcontrolElement.removeEventListener('init', onControllerSwiper);\n\t\t\t\t\t};\n\t\t\t\t\tcontrolElement.addEventListener('init', onControllerSwiper);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tswiper.controller.control = swiper.params.controller.control;\n\t\t});\n\t\ton('update', () => {\n\t\t\tremoveSpline();\n\t\t});\n\t\ton('resize', () => {\n\t\t\tremoveSpline();\n\t\t});\n\t\ton('observerUpdate', () => {\n\t\t\tremoveSpline();\n\t\t});\n\t\ton('setTranslate', (_s, translate, byController) => {\n\t\t\tif (!swiper.controller.control || swiper.controller.control.destroyed) return;\n\t\t\tswiper.controller.setTranslate(translate, byController);\n\t\t});\n\t\ton('setTransition', (_s, duration, byController) => {\n\t\t\tif (!swiper.controller.control || swiper.controller.control.destroyed) return;\n\t\t\tswiper.controller.setTransition(duration, byController);\n\t\t});\n\t\tObject.assign(swiper.controller, {\n\t\t\tsetTranslate,\n\t\t\tsetTransition\n\t\t});\n\t}\n\n\tfunction A11y(_ref) {\n\t\tlet {\n\t\t\tswiper,\n\t\t\textendParams,\n\t\t\ton\n\t\t} = _ref;\n\t\textendParams({\n\t\t\ta11y: {\n\t\t\t\tenabled: true,\n\t\t\t\tnotificationClass: 'swiper-notification',\n\t\t\t\tprevSlideMessage: 'Previous slide',\n\t\t\t\tnextSlideMessage: 'Next slide',\n\t\t\t\tfirstSlideMessage: 'This is the first slide',\n\t\t\t\tlastSlideMessage: 'This is the last slide',\n\t\t\t\tpaginationBulletMessage: 'Go to slide {{index}}',\n\t\t\t\tslideLabelMessage: '{{index}} / {{slidesLength}}',\n\t\t\t\tcontainerMessage: null,\n\t\t\t\tcontainerRoleDescriptionMessage: null,\n\t\t\t\titemRoleDescriptionMessage: null,\n\t\t\t\tslideRole: 'group',\n\t\t\t\tid: null\n\t\t\t}\n\t\t});\n\t\tswiper.a11y = {\n\t\t\tclicked: false\n\t\t};\n\t\tlet liveRegion = null;\n\t\tlet preventFocusHandler;\n\t\tlet focusTargetSlideEl;\n\t\tlet visibilityChangedTimestamp = new Date().getTime();\n\t\tfunction notify(message) {\n\t\t\tconst notification = liveRegion;\n\t\t\tif (notification.length === 0) return;\n\t\t\tnotification.innerHTML = '';\n\t\t\tnotification.innerHTML = message;\n\t\t}\n\t\tfunction getRandomNumber(size) {\n\t\t\tif (size === void 0) {\n\t\t\t\tsize = 16;\n\t\t\t}\n\t\t\tconst randomChar = () => Math.round(16 * Math.random()).toString(16);\n\t\t\treturn 'x'.repeat(size).replace(/x/g, randomChar);\n\t\t}\n\t\tfunction makeElFocusable(el) {\n\t\t\tel = makeElementsArray(el);\n\t\t\tel.forEach(subEl => {\n\t\t\t\tsubEl.setAttribute('tabIndex', '0');\n\t\t\t});\n\t\t}\n\t\tfunction makeElNotFocusable(el) {\n\t\t\tel = makeElementsArray(el);\n\t\t\tel.forEach(subEl => {\n\t\t\t\tsubEl.setAttribute('tabIndex', '-1');\n\t\t\t});\n\t\t}\n\t\tfunction addElRole(el, role) {\n\t\t\tel = makeElementsArray(el);\n\t\t\tel.forEach(subEl => {\n\t\t\t\tsubEl.setAttribute('role', role);\n\t\t\t});\n\t\t}\n\t\tfunction addElRoleDescription(el, description) {\n\t\t\tel = makeElementsArray(el);\n\t\t\tel.forEach(subEl => {\n\t\t\t\tsubEl.setAttribute('aria-roledescription', description);\n\t\t\t});\n\t\t}\n\t\tfunction addElControls(el, controls) {\n\t\t\tel = makeElementsArray(el);\n\t\t\tel.forEach(subEl => {\n\t\t\t\tsubEl.setAttribute('aria-controls', controls);\n\t\t\t});\n\t\t}\n\t\tfunction addElLabel(el, label) {\n\t\t\tel = makeElementsArray(el);\n\t\t\tel.forEach(subEl => {\n\t\t\t\tsubEl.setAttribute('aria-label', label);\n\t\t\t});\n\t\t}\n\t\tfunction addElId(el, id) {\n\t\t\tel = makeElementsArray(el);\n\t\t\tel.forEach(subEl => {\n\t\t\t\tsubEl.setAttribute('id', id);\n\t\t\t});\n\t\t}\n\t\tfunction addElLive(el, live) {\n\t\t\tel = makeElementsArray(el);\n\t\t\tel.forEach(subEl => {\n\t\t\t\tsubEl.setAttribute('aria-live', live);\n\t\t\t});\n\t\t}\n\t\tfunction disableEl(el) {\n\t\t\tel = makeElementsArray(el);\n\t\t\tel.forEach(subEl => {\n\t\t\t\tsubEl.setAttribute('aria-disabled', true);\n\t\t\t});\n\t\t}\n\t\tfunction enableEl(el) {\n\t\t\tel = makeElementsArray(el);\n\t\t\tel.forEach(subEl => {\n\t\t\t\tsubEl.setAttribute('aria-disabled', false);\n\t\t\t});\n\t\t}\n\t\tfunction onEnterOrSpaceKey(e) {\n\t\t\tif (e.keyCode !== 13 && e.keyCode !== 32) return;\n\t\t\tconst params = swiper.params.a11y;\n\t\t\tconst targetEl = e.target;\n\t\t\tif (swiper.pagination && swiper.pagination.el && (targetEl === swiper.pagination.el || swiper.pagination.el.contains(e.target))) {\n\t\t\t\tif (!e.target.matches(classesToSelector(swiper.params.pagination.bulletClass))) return;\n\t\t\t}\n\t\t\tif (swiper.navigation && swiper.navigation.prevEl && swiper.navigation.nextEl) {\n\t\t\t\tconst prevEls = makeElementsArray(swiper.navigation.prevEl);\n\t\t\t\tconst nextEls = makeElementsArray(swiper.navigation.nextEl);\n\t\t\t\tif (nextEls.includes(targetEl)) {\n\t\t\t\t\tif (!(swiper.isEnd && !swiper.params.loop)) {\n\t\t\t\t\t\tswiper.slideNext();\n\t\t\t\t\t}\n\t\t\t\t\tif (swiper.isEnd) {\n\t\t\t\t\t\tnotify(params.lastSlideMessage);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnotify(params.nextSlideMessage);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (prevEls.includes(targetEl)) {\n\t\t\t\t\tif (!(swiper.isBeginning && !swiper.params.loop)) {\n\t\t\t\t\t\tswiper.slidePrev();\n\t\t\t\t\t}\n\t\t\t\t\tif (swiper.isBeginning) {\n\t\t\t\t\t\tnotify(params.firstSlideMessage);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnotify(params.prevSlideMessage);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (swiper.pagination && targetEl.matches(classesToSelector(swiper.params.pagination.bulletClass))) {\n\t\t\t\ttargetEl.click();\n\t\t\t}\n\t\t}\n\t\tfunction updateNavigation() {\n\t\t\tif (swiper.params.loop || swiper.params.rewind || !swiper.navigation) return;\n\t\t\tconst {\n\t\t\t\tnextEl,\n\t\t\t\tprevEl\n\t\t\t} = swiper.navigation;\n\t\t\tif (prevEl) {\n\t\t\t\tif (swiper.isBeginning) {\n\t\t\t\t\tdisableEl(prevEl);\n\t\t\t\t\tmakeElNotFocusable(prevEl);\n\t\t\t\t} else {\n\t\t\t\t\tenableEl(prevEl);\n\t\t\t\t\tmakeElFocusable(prevEl);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (nextEl) {\n\t\t\t\tif (swiper.isEnd) {\n\t\t\t\t\tdisableEl(nextEl);\n\t\t\t\t\tmakeElNotFocusable(nextEl);\n\t\t\t\t} else {\n\t\t\t\t\tenableEl(nextEl);\n\t\t\t\t\tmakeElFocusable(nextEl);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfunction hasPagination() {\n\t\t\treturn swiper.pagination && swiper.pagination.bullets && swiper.pagination.bullets.length;\n\t\t}\n\t\tfunction hasClickablePagination() {\n\t\t\treturn hasPagination() && swiper.params.pagination.clickable;\n\t\t}\n\t\tfunction updatePagination() {\n\t\t\tconst params = swiper.params.a11y;\n\t\t\tif (!hasPagination()) return;\n\t\t\tswiper.pagination.bullets.forEach(bulletEl => {\n\t\t\t\tif (swiper.params.pagination.clickable) {\n\t\t\t\t\tmakeElFocusable(bulletEl);\n\t\t\t\t\tif (!swiper.params.pagination.renderBullet) {\n\t\t\t\t\t\taddElRole(bulletEl, 'button');\n\t\t\t\t\t\taddElLabel(bulletEl, params.paginationBulletMessage.replace(/\\{\\{index\\}\\}/, elementIndex(bulletEl) + 1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (bulletEl.matches(classesToSelector(swiper.params.pagination.bulletActiveClass))) {\n\t\t\t\t\tbulletEl.setAttribute('aria-current', 'true');\n\t\t\t\t} else {\n\t\t\t\t\tbulletEl.removeAttribute('aria-current');\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\tconst initNavEl = (el, wrapperId, message) => {\n\t\t\tmakeElFocusable(el);\n\t\t\tif (el.tagName !== 'BUTTON') {\n\t\t\t\taddElRole(el, 'button');\n\t\t\t\tel.addEventListener('keydown', onEnterOrSpaceKey);\n\t\t\t}\n\t\t\taddElLabel(el, message);\n\t\t\taddElControls(el, wrapperId);\n\t\t};\n\t\tconst handlePointerDown = e => {\n\t\t\tif (focusTargetSlideEl && focusTargetSlideEl !== e.target && !focusTargetSlideEl.contains(e.target)) {\n\t\t\t\tpreventFocusHandler = true;\n\t\t\t}\n\t\t\tswiper.a11y.clicked = true;\n\t\t};\n\t\tconst handlePointerUp = () => {\n\t\t\tpreventFocusHandler = false;\n\t\t\trequestAnimationFrame(() => {\n\t\t\t\trequestAnimationFrame(() => {\n\t\t\t\t\tif (!swiper.destroyed) {\n\t\t\t\t\t\tswiper.a11y.clicked = false;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t});\n\t\t};\n\t\tconst onVisibilityChange = e => {\n\t\t\tvisibilityChangedTimestamp = new Date().getTime();\n\t\t};\n\t\tconst handleFocus = e => {\n\t\t\tif (swiper.a11y.clicked) return;\n\t\t\tif (new Date().getTime() - visibilityChangedTimestamp < 100) return;\n\t\t\tconst slideEl = e.target.closest(`.${swiper.params.slideClass}, swiper-slide`);\n\t\t\tif (!slideEl || !swiper.slides.includes(slideEl)) return;\n\t\t\tfocusTargetSlideEl = slideEl;\n\t\t\tconst isActive = swiper.slides.indexOf(slideEl) === swiper.activeIndex;\n\t\t\tconst isVisible = swiper.params.watchSlidesProgress && swiper.visibleSlides && swiper.visibleSlides.includes(slideEl);\n\t\t\tif (isActive || isVisible) return;\n\t\t\tif (e.sourceCapabilities && e.sourceCapabilities.firesTouchEvents) return;\n\t\t\tif (swiper.isHorizontal()) {\n\t\t\t\tswiper.el.scrollLeft = 0;\n\t\t\t} else {\n\t\t\t\tswiper.el.scrollTop = 0;\n\t\t\t}\n\t\t\trequestAnimationFrame(() => {\n\t\t\t\tif (preventFocusHandler) return;\n\t\t\t\tif (swiper.params.loop) {\n\t\t\t\t\tswiper.slideToLoop(parseInt(slideEl.getAttribute('data-swiper-slide-index')), 0);\n\t\t\t\t} else {\n\t\t\t\t\tswiper.slideTo(swiper.slides.indexOf(slideEl), 0);\n\t\t\t\t}\n\t\t\t\tpreventFocusHandler = false;\n\t\t\t});\n\t\t};\n\t\tconst initSlides = () => {\n\t\t\tconst params = swiper.params.a11y;\n\t\t\tif (params.itemRoleDescriptionMessage) {\n\t\t\t\taddElRoleDescription(swiper.slides, params.itemRoleDescriptionMessage);\n\t\t\t}\n\t\t\tif (params.slideRole) {\n\t\t\t\taddElRole(swiper.slides, params.slideRole);\n\t\t\t}\n\t\t\tconst slidesLength = swiper.slides.length;\n\t\t\tif (params.slideLabelMessage) {\n\t\t\t\tswiper.slides.forEach((slideEl, index) => {\n\t\t\t\t\tconst slideIndex = swiper.params.loop ? parseInt(slideEl.getAttribute('data-swiper-slide-index'), 10) : index;\n\t\t\t\t\tconst ariaLabelMessage = params.slideLabelMessage.replace(/\\{\\{index\\}\\}/, slideIndex + 1).replace(/\\{\\{slidesLength\\}\\}/, slidesLength);\n\t\t\t\t\taddElLabel(slideEl, ariaLabelMessage);\n\t\t\t\t});\n\t\t\t}\n\t\t};\n\t\tconst init = () => {\n\t\t\tconst params = swiper.params.a11y;\n\t\t\tswiper.el.append(liveRegion);\n\n\t\t\t// Container\n\t\t\tconst containerEl = swiper.el;\n\t\t\tif (params.containerRoleDescriptionMessage) {\n\t\t\t\taddElRoleDescription(containerEl, params.containerRoleDescriptionMessage);\n\t\t\t}\n\t\t\tif (params.containerMessage) {\n\t\t\t\taddElLabel(containerEl, params.containerMessage);\n\t\t\t}\n\n\t\t\t// Wrapper\n\t\t\tconst wrapperEl = swiper.wrapperEl;\n\t\t\tconst wrapperId = params.id || wrapperEl.getAttribute('id') || `swiper-wrapper-${getRandomNumber(16)}`;\n\t\t\tconst live = swiper.params.autoplay && swiper.params.autoplay.enabled ? 'off' : 'polite';\n\t\t\taddElId(wrapperEl, wrapperId);\n\t\t\taddElLive(wrapperEl, live);\n\n\t\t\t// Slide\n\t\t\tinitSlides();\n\n\t\t\t// Navigation\n\t\t\tlet {\n\t\t\t\tnextEl,\n\t\t\t\tprevEl\n\t\t\t} = swiper.navigation ? swiper.navigation : {};\n\t\t\tnextEl = makeElementsArray(nextEl);\n\t\t\tprevEl = makeElementsArray(prevEl);\n\t\t\tif (nextEl) {\n\t\t\t\tnextEl.forEach(el => initNavEl(el, wrapperId, params.nextSlideMessage));\n\t\t\t}\n\t\t\tif (prevEl) {\n\t\t\t\tprevEl.forEach(el => initNavEl(el, wrapperId, params.prevSlideMessage));\n\t\t\t}\n\n\t\t\t// Pagination\n\t\t\tif (hasClickablePagination()) {\n\t\t\t\tconst paginationEl = makeElementsArray(swiper.pagination.el);\n\t\t\t\tpaginationEl.forEach(el => {\n\t\t\t\t\tel.addEventListener('keydown', onEnterOrSpaceKey);\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// Tab focus\n\t\t\tconst document = getDocument();\n\t\t\tdocument.addEventListener('visibilitychange', onVisibilityChange);\n\t\t\tswiper.el.addEventListener('focus', handleFocus, true);\n\t\t\tswiper.el.addEventListener('focus', handleFocus, true);\n\t\t\tswiper.el.addEventListener('pointerdown', handlePointerDown, true);\n\t\t\tswiper.el.addEventListener('pointerup', handlePointerUp, true);\n\t\t};\n\t\tfunction destroy() {\n\t\t\tif (liveRegion) liveRegion.remove();\n\t\t\tlet {\n\t\t\t\tnextEl,\n\t\t\t\tprevEl\n\t\t\t} = swiper.navigation ? swiper.navigation : {};\n\t\t\tnextEl = makeElementsArray(nextEl);\n\t\t\tprevEl = makeElementsArray(prevEl);\n\t\t\tif (nextEl) {\n\t\t\t\tnextEl.forEach(el => el.removeEventListener('keydown', onEnterOrSpaceKey));\n\t\t\t}\n\t\t\tif (prevEl) {\n\t\t\t\tprevEl.forEach(el => el.removeEventListener('keydown', onEnterOrSpaceKey));\n\t\t\t}\n\n\t\t\t// Pagination\n\t\t\tif (hasClickablePagination()) {\n\t\t\t\tconst paginationEl = makeElementsArray(swiper.pagination.el);\n\t\t\t\tpaginationEl.forEach(el => {\n\t\t\t\t\tel.removeEventListener('keydown', onEnterOrSpaceKey);\n\t\t\t\t});\n\t\t\t}\n\t\t\tconst document = getDocument();\n\t\t\tdocument.removeEventListener('visibilitychange', onVisibilityChange);\n\t\t\t// Tab focus\n\t\t\tif (swiper.el && typeof swiper.el !== 'string') {\n\t\t\t\tswiper.el.removeEventListener('focus', handleFocus, true);\n\t\t\t\tswiper.el.removeEventListener('pointerdown', handlePointerDown, true);\n\t\t\t\tswiper.el.removeEventListener('pointerup', handlePointerUp, true);\n\t\t\t}\n\t\t}\n\t\ton('beforeInit', () => {\n\t\t\tliveRegion = createElement('span', swiper.params.a11y.notificationClass);\n\t\t\tliveRegion.setAttribute('aria-live', 'assertive');\n\t\t\tliveRegion.setAttribute('aria-atomic', 'true');\n\t\t});\n\t\ton('afterInit', () => {\n\t\t\tif (!swiper.params.a11y.enabled) return;\n\t\t\tinit();\n\t\t});\n\t\ton('slidesLengthChange snapGridLengthChange slidesGridLengthChange', () => {\n\t\t\tif (!swiper.params.a11y.enabled) return;\n\t\t\tinitSlides();\n\t\t});\n\t\ton('fromEdge toEdge afterInit lock unlock', () => {\n\t\t\tif (!swiper.params.a11y.enabled) return;\n\t\t\tupdateNavigation();\n\t\t});\n\t\ton('paginationUpdate', () => {\n\t\t\tif (!swiper.params.a11y.enabled) return;\n\t\t\tupdatePagination();\n\t\t});\n\t\ton('destroy', () => {\n\t\t\tif (!swiper.params.a11y.enabled) return;\n\t\t\tdestroy();\n\t\t});\n\t}\n\n\tfunction History(_ref) {\n\t\tlet {\n\t\t\tswiper,\n\t\t\textendParams,\n\t\t\ton\n\t\t} = _ref;\n\t\textendParams({\n\t\t\thistory: {\n\t\t\t\tenabled: false,\n\t\t\t\troot: '',\n\t\t\t\treplaceState: false,\n\t\t\t\tkey: 'slides',\n\t\t\t\tkeepQuery: false\n\t\t\t}\n\t\t});\n\t\tlet initialized = false;\n\t\tlet paths = {};\n\t\tconst slugify = text => {\n\t\t\treturn text.toString().replace(/\\s+/g, '-').replace(/[^\\w-]+/g, '').replace(/--+/g, '-').replace(/^-+/, '').replace(/-+$/, '');\n\t\t};\n\t\tconst getPathValues = urlOverride => {\n\t\t\tconst window = getWindow();\n\t\t\tlet location;\n\t\t\tif (urlOverride) {\n\t\t\t\tlocation = new URL(urlOverride);\n\t\t\t} else {\n\t\t\t\tlocation = window.location;\n\t\t\t}\n\t\t\tconst pathArray = location.pathname.slice(1).split('/').filter(part => part !== '');\n\t\t\tconst total = pathArray.length;\n\t\t\tconst key = pathArray[total - 2];\n\t\t\tconst value = pathArray[total - 1];\n\t\t\treturn {\n\t\t\t\tkey,\n\t\t\t\tvalue\n\t\t\t};\n\t\t};\n\t\tconst setHistory = (key, index) => {\n\t\t\tconst window = getWindow();\n\t\t\tif (!initialized || !swiper.params.history.enabled) return;\n\t\t\tlet location;\n\t\t\tif (swiper.params.url) {\n\t\t\t\tlocation = new URL(swiper.params.url);\n\t\t\t} else {\n\t\t\t\tlocation = window.location;\n\t\t\t}\n\t\t\tconst slide = swiper.virtual && swiper.params.virtual.enabled ? swiper.slidesEl.querySelector(`[data-swiper-slide-index=\"${index}\"]`) : swiper.slides[index];\n\t\t\tlet value = slugify(slide.getAttribute('data-history'));\n\t\t\tif (swiper.params.history.root.length > 0) {\n\t\t\t\tlet root = swiper.params.history.root;\n\t\t\t\tif (root[root.length - 1] === '/') root = root.slice(0, root.length - 1);\n\t\t\t\tvalue = `${root}/${key ? `${key}/` : ''}${value}`;\n\t\t\t} else if (!location.pathname.includes(key)) {\n\t\t\t\tvalue = `${key ? `${key}/` : ''}${value}`;\n\t\t\t}\n\t\t\tif (swiper.params.history.keepQuery) {\n\t\t\t\tvalue += location.search;\n\t\t\t}\n\t\t\tconst currentState = window.history.state;\n\t\t\tif (currentState && currentState.value === value) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (swiper.params.history.replaceState) {\n\t\t\t\twindow.history.replaceState({\n\t\t\t\t\tvalue\n\t\t\t\t}, null, value);\n\t\t\t} else {\n\t\t\t\twindow.history.pushState({\n\t\t\t\t\tvalue\n\t\t\t\t}, null, value);\n\t\t\t}\n\t\t};\n\t\tconst scrollToSlide = (speed, value, runCallbacks) => {\n\t\t\tif (value) {\n\t\t\t\tfor (let i = 0, length = swiper.slides.length; i < length; i += 1) {\n\t\t\t\t\tconst slide = swiper.slides[i];\n\t\t\t\t\tconst slideHistory = slugify(slide.getAttribute('data-history'));\n\t\t\t\t\tif (slideHistory === value) {\n\t\t\t\t\t\tconst index = swiper.getSlideIndex(slide);\n\t\t\t\t\t\tswiper.slideTo(index, speed, runCallbacks);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tswiper.slideTo(0, speed, runCallbacks);\n\t\t\t}\n\t\t};\n\t\tconst setHistoryPopState = () => {\n\t\t\tpaths = getPathValues(swiper.params.url);\n\t\t\tscrollToSlide(swiper.params.speed, paths.value, false);\n\t\t};\n\t\tconst init = () => {\n\t\t\tconst window = getWindow();\n\t\t\tif (!swiper.params.history) return;\n\t\t\tif (!window.history || !window.history.pushState) {\n\t\t\t\tswiper.params.history.enabled = false;\n\t\t\t\tswiper.params.hashNavigation.enabled = true;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tinitialized = true;\n\t\t\tpaths = getPathValues(swiper.params.url);\n\t\t\tif (!paths.key && !paths.value) {\n\t\t\t\tif (!swiper.params.history.replaceState) {\n\t\t\t\t\twindow.addEventListener('popstate', setHistoryPopState);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tscrollToSlide(0, paths.value, swiper.params.runCallbacksOnInit);\n\t\t\tif (!swiper.params.history.replaceState) {\n\t\t\t\twindow.addEventListener('popstate', setHistoryPopState);\n\t\t\t}\n\t\t};\n\t\tconst destroy = () => {\n\t\t\tconst window = getWindow();\n\t\t\tif (!swiper.params.history.replaceState) {\n\t\t\t\twindow.removeEventListener('popstate', setHistoryPopState);\n\t\t\t}\n\t\t};\n\t\ton('init', () => {\n\t\t\tif (swiper.params.history.enabled) {\n\t\t\t\tinit();\n\t\t\t}\n\t\t});\n\t\ton('destroy', () => {\n\t\t\tif (swiper.params.history.enabled) {\n\t\t\t\tdestroy();\n\t\t\t}\n\t\t});\n\t\ton('transitionEnd _freeModeNoMomentumRelease', () => {\n\t\t\tif (initialized) {\n\t\t\t\tsetHistory(swiper.params.history.key, swiper.activeIndex);\n\t\t\t}\n\t\t});\n\t\ton('slideChange', () => {\n\t\t\tif (initialized && swiper.params.cssMode) {\n\t\t\t\tsetHistory(swiper.params.history.key, swiper.activeIndex);\n\t\t\t}\n\t\t});\n\t}\n\n\tfunction HashNavigation(_ref) {\n\t\tlet {\n\t\t\tswiper,\n\t\t\textendParams,\n\t\t\temit,\n\t\t\ton\n\t\t} = _ref;\n\t\tlet initialized = false;\n\t\tconst document = getDocument();\n\t\tconst window = getWindow();\n\t\textendParams({\n\t\t\thashNavigation: {\n\t\t\t\tenabled: false,\n\t\t\t\treplaceState: false,\n\t\t\t\twatchState: false,\n\t\t\t\tgetSlideIndex(_s, hash) {\n\t\t\t\t\tif (swiper.virtual && swiper.params.virtual.enabled) {\n\t\t\t\t\t\tconst slideWithHash = swiper.slides.filter(slideEl => slideEl.getAttribute('data-hash') === hash)[0];\n\t\t\t\t\t\tif (!slideWithHash) return 0;\n\t\t\t\t\t\tconst index = parseInt(slideWithHash.getAttribute('data-swiper-slide-index'), 10);\n\t\t\t\t\t\treturn index;\n\t\t\t\t\t}\n\t\t\t\t\treturn swiper.getSlideIndex(elementChildren(swiper.slidesEl, `.${swiper.params.slideClass}[data-hash=\"${hash}\"], swiper-slide[data-hash=\"${hash}\"]`)[0]);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\tconst onHashChange = () => {\n\t\t\temit('hashChange');\n\t\t\tconst newHash = document.location.hash.replace('#', '');\n\t\t\tconst activeSlideEl = swiper.virtual && swiper.params.virtual.enabled ? swiper.slidesEl.querySelector(`[data-swiper-slide-index=\"${swiper.activeIndex}\"]`) : swiper.slides[swiper.activeIndex];\n\t\t\tconst activeSlideHash = activeSlideEl ? activeSlideEl.getAttribute('data-hash') : '';\n\t\t\tif (newHash !== activeSlideHash) {\n\t\t\t\tconst newIndex = swiper.params.hashNavigation.getSlideIndex(swiper, newHash);\n\t\t\t\tif (typeof newIndex === 'undefined' || Number.isNaN(newIndex)) return;\n\t\t\t\tswiper.slideTo(newIndex);\n\t\t\t}\n\t\t};\n\t\tconst setHash = () => {\n\t\t\tif (!initialized || !swiper.params.hashNavigation.enabled) return;\n\t\t\tconst activeSlideEl = swiper.virtual && swiper.params.virtual.enabled ? swiper.slidesEl.querySelector(`[data-swiper-slide-index=\"${swiper.activeIndex}\"]`) : swiper.slides[swiper.activeIndex];\n\t\t\tconst activeSlideHash = activeSlideEl ? activeSlideEl.getAttribute('data-hash') || activeSlideEl.getAttribute('data-history') : '';\n\t\t\tif (swiper.params.hashNavigation.replaceState && window.history && window.history.replaceState) {\n\t\t\t\twindow.history.replaceState(null, null, `#${activeSlideHash}` || '');\n\t\t\t\temit('hashSet');\n\t\t\t} else {\n\t\t\t\tdocument.location.hash = activeSlideHash || '';\n\t\t\t\temit('hashSet');\n\t\t\t}\n\t\t};\n\t\tconst init = () => {\n\t\t\tif (!swiper.params.hashNavigation.enabled || swiper.params.history && swiper.params.history.enabled) return;\n\t\t\tinitialized = true;\n\t\t\tconst hash = document.location.hash.replace('#', '');\n\t\t\tif (hash) {\n\t\t\t\tconst speed = 0;\n\t\t\t\tconst index = swiper.params.hashNavigation.getSlideIndex(swiper, hash);\n\t\t\t\tswiper.slideTo(index || 0, speed, swiper.params.runCallbacksOnInit, true);\n\t\t\t}\n\t\t\tif (swiper.params.hashNavigation.watchState) {\n\t\t\t\twindow.addEventListener('hashchange', onHashChange);\n\t\t\t}\n\t\t};\n\t\tconst destroy = () => {\n\t\t\tif (swiper.params.hashNavigation.watchState) {\n\t\t\t\twindow.removeEventListener('hashchange', onHashChange);\n\t\t\t}\n\t\t};\n\t\ton('init', () => {\n\t\t\tif (swiper.params.hashNavigation.enabled) {\n\t\t\t\tinit();\n\t\t\t}\n\t\t});\n\t\ton('destroy', () => {\n\t\t\tif (swiper.params.hashNavigation.enabled) {\n\t\t\t\tdestroy();\n\t\t\t}\n\t\t});\n\t\ton('transitionEnd _freeModeNoMomentumRelease', () => {\n\t\t\tif (initialized) {\n\t\t\t\tsetHash();\n\t\t\t}\n\t\t});\n\t\ton('slideChange', () => {\n\t\t\tif (initialized && swiper.params.cssMode) {\n\t\t\t\tsetHash();\n\t\t\t}\n\t\t});\n\t}\n\n\t/* eslint no-underscore-dangle: \"off\" */\n\t/* eslint no-use-before-define: \"off\" */\n\tfunction Autoplay(_ref) {\n\t\tlet {\n\t\t\tswiper,\n\t\t\textendParams,\n\t\t\ton,\n\t\t\temit,\n\t\t\tparams\n\t\t} = _ref;\n\t\tswiper.autoplay = {\n\t\t\trunning: false,\n\t\t\tpaused: false,\n\t\t\ttimeLeft: 0\n\t\t};\n\t\textendParams({\n\t\t\tautoplay: {\n\t\t\t\tenabled: false,\n\t\t\t\tdelay: 3000,\n\t\t\t\twaitForTransition: true,\n\t\t\t\tdisableOnInteraction: false,\n\t\t\t\tstopOnLastSlide: false,\n\t\t\t\treverseDirection: false,\n\t\t\t\tpauseOnMouseEnter: false\n\t\t\t}\n\t\t});\n\t\tlet timeout;\n\t\tlet raf;\n\t\tlet autoplayDelayTotal = params && params.autoplay ? params.autoplay.delay : 3000;\n\t\tlet autoplayDelayCurrent = params && params.autoplay ? params.autoplay.delay : 3000;\n\t\tlet autoplayTimeLeft;\n\t\tlet autoplayStartTime = new Date().getTime();\n\t\tlet wasPaused;\n\t\tlet isTouched;\n\t\tlet pausedByTouch;\n\t\tlet touchStartTimeout;\n\t\tlet slideChanged;\n\t\tlet pausedByInteraction;\n\t\tlet pausedByPointerEnter;\n\t\tfunction onTransitionEnd(e) {\n\t\t\tif (!swiper || swiper.destroyed || !swiper.wrapperEl) return;\n\t\t\tif (e.target !== swiper.wrapperEl) return;\n\t\t\tswiper.wrapperEl.removeEventListener('transitionend', onTransitionEnd);\n\t\t\tif (pausedByPointerEnter || e.detail && e.detail.bySwiperTouchMove) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresume();\n\t\t}\n\t\tconst calcTimeLeft = () => {\n\t\t\tif (swiper.destroyed || !swiper.autoplay.running) return;\n\t\t\tif (swiper.autoplay.paused) {\n\t\t\t\twasPaused = true;\n\t\t\t} else if (wasPaused) {\n\t\t\t\tautoplayDelayCurrent = autoplayTimeLeft;\n\t\t\t\twasPaused = false;\n\t\t\t}\n\t\t\tconst timeLeft = swiper.autoplay.paused ? autoplayTimeLeft : autoplayStartTime + autoplayDelayCurrent - new Date().getTime();\n\t\t\tswiper.autoplay.timeLeft = timeLeft;\n\t\t\temit('autoplayTimeLeft', timeLeft, timeLeft / autoplayDelayTotal);\n\t\t\traf = requestAnimationFrame(() => {\n\t\t\t\tcalcTimeLeft();\n\t\t\t});\n\t\t};\n\t\tconst getSlideDelay = () => {\n\t\t\tlet activeSlideEl;\n\t\t\tif (swiper.virtual && swiper.params.virtual.enabled) {\n\t\t\t\tactiveSlideEl = swiper.slides.filter(slideEl => slideEl.classList.contains('swiper-slide-active'))[0];\n\t\t\t} else {\n\t\t\t\tactiveSlideEl = swiper.slides[swiper.activeIndex];\n\t\t\t}\n\t\t\tif (!activeSlideEl) return undefined;\n\t\t\tconst currentSlideDelay = parseInt(activeSlideEl.getAttribute('data-swiper-autoplay'), 10);\n\t\t\treturn currentSlideDelay;\n\t\t};\n\t\tconst run = delayForce => {\n\t\t\tif (swiper.destroyed || !swiper.autoplay.running) return;\n\t\t\tcancelAnimationFrame(raf);\n\t\t\tcalcTimeLeft();\n\t\t\tlet delay = typeof delayForce === 'undefined' ? swiper.params.autoplay.delay : delayForce;\n\t\t\tautoplayDelayTotal = swiper.params.autoplay.delay;\n\t\t\tautoplayDelayCurrent = swiper.params.autoplay.delay;\n\t\t\tconst currentSlideDelay = getSlideDelay();\n\t\t\tif (!Number.isNaN(currentSlideDelay) && currentSlideDelay > 0 && typeof delayForce === 'undefined') {\n\t\t\t\tdelay = currentSlideDelay;\n\t\t\t\tautoplayDelayTotal = currentSlideDelay;\n\t\t\t\tautoplayDelayCurrent = currentSlideDelay;\n\t\t\t}\n\t\t\tautoplayTimeLeft = delay;\n\t\t\tconst speed = swiper.params.speed;\n\t\t\tconst proceed = () => {\n\t\t\t\tif (!swiper || swiper.destroyed) return;\n\t\t\t\tif (swiper.params.autoplay.reverseDirection) {\n\t\t\t\t\tif (!swiper.isBeginning || swiper.params.loop || swiper.params.rewind) {\n\t\t\t\t\t\tswiper.slidePrev(speed, true, true);\n\t\t\t\t\t\temit('autoplay');\n\t\t\t\t\t} else if (!swiper.params.autoplay.stopOnLastSlide) {\n\t\t\t\t\t\tswiper.slideTo(swiper.slides.length - 1, speed, true, true);\n\t\t\t\t\t\temit('autoplay');\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (!swiper.isEnd || swiper.params.loop || swiper.params.rewind) {\n\t\t\t\t\t\tswiper.slideNext(speed, true, true);\n\t\t\t\t\t\temit('autoplay');\n\t\t\t\t\t} else if (!swiper.params.autoplay.stopOnLastSlide) {\n\t\t\t\t\t\tswiper.slideTo(0, speed, true, true);\n\t\t\t\t\t\temit('autoplay');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (swiper.params.cssMode) {\n\t\t\t\t\tautoplayStartTime = new Date().getTime();\n\t\t\t\t\trequestAnimationFrame(() => {\n\t\t\t\t\t\trun();\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t};\n\t\t\tif (delay > 0) {\n\t\t\t\tclearTimeout(timeout);\n\t\t\t\ttimeout = setTimeout(() => {\n\t\t\t\t\tproceed();\n\t\t\t\t}, delay);\n\t\t\t} else {\n\t\t\t\trequestAnimationFrame(() => {\n\t\t\t\t\tproceed();\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// eslint-disable-next-line\n\t\t\treturn delay;\n\t\t};\n\t\tconst start = () => {\n\t\t\tautoplayStartTime = new Date().getTime();\n\t\t\tswiper.autoplay.running = true;\n\t\t\trun();\n\t\t\temit('autoplayStart');\n\t\t};\n\t\tconst stop = () => {\n\t\t\tswiper.autoplay.running = false;\n\t\t\tclearTimeout(timeout);\n\t\t\tcancelAnimationFrame(raf);\n\t\t\temit('autoplayStop');\n\t\t};\n\t\tconst pause = (internal, reset) => {\n\t\t\tif (swiper.destroyed || !swiper.autoplay.running) return;\n\t\t\tclearTimeout(timeout);\n\t\t\tif (!internal) {\n\t\t\t\tpausedByInteraction = true;\n\t\t\t}\n\t\t\tconst proceed = () => {\n\t\t\t\temit('autoplayPause');\n\t\t\t\tif (swiper.params.autoplay.waitForTransition) {\n\t\t\t\t\tswiper.wrapperEl.addEventListener('transitionend', onTransitionEnd);\n\t\t\t\t} else {\n\t\t\t\t\tresume();\n\t\t\t\t}\n\t\t\t};\n\t\t\tswiper.autoplay.paused = true;\n\t\t\tif (reset) {\n\t\t\t\tif (slideChanged) {\n\t\t\t\t\tautoplayTimeLeft = swiper.params.autoplay.delay;\n\t\t\t\t}\n\t\t\t\tslideChanged = false;\n\t\t\t\tproceed();\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tconst delay = autoplayTimeLeft || swiper.params.autoplay.delay;\n\t\t\tautoplayTimeLeft = delay - (new Date().getTime() - autoplayStartTime);\n\t\t\tif (swiper.isEnd && autoplayTimeLeft < 0 && !swiper.params.loop) return;\n\t\t\tif (autoplayTimeLeft < 0) autoplayTimeLeft = 0;\n\t\t\tproceed();\n\t\t};\n\t\tconst resume = () => {\n\t\t\tif (swiper.isEnd && autoplayTimeLeft < 0 && !swiper.params.loop || swiper.destroyed || !swiper.autoplay.running) return;\n\t\t\tautoplayStartTime = new Date().getTime();\n\t\t\tif (pausedByInteraction) {\n\t\t\t\tpausedByInteraction = false;\n\t\t\t\trun(autoplayTimeLeft);\n\t\t\t} else {\n\t\t\t\trun();\n\t\t\t}\n\t\t\tswiper.autoplay.paused = false;\n\t\t\temit('autoplayResume');\n\t\t};\n\t\tconst onVisibilityChange = () => {\n\t\t\tif (swiper.destroyed || !swiper.autoplay.running) return;\n\t\t\tconst document = getDocument();\n\t\t\tif (document.visibilityState === 'hidden') {\n\t\t\t\tpausedByInteraction = true;\n\t\t\t\tpause(true);\n\t\t\t}\n\t\t\tif (document.visibilityState === 'visible') {\n\t\t\t\tresume();\n\t\t\t}\n\t\t};\n\t\tconst onPointerEnter = e => {\n\t\t\tif (e.pointerType !== 'mouse') return;\n\t\t\tpausedByInteraction = true;\n\t\t\tpausedByPointerEnter = true;\n\t\t\tif (swiper.animating || swiper.autoplay.paused) return;\n\t\t\tpause(true);\n\t\t};\n\t\tconst onPointerLeave = e => {\n\t\t\tif (e.pointerType !== 'mouse') return;\n\t\t\tpausedByPointerEnter = false;\n\t\t\tif (swiper.autoplay.paused) {\n\t\t\t\tresume();\n\t\t\t}\n\t\t};\n\t\tconst attachMouseEvents = () => {\n\t\t\tif (swiper.params.autoplay.pauseOnMouseEnter) {\n\t\t\t\tswiper.el.addEventListener('pointerenter', onPointerEnter);\n\t\t\t\tswiper.el.addEventListener('pointerleave', onPointerLeave);\n\t\t\t}\n\t\t};\n\t\tconst detachMouseEvents = () => {\n\t\t\tif (swiper.el && typeof swiper.el !== 'string') {\n\t\t\t\tswiper.el.removeEventListener('pointerenter', onPointerEnter);\n\t\t\t\tswiper.el.removeEventListener('pointerleave', onPointerLeave);\n\t\t\t}\n\t\t};\n\t\tconst attachDocumentEvents = () => {\n\t\t\tconst document = getDocument();\n\t\t\tdocument.addEventListener('visibilitychange', onVisibilityChange);\n\t\t};\n\t\tconst detachDocumentEvents = () => {\n\t\t\tconst document = getDocument();\n\t\t\tdocument.removeEventListener('visibilitychange', onVisibilityChange);\n\t\t};\n\t\ton('init', () => {\n\t\t\tif (swiper.params.autoplay.enabled) {\n\t\t\t\tattachMouseEvents();\n\t\t\t\tattachDocumentEvents();\n\t\t\t\tstart();\n\t\t\t}\n\t\t});\n\t\ton('destroy', () => {\n\t\t\tdetachMouseEvents();\n\t\t\tdetachDocumentEvents();\n\t\t\tif (swiper.autoplay.running) {\n\t\t\t\tstop();\n\t\t\t}\n\t\t});\n\t\ton('_freeModeStaticRelease', () => {\n\t\t\tif (pausedByTouch || pausedByInteraction) {\n\t\t\t\tresume();\n\t\t\t}\n\t\t});\n\t\ton('_freeModeNoMomentumRelease', () => {\n\t\t\tif (!swiper.params.autoplay.disableOnInteraction) {\n\t\t\t\tpause(true, true);\n\t\t\t} else {\n\t\t\t\tstop();\n\t\t\t}\n\t\t});\n\t\ton('beforeTransitionStart', (_s, speed, internal) => {\n\t\t\tif (swiper.destroyed || !swiper.autoplay.running) return;\n\t\t\tif (internal || !swiper.params.autoplay.disableOnInteraction) {\n\t\t\t\tpause(true, true);\n\t\t\t} else {\n\t\t\t\tstop();\n\t\t\t}\n\t\t});\n\t\ton('sliderFirstMove', () => {\n\t\t\tif (swiper.destroyed || !swiper.autoplay.running) return;\n\t\t\tif (swiper.params.autoplay.disableOnInteraction) {\n\t\t\t\tstop();\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tisTouched = true;\n\t\t\tpausedByTouch = false;\n\t\t\tpausedByInteraction = false;\n\t\t\ttouchStartTimeout = setTimeout(() => {\n\t\t\t\tpausedByInteraction = true;\n\t\t\t\tpausedByTouch = true;\n\t\t\t\tpause(true);\n\t\t\t}, 200);\n\t\t});\n\t\ton('touchEnd', () => {\n\t\t\tif (swiper.destroyed || !swiper.autoplay.running || !isTouched) return;\n\t\t\tclearTimeout(touchStartTimeout);\n\t\t\tclearTimeout(timeout);\n\t\t\tif (swiper.params.autoplay.disableOnInteraction) {\n\t\t\t\tpausedByTouch = false;\n\t\t\t\tisTouched = false;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (pausedByTouch && swiper.params.cssMode) resume();\n\t\t\tpausedByTouch = false;\n\t\t\tisTouched = false;\n\t\t});\n\t\ton('slideChange', () => {\n\t\t\tif (swiper.destroyed || !swiper.autoplay.running) return;\n\t\t\tslideChanged = true;\n\t\t});\n\t\tObject.assign(swiper.autoplay, {\n\t\t\tstart,\n\t\t\tstop,\n\t\t\tpause,\n\t\t\tresume\n\t\t});\n\t}\n\n\tfunction Thumb(_ref) {\n\t\tlet {\n\t\t\tswiper,\n\t\t\textendParams,\n\t\t\ton\n\t\t} = _ref;\n\t\textendParams({\n\t\t\tthumbs: {\n\t\t\t\tswiper: null,\n\t\t\t\tmultipleActiveThumbs: true,\n\t\t\t\tautoScrollOffset: 0,\n\t\t\t\tslideThumbActiveClass: 'swiper-slide-thumb-active',\n\t\t\t\tthumbsContainerClass: 'swiper-thumbs'\n\t\t\t}\n\t\t});\n\t\tlet initialized = false;\n\t\tlet swiperCreated = false;\n\t\tswiper.thumbs = {\n\t\t\tswiper: null\n\t\t};\n\t\tfunction onThumbClick() {\n\t\t\tconst thumbsSwiper = swiper.thumbs.swiper;\n\t\t\tif (!thumbsSwiper || thumbsSwiper.destroyed) return;\n\t\t\tconst clickedIndex = thumbsSwiper.clickedIndex;\n\t\t\tconst clickedSlide = thumbsSwiper.clickedSlide;\n\t\t\tif (clickedSlide && clickedSlide.classList.contains(swiper.params.thumbs.slideThumbActiveClass)) return;\n\t\t\tif (typeof clickedIndex === 'undefined' || clickedIndex === null) return;\n\t\t\tlet slideToIndex;\n\t\t\tif (thumbsSwiper.params.loop) {\n\t\t\t\tslideToIndex = parseInt(thumbsSwiper.clickedSlide.getAttribute('data-swiper-slide-index'), 10);\n\t\t\t} else {\n\t\t\t\tslideToIndex = clickedIndex;\n\t\t\t}\n\t\t\tif (swiper.params.loop) {\n\t\t\t\tswiper.slideToLoop(slideToIndex);\n\t\t\t} else {\n\t\t\t\tswiper.slideTo(slideToIndex);\n\t\t\t}\n\t\t}\n\t\tfunction init() {\n\t\t\tconst {\n\t\t\t\tthumbs: thumbsParams\n\t\t\t} = swiper.params;\n\t\t\tif (initialized) return false;\n\t\t\tinitialized = true;\n\t\t\tconst SwiperClass = swiper.constructor;\n\t\t\tif (thumbsParams.swiper instanceof SwiperClass) {\n\t\t\t\tswiper.thumbs.swiper = thumbsParams.swiper;\n\t\t\t\tObject.assign(swiper.thumbs.swiper.originalParams, {\n\t\t\t\t\twatchSlidesProgress: true,\n\t\t\t\t\tslideToClickedSlide: false\n\t\t\t\t});\n\t\t\t\tObject.assign(swiper.thumbs.swiper.params, {\n\t\t\t\t\twatchSlidesProgress: true,\n\t\t\t\t\tslideToClickedSlide: false\n\t\t\t\t});\n\t\t\t\tswiper.thumbs.swiper.update();\n\t\t\t} else if (isObject(thumbsParams.swiper)) {\n\t\t\t\tconst thumbsSwiperParams = Object.assign({}, thumbsParams.swiper);\n\t\t\t\tObject.assign(thumbsSwiperParams, {\n\t\t\t\t\twatchSlidesProgress: true,\n\t\t\t\t\tslideToClickedSlide: false\n\t\t\t\t});\n\t\t\t\tswiper.thumbs.swiper = new SwiperClass(thumbsSwiperParams);\n\t\t\t\tswiperCreated = true;\n\t\t\t}\n\t\t\tswiper.thumbs.swiper.el.classList.add(swiper.params.thumbs.thumbsContainerClass);\n\t\t\tswiper.thumbs.swiper.on('tap', onThumbClick);\n\t\t\treturn true;\n\t\t}\n\t\tfunction update(initial) {\n\t\t\tconst thumbsSwiper = swiper.thumbs.swiper;\n\t\t\tif (!thumbsSwiper || thumbsSwiper.destroyed) return;\n\t\t\tconst slidesPerView = thumbsSwiper.params.slidesPerView === 'auto' ? thumbsSwiper.slidesPerViewDynamic() : thumbsSwiper.params.slidesPerView;\n\n\t\t\t// Activate thumbs\n\t\t\tlet thumbsToActivate = 1;\n\t\t\tconst thumbActiveClass = swiper.params.thumbs.slideThumbActiveClass;\n\t\t\tif (swiper.params.slidesPerView > 1 && !swiper.params.centeredSlides) {\n\t\t\t\tthumbsToActivate = swiper.params.slidesPerView;\n\t\t\t}\n\t\t\tif (!swiper.params.thumbs.multipleActiveThumbs) {\n\t\t\t\tthumbsToActivate = 1;\n\t\t\t}\n\t\t\tthumbsToActivate = Math.floor(thumbsToActivate);\n\t\t\tthumbsSwiper.slides.forEach(slideEl => slideEl.classList.remove(thumbActiveClass));\n\t\t\tif (thumbsSwiper.params.loop || thumbsSwiper.params.virtual && thumbsSwiper.params.virtual.enabled) {\n\t\t\t\tfor (let i = 0; i < thumbsToActivate; i += 1) {\n\t\t\t\t\telementChildren(thumbsSwiper.slidesEl, `[data-swiper-slide-index=\"${swiper.realIndex + i}\"]`).forEach(slideEl => {\n\t\t\t\t\t\tslideEl.classList.add(thumbActiveClass);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor (let i = 0; i < thumbsToActivate; i += 1) {\n\t\t\t\t\tif (thumbsSwiper.slides[swiper.realIndex + i]) {\n\t\t\t\t\t\tthumbsSwiper.slides[swiper.realIndex + i].classList.add(thumbActiveClass);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tconst autoScrollOffset = swiper.params.thumbs.autoScrollOffset;\n\t\t\tconst useOffset = autoScrollOffset && !thumbsSwiper.params.loop;\n\t\t\tif (swiper.realIndex !== thumbsSwiper.realIndex || useOffset) {\n\t\t\t\tconst currentThumbsIndex = thumbsSwiper.activeIndex;\n\t\t\t\tlet newThumbsIndex;\n\t\t\t\tlet direction;\n\t\t\t\tif (thumbsSwiper.params.loop) {\n\t\t\t\t\tconst newThumbsSlide = thumbsSwiper.slides.filter(slideEl => slideEl.getAttribute('data-swiper-slide-index') === `${swiper.realIndex}`)[0];\n\t\t\t\t\tnewThumbsIndex = thumbsSwiper.slides.indexOf(newThumbsSlide);\n\t\t\t\t\tdirection = swiper.activeIndex > swiper.previousIndex ? 'next' : 'prev';\n\t\t\t\t} else {\n\t\t\t\t\tnewThumbsIndex = swiper.realIndex;\n\t\t\t\t\tdirection = newThumbsIndex > swiper.previousIndex ? 'next' : 'prev';\n\t\t\t\t}\n\t\t\t\tif (useOffset) {\n\t\t\t\t\tnewThumbsIndex += direction === 'next' ? autoScrollOffset : -1 * autoScrollOffset;\n\t\t\t\t}\n\t\t\t\tif (thumbsSwiper.visibleSlidesIndexes && thumbsSwiper.visibleSlidesIndexes.indexOf(newThumbsIndex) < 0) {\n\t\t\t\t\tif (thumbsSwiper.params.centeredSlides) {\n\t\t\t\t\t\tif (newThumbsIndex > currentThumbsIndex) {\n\t\t\t\t\t\t\tnewThumbsIndex = newThumbsIndex - Math.floor(slidesPerView / 2) + 1;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tnewThumbsIndex = newThumbsIndex + Math.floor(slidesPerView / 2) - 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (newThumbsIndex > currentThumbsIndex && thumbsSwiper.params.slidesPerGroup === 1);\n\t\t\t\t\tthumbsSwiper.slideTo(newThumbsIndex, initial ? 0 : undefined);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ton('beforeInit', () => {\n\t\t\tconst {\n\t\t\t\tthumbs\n\t\t\t} = swiper.params;\n\t\t\tif (!thumbs || !thumbs.swiper) return;\n\t\t\tif (typeof thumbs.swiper === 'string' || thumbs.swiper instanceof HTMLElement) {\n\t\t\t\tconst document = getDocument();\n\t\t\t\tconst getThumbsElementAndInit = () => {\n\t\t\t\t\tconst thumbsElement = typeof thumbs.swiper === 'string' ? document.querySelector(thumbs.swiper) : thumbs.swiper;\n\t\t\t\t\tif (thumbsElement && thumbsElement.swiper) {\n\t\t\t\t\t\tthumbs.swiper = thumbsElement.swiper;\n\t\t\t\t\t\tinit();\n\t\t\t\t\t\tupdate(true);\n\t\t\t\t\t} else if (thumbsElement) {\n\t\t\t\t\t\tconst onThumbsSwiper = e => {\n\t\t\t\t\t\t\tthumbs.swiper = e.detail[0];\n\t\t\t\t\t\t\tthumbsElement.removeEventListener('init', onThumbsSwiper);\n\t\t\t\t\t\t\tinit();\n\t\t\t\t\t\t\tupdate(true);\n\t\t\t\t\t\t\tthumbs.swiper.update();\n\t\t\t\t\t\t\tswiper.update();\n\t\t\t\t\t\t};\n\t\t\t\t\t\tthumbsElement.addEventListener('init', onThumbsSwiper);\n\t\t\t\t\t}\n\t\t\t\t\treturn thumbsElement;\n\t\t\t\t};\n\t\t\t\tconst watchForThumbsToAppear = () => {\n\t\t\t\t\tif (swiper.destroyed) return;\n\t\t\t\t\tconst thumbsElement = getThumbsElementAndInit();\n\t\t\t\t\tif (!thumbsElement) {\n\t\t\t\t\t\trequestAnimationFrame(watchForThumbsToAppear);\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\trequestAnimationFrame(watchForThumbsToAppear);\n\t\t\t} else {\n\t\t\t\tinit();\n\t\t\t\tupdate(true);\n\t\t\t}\n\t\t});\n\t\ton('slideChange update resize observerUpdate', () => {\n\t\t\tupdate();\n\t\t});\n\t\ton('setTransition', (_s, duration) => {\n\t\t\tconst thumbsSwiper = swiper.thumbs.swiper;\n\t\t\tif (!thumbsSwiper || thumbsSwiper.destroyed) return;\n\t\t\tthumbsSwiper.setTransition(duration);\n\t\t});\n\t\ton('beforeDestroy', () => {\n\t\t\tconst thumbsSwiper = swiper.thumbs.swiper;\n\t\t\tif (!thumbsSwiper || thumbsSwiper.destroyed) return;\n\t\t\tif (swiperCreated) {\n\t\t\t\tthumbsSwiper.destroy();\n\t\t\t}\n\t\t});\n\t\tObject.assign(swiper.thumbs, {\n\t\t\tinit,\n\t\t\tupdate\n\t\t});\n\t}\n\n\tfunction freeMode(_ref) {\n\t\tlet {\n\t\t\tswiper,\n\t\t\textendParams,\n\t\t\temit,\n\t\t\tonce\n\t\t} = _ref;\n\t\textendParams({\n\t\t\tfreeMode: {\n\t\t\t\tenabled: false,\n\t\t\t\tmomentum: true,\n\t\t\t\tmomentumRatio: 1,\n\t\t\t\tmomentumBounce: true,\n\t\t\t\tmomentumBounceRatio: 1,\n\t\t\t\tmomentumVelocityRatio: 1,\n\t\t\t\tsticky: false,\n\t\t\t\tminimumVelocity: 0.02\n\t\t\t}\n\t\t});\n\t\tfunction onTouchStart() {\n\t\t\tif (swiper.params.cssMode) return;\n\t\t\tconst translate = swiper.getTranslate();\n\t\t\tswiper.setTranslate(translate);\n\t\t\tswiper.setTransition(0);\n\t\t\tswiper.touchEventsData.velocities.length = 0;\n\t\t\tswiper.freeMode.onTouchEnd({\n\t\t\t\tcurrentPos: swiper.rtl ? swiper.translate : -swiper.translate\n\t\t\t});\n\t\t}\n\t\tfunction onTouchMove() {\n\t\t\tif (swiper.params.cssMode) return;\n\t\t\tconst {\n\t\t\t\ttouchEventsData: data,\n\t\t\t\ttouches\n\t\t\t} = swiper;\n\t\t\t// Velocity\n\t\t\tif (data.velocities.length === 0) {\n\t\t\t\tdata.velocities.push({\n\t\t\t\t\tposition: touches[swiper.isHorizontal() ? 'startX' : 'startY'],\n\t\t\t\t\ttime: data.touchStartTime\n\t\t\t\t});\n\t\t\t}\n\t\t\tdata.velocities.push({\n\t\t\t\tposition: touches[swiper.isHorizontal() ? 'currentX' : 'currentY'],\n\t\t\t\ttime: now()\n\t\t\t});\n\t\t}\n\t\tfunction onTouchEnd(_ref2) {\n\t\t\tlet {\n\t\t\t\tcurrentPos\n\t\t\t} = _ref2;\n\t\t\tif (swiper.params.cssMode) return;\n\t\t\tconst {\n\t\t\t\tparams,\n\t\t\t\twrapperEl,\n\t\t\t\trtlTranslate: rtl,\n\t\t\t\tsnapGrid,\n\t\t\t\ttouchEventsData: data\n\t\t\t} = swiper;\n\t\t\t// Time diff\n\t\t\tconst touchEndTime = now();\n\t\t\tconst timeDiff = touchEndTime - data.touchStartTime;\n\t\t\tif (currentPos < -swiper.minTranslate()) {\n\t\t\t\tswiper.slideTo(swiper.activeIndex);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (currentPos > -swiper.maxTranslate()) {\n\t\t\t\tif (swiper.slides.length < snapGrid.length) {\n\t\t\t\t\tswiper.slideTo(snapGrid.length - 1);\n\t\t\t\t} else {\n\t\t\t\t\tswiper.slideTo(swiper.slides.length - 1);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (params.freeMode.momentum) {\n\t\t\t\tif (data.velocities.length > 1) {\n\t\t\t\t\tconst lastMoveEvent = data.velocities.pop();\n\t\t\t\t\tconst velocityEvent = data.velocities.pop();\n\t\t\t\t\tconst distance = lastMoveEvent.position - velocityEvent.position;\n\t\t\t\t\tconst time = lastMoveEvent.time - velocityEvent.time;\n\t\t\t\t\tswiper.velocity = distance / time;\n\t\t\t\t\tswiper.velocity /= 2;\n\t\t\t\t\tif (Math.abs(swiper.velocity) < params.freeMode.minimumVelocity) {\n\t\t\t\t\t\tswiper.velocity = 0;\n\t\t\t\t\t}\n\t\t\t\t\t// this implies that the user stopped moving a finger then released.\n\t\t\t\t\t// There would be no events with distance zero, so the last event is stale.\n\t\t\t\t\tif (time > 150 || now() - lastMoveEvent.time > 300) {\n\t\t\t\t\t\tswiper.velocity = 0;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tswiper.velocity = 0;\n\t\t\t\t}\n\t\t\t\tswiper.velocity *= params.freeMode.momentumVelocityRatio;\n\t\t\t\tdata.velocities.length = 0;\n\t\t\t\tlet momentumDuration = 1000 * params.freeMode.momentumRatio;\n\t\t\t\tconst momentumDistance = swiper.velocity * momentumDuration;\n\t\t\t\tlet newPosition = swiper.translate + momentumDistance;\n\t\t\t\tif (rtl) newPosition = -newPosition;\n\t\t\t\tlet doBounce = false;\n\t\t\t\tlet afterBouncePosition;\n\t\t\t\tconst bounceAmount = Math.abs(swiper.velocity) * 20 * params.freeMode.momentumBounceRatio;\n\t\t\t\tlet needsLoopFix;\n\t\t\t\tif (newPosition < swiper.maxTranslate()) {\n\t\t\t\t\tif (params.freeMode.momentumBounce) {\n\t\t\t\t\t\tif (newPosition + swiper.maxTranslate() < -bounceAmount) {\n\t\t\t\t\t\t\tnewPosition = swiper.maxTranslate() - bounceAmount;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tafterBouncePosition = swiper.maxTranslate();\n\t\t\t\t\t\tdoBounce = true;\n\t\t\t\t\t\tdata.allowMomentumBounce = true;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnewPosition = swiper.maxTranslate();\n\t\t\t\t\t}\n\t\t\t\t\tif (params.loop && params.centeredSlides) needsLoopFix = true;\n\t\t\t\t} else if (newPosition > swiper.minTranslate()) {\n\t\t\t\t\tif (params.freeMode.momentumBounce) {\n\t\t\t\t\t\tif (newPosition - swiper.minTranslate() > bounceAmount) {\n\t\t\t\t\t\t\tnewPosition = swiper.minTranslate() + bounceAmount;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tafterBouncePosition = swiper.minTranslate();\n\t\t\t\t\t\tdoBounce = true;\n\t\t\t\t\t\tdata.allowMomentumBounce = true;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnewPosition = swiper.minTranslate();\n\t\t\t\t\t}\n\t\t\t\t\tif (params.loop && params.centeredSlides) needsLoopFix = true;\n\t\t\t\t} else if (params.freeMode.sticky) {\n\t\t\t\t\tlet nextSlide;\n\t\t\t\t\tfor (let j = 0; j < snapGrid.length; j += 1) {\n\t\t\t\t\t\tif (snapGrid[j] > -newPosition) {\n\t\t\t\t\t\t\tnextSlide = j;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (Math.abs(snapGrid[nextSlide] - newPosition) < Math.abs(snapGrid[nextSlide - 1] - newPosition) || swiper.swipeDirection === 'next') {\n\t\t\t\t\t\tnewPosition = snapGrid[nextSlide];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnewPosition = snapGrid[nextSlide - 1];\n\t\t\t\t\t}\n\t\t\t\t\tnewPosition = -newPosition;\n\t\t\t\t}\n\t\t\t\tif (needsLoopFix) {\n\t\t\t\t\tonce('transitionEnd', () => {\n\t\t\t\t\t\tswiper.loopFix();\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\t// Fix duration\n\t\t\t\tif (swiper.velocity !== 0) {\n\t\t\t\t\tif (rtl) {\n\t\t\t\t\t\tmomentumDuration = Math.abs((-newPosition - swiper.translate) / swiper.velocity);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmomentumDuration = Math.abs((newPosition - swiper.translate) / swiper.velocity);\n\t\t\t\t\t}\n\t\t\t\t\tif (params.freeMode.sticky) {\n\t\t\t\t\t\t// If freeMode.sticky is active and the user ends a swipe with a slow-velocity\n\t\t\t\t\t\t// event, then durations can be 20+ seconds to slide one (or zero!) slides.\n\t\t\t\t\t\t// It's easy to see this when simulating touch with mouse events. To fix this,\n\t\t\t\t\t\t// limit single-slide swipes to the default slide duration. This also has the\n\t\t\t\t\t\t// nice side effect of matching slide speed if the user stopped moving before\n\t\t\t\t\t\t// lifting finger or mouse vs. moving slowly before lifting the finger/mouse.\n\t\t\t\t\t\t// For faster swipes, also apply limits (albeit higher ones).\n\t\t\t\t\t\tconst moveDistance = Math.abs((rtl ? -newPosition : newPosition) - swiper.translate);\n\t\t\t\t\t\tconst currentSlideSize = swiper.slidesSizesGrid[swiper.activeIndex];\n\t\t\t\t\t\tif (moveDistance < currentSlideSize) {\n\t\t\t\t\t\t\tmomentumDuration = params.speed;\n\t\t\t\t\t\t} else if (moveDistance < 2 * currentSlideSize) {\n\t\t\t\t\t\t\tmomentumDuration = params.speed * 1.5;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tmomentumDuration = params.speed * 2.5;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if (params.freeMode.sticky) {\n\t\t\t\t\tswiper.slideToClosest();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (params.freeMode.momentumBounce && doBounce) {\n\t\t\t\t\tswiper.updateProgress(afterBouncePosition);\n\t\t\t\t\tswiper.setTransition(momentumDuration);\n\t\t\t\t\tswiper.setTranslate(newPosition);\n\t\t\t\t\tswiper.transitionStart(true, swiper.swipeDirection);\n\t\t\t\t\tswiper.animating = true;\n\t\t\t\t\telementTransitionEnd(wrapperEl, () => {\n\t\t\t\t\t\tif (!swiper || swiper.destroyed || !data.allowMomentumBounce) return;\n\t\t\t\t\t\temit('momentumBounce');\n\t\t\t\t\t\tswiper.setTransition(params.speed);\n\t\t\t\t\t\tsetTimeout(() => {\n\t\t\t\t\t\t\tswiper.setTranslate(afterBouncePosition);\n\t\t\t\t\t\t\telementTransitionEnd(wrapperEl, () => {\n\t\t\t\t\t\t\t\tif (!swiper || swiper.destroyed) return;\n\t\t\t\t\t\t\t\tswiper.transitionEnd();\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}, 0);\n\t\t\t\t\t});\n\t\t\t\t} else if (swiper.velocity) {\n\t\t\t\t\temit('_freeModeNoMomentumRelease');\n\t\t\t\t\tswiper.updateProgress(newPosition);\n\t\t\t\t\tswiper.setTransition(momentumDuration);\n\t\t\t\t\tswiper.setTranslate(newPosition);\n\t\t\t\t\tswiper.transitionStart(true, swiper.swipeDirection);\n\t\t\t\t\tif (!swiper.animating) {\n\t\t\t\t\t\tswiper.animating = true;\n\t\t\t\t\t\telementTransitionEnd(wrapperEl, () => {\n\t\t\t\t\t\t\tif (!swiper || swiper.destroyed) return;\n\t\t\t\t\t\t\tswiper.transitionEnd();\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tswiper.updateProgress(newPosition);\n\t\t\t\t}\n\t\t\t\tswiper.updateActiveIndex();\n\t\t\t\tswiper.updateSlidesClasses();\n\t\t\t} else if (params.freeMode.sticky) {\n\t\t\t\tswiper.slideToClosest();\n\t\t\t\treturn;\n\t\t\t} else if (params.freeMode) {\n\t\t\t\temit('_freeModeNoMomentumRelease');\n\t\t\t}\n\t\t\tif (!params.freeMode.momentum || timeDiff >= params.longSwipesMs) {\n\t\t\t\temit('_freeModeStaticRelease');\n\t\t\t\tswiper.updateProgress();\n\t\t\t\tswiper.updateActiveIndex();\n\t\t\t\tswiper.updateSlidesClasses();\n\t\t\t}\n\t\t}\n\t\tObject.assign(swiper, {\n\t\t\tfreeMode: {\n\t\t\t\tonTouchStart,\n\t\t\t\tonTouchMove,\n\t\t\t\tonTouchEnd\n\t\t\t}\n\t\t});\n\t}\n\n\tfunction Grid(_ref) {\n\t\tlet {\n\t\t\tswiper,\n\t\t\textendParams,\n\t\t\ton\n\t\t} = _ref;\n\t\textendParams({\n\t\t\tgrid: {\n\t\t\t\trows: 1,\n\t\t\t\tfill: 'column'\n\t\t\t}\n\t\t});\n\t\tlet slidesNumberEvenToRows;\n\t\tlet slidesPerRow;\n\t\tlet numFullColumns;\n\t\tlet wasMultiRow;\n\t\tconst getSpaceBetween = () => {\n\t\t\tlet spaceBetween = swiper.params.spaceBetween;\n\t\t\tif (typeof spaceBetween === 'string' && spaceBetween.indexOf('%') >= 0) {\n\t\t\t\tspaceBetween = parseFloat(spaceBetween.replace('%', '')) / 100 * swiper.size;\n\t\t\t} else if (typeof spaceBetween === 'string') {\n\t\t\t\tspaceBetween = parseFloat(spaceBetween);\n\t\t\t}\n\t\t\treturn spaceBetween;\n\t\t};\n\t\tconst initSlides = slides => {\n\t\t\tconst {\n\t\t\t\tslidesPerView\n\t\t\t} = swiper.params;\n\t\t\tconst {\n\t\t\t\trows,\n\t\t\t\tfill\n\t\t\t} = swiper.params.grid;\n\t\t\tconst slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : slides.length;\n\t\t\tnumFullColumns = Math.floor(slidesLength / rows);\n\t\t\tif (Math.floor(slidesLength / rows) === slidesLength / rows) {\n\t\t\t\tslidesNumberEvenToRows = slidesLength;\n\t\t\t} else {\n\t\t\t\tslidesNumberEvenToRows = Math.ceil(slidesLength / rows) * rows;\n\t\t\t}\n\t\t\tif (slidesPerView !== 'auto' && fill === 'row') {\n\t\t\t\tslidesNumberEvenToRows = Math.max(slidesNumberEvenToRows, slidesPerView * rows);\n\t\t\t}\n\t\t\tslidesPerRow = slidesNumberEvenToRows / rows;\n\t\t};\n\t\tconst unsetSlides = () => {\n\t\t\tif (swiper.slides) {\n\t\t\t\tswiper.slides.forEach(slide => {\n\t\t\t\t\tif (slide.swiperSlideGridSet) {\n\t\t\t\t\t\tslide.style.height = '';\n\t\t\t\t\t\tslide.style[swiper.getDirectionLabel('margin-top')] = '';\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t};\n\t\tconst updateSlide = (i, slide, slides) => {\n\t\t\tconst {\n\t\t\t\tslidesPerGroup\n\t\t\t} = swiper.params;\n\t\t\tconst spaceBetween = getSpaceBetween();\n\t\t\tconst {\n\t\t\t\trows,\n\t\t\t\tfill\n\t\t\t} = swiper.params.grid;\n\t\t\tconst slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : slides.length;\n\t\t\t// Set slides order\n\t\t\tlet newSlideOrderIndex;\n\t\t\tlet column;\n\t\t\tlet row;\n\t\t\tif (fill === 'row' && slidesPerGroup > 1) {\n\t\t\t\tconst groupIndex = Math.floor(i / (slidesPerGroup * rows));\n\t\t\t\tconst slideIndexInGroup = i - rows * slidesPerGroup * groupIndex;\n\t\t\t\tconst columnsInGroup = groupIndex === 0 ? slidesPerGroup : Math.min(Math.ceil((slidesLength - groupIndex * rows * slidesPerGroup) / rows), slidesPerGroup);\n\t\t\t\trow = Math.floor(slideIndexInGroup / columnsInGroup);\n\t\t\t\tcolumn = slideIndexInGroup - row * columnsInGroup + groupIndex * slidesPerGroup;\n\t\t\t\tnewSlideOrderIndex = column + row * slidesNumberEvenToRows / rows;\n\t\t\t\tslide.style.order = newSlideOrderIndex;\n\t\t\t} else if (fill === 'column') {\n\t\t\t\tcolumn = Math.floor(i / rows);\n\t\t\t\trow = i - column * rows;\n\t\t\t\tif (column > numFullColumns || column === numFullColumns && row === rows - 1) {\n\t\t\t\t\trow += 1;\n\t\t\t\t\tif (row >= rows) {\n\t\t\t\t\t\trow = 0;\n\t\t\t\t\t\tcolumn += 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\trow = Math.floor(i / slidesPerRow);\n\t\t\t\tcolumn = i - row * slidesPerRow;\n\t\t\t}\n\t\t\tslide.row = row;\n\t\t\tslide.column = column;\n\t\t\tslide.style.height = `calc((100% - ${(rows - 1) * spaceBetween}px) / ${rows})`;\n\t\t\tslide.style[swiper.getDirectionLabel('margin-top')] = row !== 0 ? spaceBetween && `${spaceBetween}px` : '';\n\t\t\tslide.swiperSlideGridSet = true;\n\t\t};\n\t\tconst updateWrapperSize = (slideSize, snapGrid) => {\n\t\t\tconst {\n\t\t\t\tcenteredSlides,\n\t\t\t\troundLengths\n\t\t\t} = swiper.params;\n\t\t\tconst spaceBetween = getSpaceBetween();\n\t\t\tconst {\n\t\t\t\trows\n\t\t\t} = swiper.params.grid;\n\t\t\tswiper.virtualSize = (slideSize + spaceBetween) * slidesNumberEvenToRows;\n\t\t\tswiper.virtualSize = Math.ceil(swiper.virtualSize / rows) - spaceBetween;\n\t\t\tif (!swiper.params.cssMode) {\n\t\t\t\tswiper.wrapperEl.style[swiper.getDirectionLabel('width')] = `${swiper.virtualSize + spaceBetween}px`;\n\t\t\t}\n\t\t\tif (centeredSlides) {\n\t\t\t\tconst newSlidesGrid = [];\n\t\t\t\tfor (let i = 0; i < snapGrid.length; i += 1) {\n\t\t\t\t\tlet slidesGridItem = snapGrid[i];\n\t\t\t\t\tif (roundLengths) slidesGridItem = Math.floor(slidesGridItem);\n\t\t\t\t\tif (snapGrid[i] < swiper.virtualSize + snapGrid[0]) newSlidesGrid.push(slidesGridItem);\n\t\t\t\t}\n\t\t\t\tsnapGrid.splice(0, snapGrid.length);\n\t\t\t\tsnapGrid.push(...newSlidesGrid);\n\t\t\t}\n\t\t};\n\t\tconst onInit = () => {\n\t\t\twasMultiRow = swiper.params.grid && swiper.params.grid.rows > 1;\n\t\t};\n\t\tconst onUpdate = () => {\n\t\t\tconst {\n\t\t\t\tparams,\n\t\t\t\tel\n\t\t\t} = swiper;\n\t\t\tconst isMultiRow = params.grid && params.grid.rows > 1;\n\t\t\tif (wasMultiRow && !isMultiRow) {\n\t\t\t\tel.classList.remove(`${params.containerModifierClass}grid`, `${params.containerModifierClass}grid-column`);\n\t\t\t\tnumFullColumns = 1;\n\t\t\t\tswiper.emitContainerClasses();\n\t\t\t} else if (!wasMultiRow && isMultiRow) {\n\t\t\t\tel.classList.add(`${params.containerModifierClass}grid`);\n\t\t\t\tif (params.grid.fill === 'column') {\n\t\t\t\t\tel.classList.add(`${params.containerModifierClass}grid-column`);\n\t\t\t\t}\n\t\t\t\tswiper.emitContainerClasses();\n\t\t\t}\n\t\t\twasMultiRow = isMultiRow;\n\t\t};\n\t\ton('init', onInit);\n\t\ton('update', onUpdate);\n\t\tswiper.grid = {\n\t\t\tinitSlides,\n\t\t\tunsetSlides,\n\t\t\tupdateSlide,\n\t\t\tupdateWrapperSize\n\t\t};\n\t}\n\n\tfunction appendSlide(slides) {\n\t\tconst swiper = this;\n\t\tconst {\n\t\t\tparams,\n\t\t\tslidesEl\n\t\t} = swiper;\n\t\tif (params.loop) {\n\t\t\tswiper.loopDestroy();\n\t\t}\n\t\tconst appendElement = slideEl => {\n\t\t\tif (typeof slideEl === 'string') {\n\t\t\t\tconst tempDOM = document.createElement('div');\n\t\t\t\ttempDOM.innerHTML = slideEl;\n\t\t\t\tslidesEl.append(tempDOM.children[0]);\n\t\t\t\ttempDOM.innerHTML = '';\n\t\t\t} else {\n\t\t\t\tslidesEl.append(slideEl);\n\t\t\t}\n\t\t};\n\t\tif (typeof slides === 'object' && 'length' in slides) {\n\t\t\tfor (let i = 0; i < slides.length; i += 1) {\n\t\t\t\tif (slides[i]) appendElement(slides[i]);\n\t\t\t}\n\t\t} else {\n\t\t\tappendElement(slides);\n\t\t}\n\t\tswiper.recalcSlides();\n\t\tif (params.loop) {\n\t\t\tswiper.loopCreate();\n\t\t}\n\t\tif (!params.observer || swiper.isElement) {\n\t\t\tswiper.update();\n\t\t}\n\t}\n\n\tfunction prependSlide(slides) {\n\t\tconst swiper = this;\n\t\tconst {\n\t\t\tparams,\n\t\t\tactiveIndex,\n\t\t\tslidesEl\n\t\t} = swiper;\n\t\tif (params.loop) {\n\t\t\tswiper.loopDestroy();\n\t\t}\n\t\tlet newActiveIndex = activeIndex + 1;\n\t\tconst prependElement = slideEl => {\n\t\t\tif (typeof slideEl === 'string') {\n\t\t\t\tconst tempDOM = document.createElement('div');\n\t\t\t\ttempDOM.innerHTML = slideEl;\n\t\t\t\tslidesEl.prepend(tempDOM.children[0]);\n\t\t\t\ttempDOM.innerHTML = '';\n\t\t\t} else {\n\t\t\t\tslidesEl.prepend(slideEl);\n\t\t\t}\n\t\t};\n\t\tif (typeof slides === 'object' && 'length' in slides) {\n\t\t\tfor (let i = 0; i < slides.length; i += 1) {\n\t\t\t\tif (slides[i]) prependElement(slides[i]);\n\t\t\t}\n\t\t\tnewActiveIndex = activeIndex + slides.length;\n\t\t} else {\n\t\t\tprependElement(slides);\n\t\t}\n\t\tswiper.recalcSlides();\n\t\tif (params.loop) {\n\t\t\tswiper.loopCreate();\n\t\t}\n\t\tif (!params.observer || swiper.isElement) {\n\t\t\tswiper.update();\n\t\t}\n\t\tswiper.slideTo(newActiveIndex, 0, false);\n\t}\n\n\tfunction addSlide(index, slides) {\n\t\tconst swiper = this;\n\t\tconst {\n\t\t\tparams,\n\t\t\tactiveIndex,\n\t\t\tslidesEl\n\t\t} = swiper;\n\t\tlet activeIndexBuffer = activeIndex;\n\t\tif (params.loop) {\n\t\t\tactiveIndexBuffer -= swiper.loopedSlides;\n\t\t\tswiper.loopDestroy();\n\t\t\tswiper.recalcSlides();\n\t\t}\n\t\tconst baseLength = swiper.slides.length;\n\t\tif (index <= 0) {\n\t\t\tswiper.prependSlide(slides);\n\t\t\treturn;\n\t\t}\n\t\tif (index >= baseLength) {\n\t\t\tswiper.appendSlide(slides);\n\t\t\treturn;\n\t\t}\n\t\tlet newActiveIndex = activeIndexBuffer > index ? activeIndexBuffer + 1 : activeIndexBuffer;\n\t\tconst slidesBuffer = [];\n\t\tfor (let i = baseLength - 1; i >= index; i -= 1) {\n\t\t\tconst currentSlide = swiper.slides[i];\n\t\t\tcurrentSlide.remove();\n\t\t\tslidesBuffer.unshift(currentSlide);\n\t\t}\n\t\tif (typeof slides === 'object' && 'length' in slides) {\n\t\t\tfor (let i = 0; i < slides.length; i += 1) {\n\t\t\t\tif (slides[i]) slidesEl.append(slides[i]);\n\t\t\t}\n\t\t\tnewActiveIndex = activeIndexBuffer > index ? activeIndexBuffer + slides.length : activeIndexBuffer;\n\t\t} else {\n\t\t\tslidesEl.append(slides);\n\t\t}\n\t\tfor (let i = 0; i < slidesBuffer.length; i += 1) {\n\t\t\tslidesEl.append(slidesBuffer[i]);\n\t\t}\n\t\tswiper.recalcSlides();\n\t\tif (params.loop) {\n\t\t\tswiper.loopCreate();\n\t\t}\n\t\tif (!params.observer || swiper.isElement) {\n\t\t\tswiper.update();\n\t\t}\n\t\tif (params.loop) {\n\t\t\tswiper.slideTo(newActiveIndex + swiper.loopedSlides, 0, false);\n\t\t} else {\n\t\t\tswiper.slideTo(newActiveIndex, 0, false);\n\t\t}\n\t}\n\n\tfunction removeSlide(slidesIndexes) {\n\t\tconst swiper = this;\n\t\tconst {\n\t\t\tparams,\n\t\t\tactiveIndex\n\t\t} = swiper;\n\t\tlet activeIndexBuffer = activeIndex;\n\t\tif (params.loop) {\n\t\t\tactiveIndexBuffer -= swiper.loopedSlides;\n\t\t\tswiper.loopDestroy();\n\t\t}\n\t\tlet newActiveIndex = activeIndexBuffer;\n\t\tlet indexToRemove;\n\t\tif (typeof slidesIndexes === 'object' && 'length' in slidesIndexes) {\n\t\t\tfor (let i = 0; i < slidesIndexes.length; i += 1) {\n\t\t\t\tindexToRemove = slidesIndexes[i];\n\t\t\t\tif (swiper.slides[indexToRemove]) swiper.slides[indexToRemove].remove();\n\t\t\t\tif (indexToRemove < newActiveIndex) newActiveIndex -= 1;\n\t\t\t}\n\t\t\tnewActiveIndex = Math.max(newActiveIndex, 0);\n\t\t} else {\n\t\t\tindexToRemove = slidesIndexes;\n\t\t\tif (swiper.slides[indexToRemove]) swiper.slides[indexToRemove].remove();\n\t\t\tif (indexToRemove < newActiveIndex) newActiveIndex -= 1;\n\t\t\tnewActiveIndex = Math.max(newActiveIndex, 0);\n\t\t}\n\t\tswiper.recalcSlides();\n\t\tif (params.loop) {\n\t\t\tswiper.loopCreate();\n\t\t}\n\t\tif (!params.observer || swiper.isElement) {\n\t\t\tswiper.update();\n\t\t}\n\t\tif (params.loop) {\n\t\t\tswiper.slideTo(newActiveIndex + swiper.loopedSlides, 0, false);\n\t\t} else {\n\t\t\tswiper.slideTo(newActiveIndex, 0, false);\n\t\t}\n\t}\n\n\tfunction removeAllSlides() {\n\t\tconst swiper = this;\n\t\tconst slidesIndexes = [];\n\t\tfor (let i = 0; i < swiper.slides.length; i += 1) {\n\t\t\tslidesIndexes.push(i);\n\t\t}\n\t\tswiper.removeSlide(slidesIndexes);\n\t}\n\n\tfunction Manipulation(_ref) {\n\t\tlet {\n\t\t\tswiper\n\t\t} = _ref;\n\t\tObject.assign(swiper, {\n\t\t\tappendSlide: appendSlide.bind(swiper),\n\t\t\tprependSlide: prependSlide.bind(swiper),\n\t\t\taddSlide: addSlide.bind(swiper),\n\t\t\tremoveSlide: removeSlide.bind(swiper),\n\t\t\tremoveAllSlides: removeAllSlides.bind(swiper)\n\t\t});\n\t}\n\n\tfunction effectInit(params) {\n\t\tconst {\n\t\t\teffect,\n\t\t\tswiper,\n\t\t\ton,\n\t\t\tsetTranslate,\n\t\t\tsetTransition,\n\t\t\toverwriteParams,\n\t\t\tperspective,\n\t\t\trecreateShadows,\n\t\t\tgetEffectParams\n\t\t} = params;\n\t\ton('beforeInit', () => {\n\t\t\tif (swiper.params.effect !== effect) return;\n\t\t\tswiper.classNames.push(`${swiper.params.containerModifierClass}${effect}`);\n\t\t\tif (perspective && perspective()) {\n\t\t\t\tswiper.classNames.push(`${swiper.params.containerModifierClass}3d`);\n\t\t\t}\n\t\t\tconst overwriteParamsResult = overwriteParams ? overwriteParams() : {};\n\t\t\tObject.assign(swiper.params, overwriteParamsResult);\n\t\t\tObject.assign(swiper.originalParams, overwriteParamsResult);\n\t\t});\n\t\ton('setTranslate', () => {\n\t\t\tif (swiper.params.effect !== effect) return;\n\t\t\tsetTranslate();\n\t\t});\n\t\ton('setTransition', (_s, duration) => {\n\t\t\tif (swiper.params.effect !== effect) return;\n\t\t\tsetTransition(duration);\n\t\t});\n\t\ton('transitionEnd', () => {\n\t\t\tif (swiper.params.effect !== effect) return;\n\t\t\tif (recreateShadows) {\n\t\t\t\tif (!getEffectParams || !getEffectParams().slideShadows) return;\n\t\t\t\t// remove shadows\n\t\t\t\tswiper.slides.forEach(slideEl => {\n\t\t\t\t\tslideEl.querySelectorAll('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left').forEach(shadowEl => shadowEl.remove());\n\t\t\t\t});\n\t\t\t\t// create new one\n\t\t\t\trecreateShadows();\n\t\t\t}\n\t\t});\n\t\tlet requireUpdateOnVirtual;\n\t\ton('virtualUpdate', () => {\n\t\t\tif (swiper.params.effect !== effect) return;\n\t\t\tif (!swiper.slides.length) {\n\t\t\t\trequireUpdateOnVirtual = true;\n\t\t\t}\n\t\t\trequestAnimationFrame(() => {\n\t\t\t\tif (requireUpdateOnVirtual && swiper.slides && swiper.slides.length) {\n\t\t\t\t\tsetTranslate();\n\t\t\t\t\trequireUpdateOnVirtual = false;\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n\n\tfunction effectTarget(effectParams, slideEl) {\n\t\tconst transformEl = getSlideTransformEl(slideEl);\n\t\tif (transformEl !== slideEl) {\n\t\t\ttransformEl.style.backfaceVisibility = 'hidden';\n\t\t\ttransformEl.style['-webkit-backface-visibility'] = 'hidden';\n\t\t}\n\t\treturn transformEl;\n\t}\n\n\tfunction effectVirtualTransitionEnd(_ref) {\n\t\tlet {\n\t\t\tswiper,\n\t\t\tduration,\n\t\t\ttransformElements,\n\t\t\tallSlides\n\t\t} = _ref;\n\t\tconst {\n\t\t\tactiveIndex\n\t\t} = swiper;\n\t\tconst getSlide = el => {\n\t\t\tif (!el.parentElement) {\n\t\t\t\t// assume shadow root\n\t\t\t\tconst slide = swiper.slides.filter(slideEl => slideEl.shadowRoot && slideEl.shadowRoot === el.parentNode)[0];\n\t\t\t\treturn slide;\n\t\t\t}\n\t\t\treturn el.parentElement;\n\t\t};\n\t\tif (swiper.params.virtualTranslate && duration !== 0) {\n\t\t\tlet eventTriggered = false;\n\t\t\tlet transitionEndTarget;\n\t\t\tif (allSlides) {\n\t\t\t\ttransitionEndTarget = transformElements;\n\t\t\t} else {\n\t\t\t\ttransitionEndTarget = transformElements.filter(transformEl => {\n\t\t\t\t\tconst el = transformEl.classList.contains('swiper-slide-transform') ? getSlide(transformEl) : transformEl;\n\t\t\t\t\treturn swiper.getSlideIndex(el) === activeIndex;\n\t\t\t\t});\n\t\t\t}\n\t\t\ttransitionEndTarget.forEach(el => {\n\t\t\t\telementTransitionEnd(el, () => {\n\t\t\t\t\tif (eventTriggered) return;\n\t\t\t\t\tif (!swiper || swiper.destroyed) return;\n\t\t\t\t\teventTriggered = true;\n\t\t\t\t\tswiper.animating = false;\n\t\t\t\t\tconst evt = new window.CustomEvent('transitionend', {\n\t\t\t\t\t\tbubbles: true,\n\t\t\t\t\t\tcancelable: true\n\t\t\t\t\t});\n\t\t\t\t\tswiper.wrapperEl.dispatchEvent(evt);\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\t}\n\n\tfunction EffectFade(_ref) {\n\t\tlet {\n\t\t\tswiper,\n\t\t\textendParams,\n\t\t\ton\n\t\t} = _ref;\n\t\textendParams({\n\t\t\tfadeEffect: {\n\t\t\t\tcrossFade: false\n\t\t\t}\n\t\t});\n\t\tconst setTranslate = () => {\n\t\t\tconst {\n\t\t\t\tslides\n\t\t\t} = swiper;\n\t\t\tconst params = swiper.params.fadeEffect;\n\t\t\tfor (let i = 0; i < slides.length; i += 1) {\n\t\t\t\tconst slideEl = swiper.slides[i];\n\t\t\t\tconst offset = slideEl.swiperSlideOffset;\n\t\t\t\tlet tx = -offset;\n\t\t\t\tif (!swiper.params.virtualTranslate) tx -= swiper.translate;\n\t\t\t\tlet ty = 0;\n\t\t\t\tif (!swiper.isHorizontal()) {\n\t\t\t\t\tty = tx;\n\t\t\t\t\ttx = 0;\n\t\t\t\t}\n\t\t\t\tconst slideOpacity = swiper.params.fadeEffect.crossFade ? Math.max(1 - Math.abs(slideEl.progress), 0) : 1 + Math.min(Math.max(slideEl.progress, -1), 0);\n\t\t\t\tconst targetEl = effectTarget(params, slideEl);\n\t\t\t\ttargetEl.style.opacity = slideOpacity;\n\t\t\t\ttargetEl.style.transform = `translate3d(${tx}px, ${ty}px, 0px)`;\n\t\t\t}\n\t\t};\n\t\tconst setTransition = duration => {\n\t\t\tconst transformElements = swiper.slides.map(slideEl => getSlideTransformEl(slideEl));\n\t\t\ttransformElements.forEach(el => {\n\t\t\t\tel.style.transitionDuration = `${duration}ms`;\n\t\t\t});\n\t\t\teffectVirtualTransitionEnd({\n\t\t\t\tswiper,\n\t\t\t\tduration,\n\t\t\t\ttransformElements,\n\t\t\t\tallSlides: true\n\t\t\t});\n\t\t};\n\t\teffectInit({\n\t\t\teffect: 'fade',\n\t\t\tswiper,\n\t\t\ton,\n\t\t\tsetTranslate,\n\t\t\tsetTransition,\n\t\t\toverwriteParams: () => ({\n\t\t\t\tslidesPerView: 1,\n\t\t\t\tslidesPerGroup: 1,\n\t\t\t\twatchSlidesProgress: true,\n\t\t\t\tspaceBetween: 0,\n\t\t\t\tvirtualTranslate: !swiper.params.cssMode\n\t\t\t})\n\t\t});\n\t}\n\n\tfunction EffectCube(_ref) {\n\t\tlet {\n\t\t\tswiper,\n\t\t\textendParams,\n\t\t\ton\n\t\t} = _ref;\n\t\textendParams({\n\t\t\tcubeEffect: {\n\t\t\t\tslideShadows: true,\n\t\t\t\tshadow: true,\n\t\t\t\tshadowOffset: 20,\n\t\t\t\tshadowScale: 0.94\n\t\t\t}\n\t\t});\n\t\tconst createSlideShadows = (slideEl, progress, isHorizontal) => {\n\t\t\tlet shadowBefore = isHorizontal ? slideEl.querySelector('.swiper-slide-shadow-left') : slideEl.querySelector('.swiper-slide-shadow-top');\n\t\t\tlet shadowAfter = isHorizontal ? slideEl.querySelector('.swiper-slide-shadow-right') : slideEl.querySelector('.swiper-slide-shadow-bottom');\n\t\t\tif (!shadowBefore) {\n\t\t\t\tshadowBefore = createElement('div', `swiper-slide-shadow-cube swiper-slide-shadow-${isHorizontal ? 'left' : 'top'}`.split(' '));\n\t\t\t\tslideEl.append(shadowBefore);\n\t\t\t}\n\t\t\tif (!shadowAfter) {\n\t\t\t\tshadowAfter = createElement('div', `swiper-slide-shadow-cube swiper-slide-shadow-${isHorizontal ? 'right' : 'bottom'}`.split(' '));\n\t\t\t\tslideEl.append(shadowAfter);\n\t\t\t}\n\t\t\tif (shadowBefore) shadowBefore.style.opacity = Math.max(-progress, 0);\n\t\t\tif (shadowAfter) shadowAfter.style.opacity = Math.max(progress, 0);\n\t\t};\n\t\tconst recreateShadows = () => {\n\t\t\t// create new ones\n\t\t\tconst isHorizontal = swiper.isHorizontal();\n\t\t\tswiper.slides.forEach(slideEl => {\n\t\t\t\tconst progress = Math.max(Math.min(slideEl.progress, 1), -1);\n\t\t\t\tcreateSlideShadows(slideEl, progress, isHorizontal);\n\t\t\t});\n\t\t};\n\t\tconst setTranslate = () => {\n\t\t\tconst {\n\t\t\t\tel,\n\t\t\t\twrapperEl,\n\t\t\t\tslides,\n\t\t\t\twidth: swiperWidth,\n\t\t\t\theight: swiperHeight,\n\t\t\t\trtlTranslate: rtl,\n\t\t\t\tsize: swiperSize,\n\t\t\t\tbrowser\n\t\t\t} = swiper;\n\t\t\tconst params = swiper.params.cubeEffect;\n\t\t\tconst isHorizontal = swiper.isHorizontal();\n\t\t\tconst isVirtual = swiper.virtual && swiper.params.virtual.enabled;\n\t\t\tlet wrapperRotate = 0;\n\t\t\tlet cubeShadowEl;\n\t\t\tif (params.shadow) {\n\t\t\t\tif (isHorizontal) {\n\t\t\t\t\tcubeShadowEl = swiper.wrapperEl.querySelector('.swiper-cube-shadow');\n\t\t\t\t\tif (!cubeShadowEl) {\n\t\t\t\t\t\tcubeShadowEl = createElement('div', 'swiper-cube-shadow');\n\t\t\t\t\t\tswiper.wrapperEl.append(cubeShadowEl);\n\t\t\t\t\t}\n\t\t\t\t\tcubeShadowEl.style.height = `${swiperWidth}px`;\n\t\t\t\t} else {\n\t\t\t\t\tcubeShadowEl = el.querySelector('.swiper-cube-shadow');\n\t\t\t\t\tif (!cubeShadowEl) {\n\t\t\t\t\t\tcubeShadowEl = createElement('div', 'swiper-cube-shadow');\n\t\t\t\t\t\tel.append(cubeShadowEl);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (let i = 0; i < slides.length; i += 1) {\n\t\t\t\tconst slideEl = slides[i];\n\t\t\t\tlet slideIndex = i;\n\t\t\t\tif (isVirtual) {\n\t\t\t\t\tslideIndex = parseInt(slideEl.getAttribute('data-swiper-slide-index'), 10);\n\t\t\t\t}\n\t\t\t\tlet slideAngle = slideIndex * 90;\n\t\t\t\tlet round = Math.floor(slideAngle / 360);\n\t\t\t\tif (rtl) {\n\t\t\t\t\tslideAngle = -slideAngle;\n\t\t\t\t\tround = Math.floor(-slideAngle / 360);\n\t\t\t\t}\n\t\t\t\tconst progress = Math.max(Math.min(slideEl.progress, 1), -1);\n\t\t\t\tlet tx = 0;\n\t\t\t\tlet ty = 0;\n\t\t\t\tlet tz = 0;\n\t\t\t\tif (slideIndex % 4 === 0) {\n\t\t\t\t\ttx = -round * 4 * swiperSize;\n\t\t\t\t\ttz = 0;\n\t\t\t\t} else if ((slideIndex - 1) % 4 === 0) {\n\t\t\t\t\ttx = 0;\n\t\t\t\t\ttz = -round * 4 * swiperSize;\n\t\t\t\t} else if ((slideIndex - 2) % 4 === 0) {\n\t\t\t\t\ttx = swiperSize + round * 4 * swiperSize;\n\t\t\t\t\ttz = swiperSize;\n\t\t\t\t} else if ((slideIndex - 3) % 4 === 0) {\n\t\t\t\t\ttx = -swiperSize;\n\t\t\t\t\ttz = 3 * swiperSize + swiperSize * 4 * round;\n\t\t\t\t}\n\t\t\t\tif (rtl) {\n\t\t\t\t\ttx = -tx;\n\t\t\t\t}\n\t\t\t\tif (!isHorizontal) {\n\t\t\t\t\tty = tx;\n\t\t\t\t\ttx = 0;\n\t\t\t\t}\n\t\t\t\tconst transform = `rotateX(${isHorizontal ? 0 : -slideAngle}deg) rotateY(${isHorizontal ? slideAngle : 0}deg) translate3d(${tx}px, ${ty}px, ${tz}px)`;\n\t\t\t\tif (progress <= 1 && progress > -1) {\n\t\t\t\t\twrapperRotate = slideIndex * 90 + progress * 90;\n\t\t\t\t\tif (rtl) wrapperRotate = -slideIndex * 90 - progress * 90;\n\t\t\t\t\tif (swiper.browser && swiper.browser.need3dFix && Math.abs(wrapperRotate) / 90 % 2 === 1) {\n\t\t\t\t\t\twrapperRotate += 0.001;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tslideEl.style.transform = transform;\n\t\t\t\tif (params.slideShadows) {\n\t\t\t\t\tcreateSlideShadows(slideEl, progress, isHorizontal);\n\t\t\t\t}\n\t\t\t}\n\t\t\twrapperEl.style.transformOrigin = `50% 50% -${swiperSize / 2}px`;\n\t\t\twrapperEl.style['-webkit-transform-origin'] = `50% 50% -${swiperSize / 2}px`;\n\t\t\tif (params.shadow) {\n\t\t\t\tif (isHorizontal) {\n\t\t\t\t\tcubeShadowEl.style.transform = `translate3d(0px, ${swiperWidth / 2 + params.shadowOffset}px, ${-swiperWidth / 2}px) rotateX(89.99deg) rotateZ(0deg) scale(${params.shadowScale})`;\n\t\t\t\t} else {\n\t\t\t\t\tconst shadowAngle = Math.abs(wrapperRotate) - Math.floor(Math.abs(wrapperRotate) / 90) * 90;\n\t\t\t\t\tconst multiplier = 1.5 - (Math.sin(shadowAngle * 2 * Math.PI / 360) / 2 + Math.cos(shadowAngle * 2 * Math.PI / 360) / 2);\n\t\t\t\t\tconst scale1 = params.shadowScale;\n\t\t\t\t\tconst scale2 = params.shadowScale / multiplier;\n\t\t\t\t\tconst offset = params.shadowOffset;\n\t\t\t\t\tcubeShadowEl.style.transform = `scale3d(${scale1}, 1, ${scale2}) translate3d(0px, ${swiperHeight / 2 + offset}px, ${-swiperHeight / 2 / scale2}px) rotateX(-89.99deg)`;\n\t\t\t\t}\n\t\t\t}\n\t\t\tconst zFactor = (browser.isSafari || browser.isWebView) && browser.needPerspectiveFix ? -swiperSize / 2 : 0;\n\t\t\twrapperEl.style.transform = `translate3d(0px,0,${zFactor}px) rotateX(${swiper.isHorizontal() ? 0 : wrapperRotate}deg) rotateY(${swiper.isHorizontal() ? -wrapperRotate : 0}deg)`;\n\t\t\twrapperEl.style.setProperty('--swiper-cube-translate-z', `${zFactor}px`);\n\t\t};\n\t\tconst setTransition = duration => {\n\t\t\tconst {\n\t\t\t\tel,\n\t\t\t\tslides\n\t\t\t} = swiper;\n\t\t\tslides.forEach(slideEl => {\n\t\t\t\tslideEl.style.transitionDuration = `${duration}ms`;\n\t\t\t\tslideEl.querySelectorAll('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left').forEach(subEl => {\n\t\t\t\t\tsubEl.style.transitionDuration = `${duration}ms`;\n\t\t\t\t});\n\t\t\t});\n\t\t\tif (swiper.params.cubeEffect.shadow && !swiper.isHorizontal()) {\n\t\t\t\tconst shadowEl = el.querySelector('.swiper-cube-shadow');\n\t\t\t\tif (shadowEl) shadowEl.style.transitionDuration = `${duration}ms`;\n\t\t\t}\n\t\t};\n\t\teffectInit({\n\t\t\teffect: 'cube',\n\t\t\tswiper,\n\t\t\ton,\n\t\t\tsetTranslate,\n\t\t\tsetTransition,\n\t\t\trecreateShadows,\n\t\t\tgetEffectParams: () => swiper.params.cubeEffect,\n\t\t\tperspective: () => true,\n\t\t\toverwriteParams: () => ({\n\t\t\t\tslidesPerView: 1,\n\t\t\t\tslidesPerGroup: 1,\n\t\t\t\twatchSlidesProgress: true,\n\t\t\t\tresistanceRatio: 0,\n\t\t\t\tspaceBetween: 0,\n\t\t\t\tcenteredSlides: false,\n\t\t\t\tvirtualTranslate: true\n\t\t\t})\n\t\t});\n\t}\n\n\tfunction createShadow(suffix, slideEl, side) {\n\t\tconst shadowClass = `swiper-slide-shadow${side ? `-${side}` : ''}${suffix ? ` swiper-slide-shadow-${suffix}` : ''}`;\n\t\tconst shadowContainer = getSlideTransformEl(slideEl);\n\t\tlet shadowEl = shadowContainer.querySelector(`.${shadowClass.split(' ').join('.')}`);\n\t\tif (!shadowEl) {\n\t\t\tshadowEl = createElement('div', shadowClass.split(' '));\n\t\t\tshadowContainer.append(shadowEl);\n\t\t}\n\t\treturn shadowEl;\n\t}\n\n\tfunction EffectFlip(_ref) {\n\t\tlet {\n\t\t\tswiper,\n\t\t\textendParams,\n\t\t\ton\n\t\t} = _ref;\n\t\textendParams({\n\t\t\tflipEffect: {\n\t\t\t\tslideShadows: true,\n\t\t\t\tlimitRotation: true\n\t\t\t}\n\t\t});\n\t\tconst createSlideShadows = (slideEl, progress) => {\n\t\t\tlet shadowBefore = swiper.isHorizontal() ? slideEl.querySelector('.swiper-slide-shadow-left') : slideEl.querySelector('.swiper-slide-shadow-top');\n\t\t\tlet shadowAfter = swiper.isHorizontal() ? slideEl.querySelector('.swiper-slide-shadow-right') : slideEl.querySelector('.swiper-slide-shadow-bottom');\n\t\t\tif (!shadowBefore) {\n\t\t\t\tshadowBefore = createShadow('flip', slideEl, swiper.isHorizontal() ? 'left' : 'top');\n\t\t\t}\n\t\t\tif (!shadowAfter) {\n\t\t\t\tshadowAfter = createShadow('flip', slideEl, swiper.isHorizontal() ? 'right' : 'bottom');\n\t\t\t}\n\t\t\tif (shadowBefore) shadowBefore.style.opacity = Math.max(-progress, 0);\n\t\t\tif (shadowAfter) shadowAfter.style.opacity = Math.max(progress, 0);\n\t\t};\n\t\tconst recreateShadows = () => {\n\t\t\t// Set shadows\n\t\t\tswiper.params.flipEffect;\n\t\t\tswiper.slides.forEach(slideEl => {\n\t\t\t\tlet progress = slideEl.progress;\n\t\t\t\tif (swiper.params.flipEffect.limitRotation) {\n\t\t\t\t\tprogress = Math.max(Math.min(slideEl.progress, 1), -1);\n\t\t\t\t}\n\t\t\t\tcreateSlideShadows(slideEl, progress);\n\t\t\t});\n\t\t};\n\t\tconst setTranslate = () => {\n\t\t\tconst {\n\t\t\t\tslides,\n\t\t\t\trtlTranslate: rtl\n\t\t\t} = swiper;\n\t\t\tconst params = swiper.params.flipEffect;\n\t\t\tfor (let i = 0; i < slides.length; i += 1) {\n\t\t\t\tconst slideEl = slides[i];\n\t\t\t\tlet progress = slideEl.progress;\n\t\t\t\tif (swiper.params.flipEffect.limitRotation) {\n\t\t\t\t\tprogress = Math.max(Math.min(slideEl.progress, 1), -1);\n\t\t\t\t}\n\t\t\t\tconst offset = slideEl.swiperSlideOffset;\n\t\t\t\tconst rotate = -180 * progress;\n\t\t\t\tlet rotateY = rotate;\n\t\t\t\tlet rotateX = 0;\n\t\t\t\tlet tx = swiper.params.cssMode ? -offset - swiper.translate : -offset;\n\t\t\t\tlet ty = 0;\n\t\t\t\tif (!swiper.isHorizontal()) {\n\t\t\t\t\tty = tx;\n\t\t\t\t\ttx = 0;\n\t\t\t\t\trotateX = -rotateY;\n\t\t\t\t\trotateY = 0;\n\t\t\t\t} else if (rtl) {\n\t\t\t\t\trotateY = -rotateY;\n\t\t\t\t}\n\t\t\t\tif (swiper.browser && swiper.browser.need3dFix) {\n\t\t\t\t\tif (Math.abs(rotateY) / 90 % 2 === 1) {\n\t\t\t\t\t\trotateY += 0.001;\n\t\t\t\t\t}\n\t\t\t\t\tif (Math.abs(rotateX) / 90 % 2 === 1) {\n\t\t\t\t\t\trotateX += 0.001;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tslideEl.style.zIndex = -Math.abs(Math.round(progress)) + slides.length;\n\t\t\t\tif (params.slideShadows) {\n\t\t\t\t\tcreateSlideShadows(slideEl, progress);\n\t\t\t\t}\n\t\t\t\tconst transform = `translate3d(${tx}px, ${ty}px, 0px) rotateX(${rotateX}deg) rotateY(${rotateY}deg)`;\n\t\t\t\tconst targetEl = effectTarget(params, slideEl);\n\t\t\t\ttargetEl.style.transform = transform;\n\t\t\t}\n\t\t};\n\t\tconst setTransition = duration => {\n\t\t\tconst transformElements = swiper.slides.map(slideEl => getSlideTransformEl(slideEl));\n\t\t\ttransformElements.forEach(el => {\n\t\t\t\tel.style.transitionDuration = `${duration}ms`;\n\t\t\t\tel.querySelectorAll('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left').forEach(shadowEl => {\n\t\t\t\t\tshadowEl.style.transitionDuration = `${duration}ms`;\n\t\t\t\t});\n\t\t\t});\n\t\t\teffectVirtualTransitionEnd({\n\t\t\t\tswiper,\n\t\t\t\tduration,\n\t\t\t\ttransformElements\n\t\t\t});\n\t\t};\n\t\teffectInit({\n\t\t\teffect: 'flip',\n\t\t\tswiper,\n\t\t\ton,\n\t\t\tsetTranslate,\n\t\t\tsetTransition,\n\t\t\trecreateShadows,\n\t\t\tgetEffectParams: () => swiper.params.flipEffect,\n\t\t\tperspective: () => true,\n\t\t\toverwriteParams: () => ({\n\t\t\t\tslidesPerView: 1,\n\t\t\t\tslidesPerGroup: 1,\n\t\t\t\twatchSlidesProgress: true,\n\t\t\t\tspaceBetween: 0,\n\t\t\t\tvirtualTranslate: !swiper.params.cssMode\n\t\t\t})\n\t\t});\n\t}\n\n\tfunction EffectCoverflow(_ref) {\n\t\tlet {\n\t\t\tswiper,\n\t\t\textendParams,\n\t\t\ton\n\t\t} = _ref;\n\t\textendParams({\n\t\t\tcoverflowEffect: {\n\t\t\t\trotate: 50,\n\t\t\t\tstretch: 0,\n\t\t\t\tdepth: 100,\n\t\t\t\tscale: 1,\n\t\t\t\tmodifier: 1,\n\t\t\t\tslideShadows: true\n\t\t\t}\n\t\t});\n\t\tconst setTranslate = () => {\n\t\t\tconst {\n\t\t\t\twidth: swiperWidth,\n\t\t\t\theight: swiperHeight,\n\t\t\t\tslides,\n\t\t\t\tslidesSizesGrid\n\t\t\t} = swiper;\n\t\t\tconst params = swiper.params.coverflowEffect;\n\t\t\tconst isHorizontal = swiper.isHorizontal();\n\t\t\tconst transform = swiper.translate;\n\t\t\tconst center = isHorizontal ? -transform + swiperWidth / 2 : -transform + swiperHeight / 2;\n\t\t\tconst rotate = isHorizontal ? params.rotate : -params.rotate;\n\t\t\tconst translate = params.depth;\n\t\t\t// Each slide offset from center\n\t\t\tfor (let i = 0, length = slides.length; i < length; i += 1) {\n\t\t\t\tconst slideEl = slides[i];\n\t\t\t\tconst slideSize = slidesSizesGrid[i];\n\t\t\t\tconst slideOffset = slideEl.swiperSlideOffset;\n\t\t\t\tconst centerOffset = (center - slideOffset - slideSize / 2) / slideSize;\n\t\t\t\tconst offsetMultiplier = typeof params.modifier === 'function' ? params.modifier(centerOffset) : centerOffset * params.modifier;\n\t\t\t\tlet rotateY = isHorizontal ? rotate * offsetMultiplier : 0;\n\t\t\t\tlet rotateX = isHorizontal ? 0 : rotate * offsetMultiplier;\n\t\t\t\t// var rotateZ = 0\n\t\t\t\tlet translateZ = -translate * Math.abs(offsetMultiplier);\n\t\t\t\tlet stretch = params.stretch;\n\t\t\t\t// Allow percentage to make a relative stretch for responsive sliders\n\t\t\t\tif (typeof stretch === 'string' && stretch.indexOf('%') !== -1) {\n\t\t\t\t\tstretch = parseFloat(params.stretch) / 100 * slideSize;\n\t\t\t\t}\n\t\t\t\tlet translateY = isHorizontal ? 0 : stretch * offsetMultiplier;\n\t\t\t\tlet translateX = isHorizontal ? stretch * offsetMultiplier : 0;\n\t\t\t\tlet scale = 1 - (1 - params.scale) * Math.abs(offsetMultiplier);\n\n\t\t\t\t// Fix for ultra small values\n\t\t\t\tif (Math.abs(translateX) < 0.001) translateX = 0;\n\t\t\t\tif (Math.abs(translateY) < 0.001) translateY = 0;\n\t\t\t\tif (Math.abs(translateZ) < 0.001) translateZ = 0;\n\t\t\t\tif (Math.abs(rotateY) < 0.001) rotateY = 0;\n\t\t\t\tif (Math.abs(rotateX) < 0.001) rotateX = 0;\n\t\t\t\tif (Math.abs(scale) < 0.001) scale = 0;\n\t\t\t\tif (swiper.browser && swiper.browser.need3dFix) {\n\t\t\t\t\tif (Math.abs(rotateY) / 90 % 2 === 1) {\n\t\t\t\t\t\trotateY += 0.001;\n\t\t\t\t\t}\n\t\t\t\t\tif (Math.abs(rotateX) / 90 % 2 === 1) {\n\t\t\t\t\t\trotateX += 0.001;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tconst slideTransform = `translate3d(${translateX}px,${translateY}px,${translateZ}px)  rotateX(${rotateX}deg) rotateY(${rotateY}deg) scale(${scale})`;\n\t\t\t\tconst targetEl = effectTarget(params, slideEl);\n\t\t\t\ttargetEl.style.transform = slideTransform;\n\t\t\t\tslideEl.style.zIndex = -Math.abs(Math.round(offsetMultiplier)) + 1;\n\t\t\t\tif (params.slideShadows) {\n\t\t\t\t\t// Set shadows\n\t\t\t\t\tlet shadowBeforeEl = isHorizontal ? slideEl.querySelector('.swiper-slide-shadow-left') : slideEl.querySelector('.swiper-slide-shadow-top');\n\t\t\t\t\tlet shadowAfterEl = isHorizontal ? slideEl.querySelector('.swiper-slide-shadow-right') : slideEl.querySelector('.swiper-slide-shadow-bottom');\n\t\t\t\t\tif (!shadowBeforeEl) {\n\t\t\t\t\t\tshadowBeforeEl = createShadow('coverflow', slideEl, isHorizontal ? 'left' : 'top');\n\t\t\t\t\t}\n\t\t\t\t\tif (!shadowAfterEl) {\n\t\t\t\t\t\tshadowAfterEl = createShadow('coverflow', slideEl, isHorizontal ? 'right' : 'bottom');\n\t\t\t\t\t}\n\t\t\t\t\tif (shadowBeforeEl) shadowBeforeEl.style.opacity = offsetMultiplier > 0 ? offsetMultiplier : 0;\n\t\t\t\t\tif (shadowAfterEl) shadowAfterEl.style.opacity = -offsetMultiplier > 0 ? -offsetMultiplier : 0;\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tconst setTransition = duration => {\n\t\t\tconst transformElements = swiper.slides.map(slideEl => getSlideTransformEl(slideEl));\n\t\t\ttransformElements.forEach(el => {\n\t\t\t\tel.style.transitionDuration = `${duration}ms`;\n\t\t\t\tel.querySelectorAll('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left').forEach(shadowEl => {\n\t\t\t\t\tshadowEl.style.transitionDuration = `${duration}ms`;\n\t\t\t\t});\n\t\t\t});\n\t\t};\n\t\teffectInit({\n\t\t\teffect: 'coverflow',\n\t\t\tswiper,\n\t\t\ton,\n\t\t\tsetTranslate,\n\t\t\tsetTransition,\n\t\t\tperspective: () => true,\n\t\t\toverwriteParams: () => ({\n\t\t\t\twatchSlidesProgress: true\n\t\t\t})\n\t\t});\n\t}\n\n\tfunction EffectCreative(_ref) {\n\t\tlet {\n\t\t\tswiper,\n\t\t\textendParams,\n\t\t\ton\n\t\t} = _ref;\n\t\textendParams({\n\t\t\tcreativeEffect: {\n\t\t\t\tlimitProgress: 1,\n\t\t\t\tshadowPerProgress: false,\n\t\t\t\tprogressMultiplier: 1,\n\t\t\t\tperspective: true,\n\t\t\t\tprev: {\n\t\t\t\t\ttranslate: [0, 0, 0],\n\t\t\t\t\trotate: [0, 0, 0],\n\t\t\t\t\topacity: 1,\n\t\t\t\t\tscale: 1\n\t\t\t\t},\n\t\t\t\tnext: {\n\t\t\t\t\ttranslate: [0, 0, 0],\n\t\t\t\t\trotate: [0, 0, 0],\n\t\t\t\t\topacity: 1,\n\t\t\t\t\tscale: 1\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\tconst getTranslateValue = value => {\n\t\t\tif (typeof value === 'string') return value;\n\t\t\treturn `${value}px`;\n\t\t};\n\t\tconst setTranslate = () => {\n\t\t\tconst {\n\t\t\t\tslides,\n\t\t\t\twrapperEl,\n\t\t\t\tslidesSizesGrid\n\t\t\t} = swiper;\n\t\t\tconst params = swiper.params.creativeEffect;\n\t\t\tconst {\n\t\t\t\tprogressMultiplier: multiplier\n\t\t\t} = params;\n\t\t\tconst isCenteredSlides = swiper.params.centeredSlides;\n\t\t\tif (isCenteredSlides) {\n\t\t\t\tconst margin = slidesSizesGrid[0] / 2 - swiper.params.slidesOffsetBefore || 0;\n\t\t\t\twrapperEl.style.transform = `translateX(calc(50% - ${margin}px))`;\n\t\t\t}\n\t\t\tfor (let i = 0; i < slides.length; i += 1) {\n\t\t\t\tconst slideEl = slides[i];\n\t\t\t\tconst slideProgress = slideEl.progress;\n\t\t\t\tconst progress = Math.min(Math.max(slideEl.progress, -params.limitProgress), params.limitProgress);\n\t\t\t\tlet originalProgress = progress;\n\t\t\t\tif (!isCenteredSlides) {\n\t\t\t\t\toriginalProgress = Math.min(Math.max(slideEl.originalProgress, -params.limitProgress), params.limitProgress);\n\t\t\t\t}\n\t\t\t\tconst offset = slideEl.swiperSlideOffset;\n\t\t\t\tconst t = [swiper.params.cssMode ? -offset - swiper.translate : -offset, 0, 0];\n\t\t\t\tconst r = [0, 0, 0];\n\t\t\t\tlet custom = false;\n\t\t\t\tif (!swiper.isHorizontal()) {\n\t\t\t\t\tt[1] = t[0];\n\t\t\t\t\tt[0] = 0;\n\t\t\t\t}\n\t\t\t\tlet data = {\n\t\t\t\t\ttranslate: [0, 0, 0],\n\t\t\t\t\trotate: [0, 0, 0],\n\t\t\t\t\tscale: 1,\n\t\t\t\t\topacity: 1\n\t\t\t\t};\n\t\t\t\tif (progress < 0) {\n\t\t\t\t\tdata = params.next;\n\t\t\t\t\tcustom = true;\n\t\t\t\t} else if (progress > 0) {\n\t\t\t\t\tdata = params.prev;\n\t\t\t\t\tcustom = true;\n\t\t\t\t}\n\t\t\t\t// set translate\n\t\t\t\tt.forEach((value, index) => {\n\t\t\t\t\tt[index] = `calc(${value}px + (${getTranslateValue(data.translate[index])} * ${Math.abs(progress * multiplier)}))`;\n\t\t\t\t});\n\t\t\t\t// set rotates\n\t\t\t\tr.forEach((value, index) => {\n\t\t\t\t\tlet val = data.rotate[index] * Math.abs(progress * multiplier);\n\t\t\t\t\tif (swiper.browser && swiper.browser.need3dFix && Math.abs(val) / 90 % 2 === 1) {\n\t\t\t\t\t\tval += 0.001;\n\t\t\t\t\t}\n\t\t\t\t\tr[index] = val;\n\t\t\t\t});\n\t\t\t\tslideEl.style.zIndex = -Math.abs(Math.round(slideProgress)) + slides.length;\n\t\t\t\tconst translateString = t.join(', ');\n\t\t\t\tconst rotateString = `rotateX(${r[0]}deg) rotateY(${r[1]}deg) rotateZ(${r[2]}deg)`;\n\t\t\t\tconst scaleString = originalProgress < 0 ? `scale(${1 + (1 - data.scale) * originalProgress * multiplier})` : `scale(${1 - (1 - data.scale) * originalProgress * multiplier})`;\n\t\t\t\tconst opacityString = originalProgress < 0 ? 1 + (1 - data.opacity) * originalProgress * multiplier : 1 - (1 - data.opacity) * originalProgress * multiplier;\n\t\t\t\tconst transform = `translate3d(${translateString}) ${rotateString} ${scaleString}`;\n\n\t\t\t\t// Set shadows\n\t\t\t\tif (custom && data.shadow || !custom) {\n\t\t\t\t\tlet shadowEl = slideEl.querySelector('.swiper-slide-shadow');\n\t\t\t\t\tif (!shadowEl && data.shadow) {\n\t\t\t\t\t\tshadowEl = createShadow('creative', slideEl);\n\t\t\t\t\t}\n\t\t\t\t\tif (shadowEl) {\n\t\t\t\t\t\tconst shadowOpacity = params.shadowPerProgress ? progress * (1 / params.limitProgress) : progress;\n\t\t\t\t\t\tshadowEl.style.opacity = Math.min(Math.max(Math.abs(shadowOpacity), 0), 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tconst targetEl = effectTarget(params, slideEl);\n\t\t\t\ttargetEl.style.transform = transform;\n\t\t\t\ttargetEl.style.opacity = opacityString;\n\t\t\t\tif (data.origin) {\n\t\t\t\t\ttargetEl.style.transformOrigin = data.origin;\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tconst setTransition = duration => {\n\t\t\tconst transformElements = swiper.slides.map(slideEl => getSlideTransformEl(slideEl));\n\t\t\ttransformElements.forEach(el => {\n\t\t\t\tel.style.transitionDuration = `${duration}ms`;\n\t\t\t\tel.querySelectorAll('.swiper-slide-shadow').forEach(shadowEl => {\n\t\t\t\t\tshadowEl.style.transitionDuration = `${duration}ms`;\n\t\t\t\t});\n\t\t\t});\n\t\t\teffectVirtualTransitionEnd({\n\t\t\t\tswiper,\n\t\t\t\tduration,\n\t\t\t\ttransformElements,\n\t\t\t\tallSlides: true\n\t\t\t});\n\t\t};\n\t\teffectInit({\n\t\t\teffect: 'creative',\n\t\t\tswiper,\n\t\t\ton,\n\t\t\tsetTranslate,\n\t\t\tsetTransition,\n\t\t\tperspective: () => swiper.params.creativeEffect.perspective,\n\t\t\toverwriteParams: () => ({\n\t\t\t\twatchSlidesProgress: true,\n\t\t\t\tvirtualTranslate: !swiper.params.cssMode\n\t\t\t})\n\t\t});\n\t}\n\n\tfunction EffectCards(_ref) {\n\t\tlet {\n\t\t\tswiper,\n\t\t\textendParams,\n\t\t\ton\n\t\t} = _ref;\n\t\textendParams({\n\t\t\tcardsEffect: {\n\t\t\t\tslideShadows: true,\n\t\t\t\trotate: true,\n\t\t\t\tperSlideRotate: 2,\n\t\t\t\tperSlideOffset: 8\n\t\t\t}\n\t\t});\n\t\tconst setTranslate = () => {\n\t\t\tconst {\n\t\t\t\tslides,\n\t\t\t\tactiveIndex,\n\t\t\t\trtlTranslate: rtl\n\t\t\t} = swiper;\n\t\t\tconst params = swiper.params.cardsEffect;\n\t\t\tconst {\n\t\t\t\tstartTranslate,\n\t\t\t\tisTouched\n\t\t\t} = swiper.touchEventsData;\n\t\t\tconst currentTranslate = rtl ? -swiper.translate : swiper.translate;\n\t\t\tfor (let i = 0; i < slides.length; i += 1) {\n\t\t\t\tconst slideEl = slides[i];\n\t\t\t\tconst slideProgress = slideEl.progress;\n\t\t\t\tconst progress = Math.min(Math.max(slideProgress, -4), 4);\n\t\t\t\tlet offset = slideEl.swiperSlideOffset;\n\t\t\t\tif (swiper.params.centeredSlides && !swiper.params.cssMode) {\n\t\t\t\t\tswiper.wrapperEl.style.transform = `translateX(${swiper.minTranslate()}px)`;\n\t\t\t\t}\n\t\t\t\tif (swiper.params.centeredSlides && swiper.params.cssMode) {\n\t\t\t\t\toffset -= slides[0].swiperSlideOffset;\n\t\t\t\t}\n\t\t\t\tlet tX = swiper.params.cssMode ? -offset - swiper.translate : -offset;\n\t\t\t\tlet tY = 0;\n\t\t\t\tconst tZ = -100 * Math.abs(progress);\n\t\t\t\tlet scale = 1;\n\t\t\t\tlet rotate = -params.perSlideRotate * progress;\n\t\t\t\tlet tXAdd = params.perSlideOffset - Math.abs(progress) * 0.75;\n\t\t\t\tconst slideIndex = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.from + i : i;\n\t\t\t\tconst isSwipeToNext = (slideIndex === activeIndex || slideIndex === activeIndex - 1) && progress > 0 && progress < 1 && (isTouched || swiper.params.cssMode) && currentTranslate < startTranslate;\n\t\t\t\tconst isSwipeToPrev = (slideIndex === activeIndex || slideIndex === activeIndex + 1) && progress < 0 && progress > -1 && (isTouched || swiper.params.cssMode) && currentTranslate > startTranslate;\n\t\t\t\tif (isSwipeToNext || isSwipeToPrev) {\n\t\t\t\t\tconst subProgress = (1 - Math.abs((Math.abs(progress) - 0.5) / 0.5)) ** 0.5;\n\t\t\t\t\trotate += -28 * progress * subProgress;\n\t\t\t\t\tscale += -0.5 * subProgress;\n\t\t\t\t\ttXAdd += 96 * subProgress;\n\t\t\t\t\ttY = `${-25 * subProgress * Math.abs(progress)}%`;\n\t\t\t\t}\n\t\t\t\tif (progress < 0) {\n\t\t\t\t\t// next\n\t\t\t\t\ttX = `calc(${tX}px ${rtl ? '-' : '+'} (${tXAdd * Math.abs(progress)}%))`;\n\t\t\t\t} else if (progress > 0) {\n\t\t\t\t\t// prev\n\t\t\t\t\ttX = `calc(${tX}px ${rtl ? '-' : '+'} (-${tXAdd * Math.abs(progress)}%))`;\n\t\t\t\t} else {\n\t\t\t\t\ttX = `${tX}px`;\n\t\t\t\t}\n\t\t\t\tif (!swiper.isHorizontal()) {\n\t\t\t\t\tconst prevY = tY;\n\t\t\t\t\ttY = tX;\n\t\t\t\t\ttX = prevY;\n\t\t\t\t}\n\t\t\t\tconst scaleString = progress < 0 ? `${1 + (1 - scale) * progress}` : `${1 - (1 - scale) * progress}`;\n\n\t\t\t\t/* eslint-disable */\n\t\t\t\tconst transform = `\n        translate3d(${tX}, ${tY}, ${tZ}px)\n        rotateZ(${params.rotate ? rtl ? -rotate : rotate : 0}deg)\n        scale(${scaleString})\n      `;\n\t\t\t\t/* eslint-enable */\n\n\t\t\t\tif (params.slideShadows) {\n\t\t\t\t\t// Set shadows\n\t\t\t\t\tlet shadowEl = slideEl.querySelector('.swiper-slide-shadow');\n\t\t\t\t\tif (!shadowEl) {\n\t\t\t\t\t\tshadowEl = createShadow('cards', slideEl);\n\t\t\t\t\t}\n\t\t\t\t\tif (shadowEl) shadowEl.style.opacity = Math.min(Math.max((Math.abs(progress) - 0.5) / 0.5, 0), 1);\n\t\t\t\t}\n\t\t\t\tslideEl.style.zIndex = -Math.abs(Math.round(slideProgress)) + slides.length;\n\t\t\t\tconst targetEl = effectTarget(params, slideEl);\n\t\t\t\ttargetEl.style.transform = transform;\n\t\t\t}\n\t\t};\n\t\tconst setTransition = duration => {\n\t\t\tconst transformElements = swiper.slides.map(slideEl => getSlideTransformEl(slideEl));\n\t\t\ttransformElements.forEach(el => {\n\t\t\t\tel.style.transitionDuration = `${duration}ms`;\n\t\t\t\tel.querySelectorAll('.swiper-slide-shadow').forEach(shadowEl => {\n\t\t\t\t\tshadowEl.style.transitionDuration = `${duration}ms`;\n\t\t\t\t});\n\t\t\t});\n\t\t\teffectVirtualTransitionEnd({\n\t\t\t\tswiper,\n\t\t\t\tduration,\n\t\t\t\ttransformElements\n\t\t\t});\n\t\t};\n\t\teffectInit({\n\t\t\teffect: 'cards',\n\t\t\tswiper,\n\t\t\ton,\n\t\t\tsetTranslate,\n\t\t\tsetTransition,\n\t\t\tperspective: () => true,\n\t\t\toverwriteParams: () => ({\n\t\t\t\twatchSlidesProgress: true,\n\t\t\t\tvirtualTranslate: !swiper.params.cssMode\n\t\t\t})\n\t\t});\n\t}\n\n\t/**\n\t * Swiper 11.1.4\n\t * Most modern mobile touch slider and framework with hardware accelerated transitions\n\t * https://swiperjs.com\n\t *\n\t * Copyright 2014-2024 Vladimir Kharlampidi\n\t *\n\t * Released under the MIT License\n\t *\n\t * Released on: May 30, 2024\n\t */\n\n\n\t// Swiper Class\n\tconst modules = [Virtual, Keyboard, Mousewheel, Navigation, Pagination, Scrollbar, Parallax, Zoom, Controller, A11y, History, HashNavigation, Autoplay, Thumb, freeMode, Grid, Manipulation, EffectFade, EffectCube, EffectFlip, EffectCoverflow, EffectCreative, EffectCards];\n\tSwiper.use(modules);\n\n\treturn Swiper;\n\n})();\n\n\n//# sourceURL=webpack://funiro/./src/js/libs/swiper-bundle.js?");

/***/ }),

/***/ "./src/js/vendors.js":
/*!***************************!*\
  !*** ./src/js/vendors.js ***!
  \***************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n// import './libs/swiper.js';\n\n//# sourceURL=webpack://funiro/./src/js/vendors.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	__webpack_require__("./src/js/vendors.js");
/******/ 	var __webpack_exports__ = __webpack_require__("./src/js/app.js");
/******/ 	
/******/ })()
;